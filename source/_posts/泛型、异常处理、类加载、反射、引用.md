---
layout: post
title: 泛型、异常处理、类加载、反射、引用
category: Java
---

# 泛型、异常处理、类加载、反射、引用

## 泛型

概念：一种编译时概念，表明容器对象内部元素类型，支持在编译时校验元素类型，但在运行时擦除的元素具体类型，统一用Object表示。简言之，泛型能够使**类型**（类和接口）在定义类，接口和方法的时候参数化。好处：消除类型转换。



### java6泛型

```java
Map<String, String> myMap = new HashMap<String, String>();
```

### java7泛型

```java
Map<String, String> myMap = new HashMap<>();
```

### java8泛型

1. 支持通过方法上下文推断泛型目标类型

2. 支持在方法调用链路当中，泛型类型推断传递到最后一个方法

   ```
   List<String> list = new ArrayList<>();
   list.addAll(new ArrayList<>());
   ```

### 泛型通配符：

1. 泛型通配符：`?`

表示任意类型的泛型类型。

```java
List<?> list = new ArrayList<String>();
list = new ArrayList<Integer>();
```

2. 通配符继承(**上界< ? extends Class>**)：`? extend Object `

   ```
   List<? extends Number> list = new ArrayList<>();
   list = new ArrayList<Number>();
   list = new ArrayList<Integer>();
   Number number = list.get(0);
   ```

   list中存放的都是Number的子类型表示的对象，这里表示存放有任意类型的子类型，所以反而不能向里面添加元素，要添加的元素编译器无法判断是否与List中的元素类型相同。

   ​

3. 通配符超类(**下界< ? super Class>**)：`? super Object`

   ```
   List<? super Number> list = new ArrayList<>();
   list.add(new Integer(1));
   list.add(new Long(1L));
   Object object = list.get(0);
   ```

   list中存放的都是Number的超类能表示的对象，这里表示能存放任意类型的超类，所以意味着可以向list中添加任意类型的对象，因为Object是Number的超类，所以list能存放任意的object对象。

4. * 如果要从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends) 
   * 如果要从集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super) 
   * 如果既要存又要取，那么就不要使用任何通配符。



## 异常处理

![image](https://tvax4.sinaimg.cn/large/007S2YVMgy1gdzjfcitv6j30hs0bcacg.jpg)

实践：

1. 在所有方法上标记方法内被抛出的异常（无论是受检异常还是运行时异常），写注释时增加异常的注释信息

2. 建立统一的自定义异常处理和通用异常处理

3. 了解try-catch-finally顺序

   1. 不管有木有出现异常，finally块中代码都会执行；
   2. 当try和catch中有return时，finally仍然会执行；
   3. finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；
   4. finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值

4. 了解异常堆栈信息

   异常堆栈信息提供了导致异常出现的方法调用链的精确顺序，包括每个方法调用的类名，方法名，代码文件名甚至行数，以此来精确定位异常出现的现场。

5. try-catch与性能

   try-catch块会影响性能，但是并非很多，仅仅最重要的是只有在发生异常时，收集调用堆栈比较复杂。如果不抛出异常，那么性能消耗完全不明显。但是我们推荐的是尽量少用try-catch，因为代码的复杂度和可理解性的原因

   ​

## 类加载器

这个东西用的实在实在太少。不说了，有兴趣的人可以自己去了解。

## 反射

很多Java框架，都跟反射离不开关系。因为有反射，所以框架实现了对通用数据结构的解析。反射实现了对Java对象元数据的获取。通过丰富的元数据，可以灵活地实现动态查询和赋值，例如动态调用方法、动态设置字段值。

| 方法关键字                                  | 含义                                       |
| -------------------------------------- | ---------------------------------------- |
| getDeclaredMethods()                   | 获取所有的方法                                  |
| getReturnType()                        | 获得方法的放回类型                                |
| getParameterTypes()                    | 获得方法的传入参数类型                              |
| getDeclaredMethod("方法名",参数类型.class,……) | 获得特定的方法                                  |
|                                        |                                          |
| 构造方法关键字                                | 含义                                       |
| getDeclaredConstructors()              | 获取所有的构造方法                                |
| getDeclaredConstructor(参数类型.class,……)  | 获取特定的构造方法                                |
|                                        |                                          |
| 父类和父接口                                 | 含义                                       |
| getSuperclass()                        | 获取某类的父类                                  |
| getInterfaces()                        | 获取某类实现的接口                                |
|                                        |                                          |
| 字段                                     |                                          |
| getFields()                            | 获得某个类的所有的公共(public)的字段,包括父类。             |
| getDeclaredFields()                    | 获得某个类的所有申明的字段,即包括public、private和proteced，不包括父类 |



1. Accessable: Accessible并不是标识方法能否访问的. public的方法 Accessible仍为false .
   Accessable属性是继承自AccessibleObject 类. 功能是启用或禁用安全检查。将此对象的 accessible 标志设置为指示的布尔值。值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查。

   当isAccessible()的结果是false时不允许通过外部类反射访问私有字段。

2. 反射获取注解

   这个是一个比较常用的方法，尤其在写AOP切面时。

   通过AOP的功能，我们可以拦截指定带有注解的方法。在执行AOP时，可以通过方法对象来获取注解上的参数。

   | method.getAnnoations()           | 获取方法上所有注解                 |
   | -------------------------------- | ------------------------- |
   | method.getDeclaredAnnotations()  | 获取当前方法上的注解，忽略继承来的注解       |
   | method.getParameterAnnotations() | 获取方法参数上的注解，返回一个二维数组       |
   | method.getAnnotatedReturnType()  | jdk1.8，返回方法返回值上的注解类型      |
   | method.getAnnotation(class)      | 根据类型返回单个注解，了解@ Repeatable |
   | method.getAnnotationsByType      | 根据类型返回注解数组                |
   | field、class省略                    |                           |

   http://www.howsoftworks.net/javaapi/java.lang/indexclass.html





## 引用：

值传递：方法调用时，实际参数把它的值传递给对应的形式参数，方法执行中形式参数值的改变不影响实际参 数的值。

引用传递：也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，方法执行中形式参数值的改变将会影响实际参数的值。

Java中都是地址值引用，并不是引用传递。



⑴强引用（StrongReference）
强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。  ps：强引用其实也就是我们平时A a = new A()这个意思。

⑵软引用（SoftReference）
如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存（下文给出示例）。
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

⑶弱引用（WeakReference）
弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

⑷虚引用（PhantomReference）
“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。