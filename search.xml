<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ELK部署图</title>
    <url>/2020/04/19/ELK%E9%83%A8%E7%BD%B2%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="ELK部署图"><a href="#ELK部署图" class="headerlink" title="ELK部署图"></a>ELK部署图</h1><p>ELK 常用架构及使用场景介绍<br>在这个章节中，我们将介绍几种常用架构及使用场景。</p>
<p>最简单架构<br>在这种架构中，只有一个 Logstash、Elasticsearch 和 Kibana 实例。Logstash 通过输入插件从多种数据源（比如日志文件、标准输入 Stdin 等）获取数据，再经过滤插件加工数据，然后经 Elasticsearch 输出插件输出到 Elasticsearch，通过 Kibana 展示。详见图 1。</p>
<h3 id="最简单架构"><a href="#最简单架构" class="headerlink" title="最简单架构"></a>最简单架构</h3><p>这种架构非常简单，使用场景也有限。初学者可以搭建这个架构，了解 ELK 如何工作。</p>
<p>Logstash 作为日志搜集器<br>这种架构是对上面架构的扩展，把一个 Logstash 数据搜集节点扩展到多个，分布于多台机器，将解析好的数据发送到 Elasticsearch server 进行存储，最后在 Kibana 查询、生成日志报表等。详见图 2。</p>
<p><img src="https://tvax3.sinaimg.cn/large/007S2YVMgy1gdzje8vav1j30jm05iweq.jpg" alt="image"></p>
<h3 id="Logstash-作为日志搜索器"><a href="#Logstash-作为日志搜索器" class="headerlink" title="Logstash 作为日志搜索器"></a>Logstash 作为日志搜索器</h3><p>这种结构因为需要在各个服务器上部署 Logstash，而它比较消耗 CPU 和内存资源，所以比较适合计算资源丰富的服务器，否则容易造成服务器性能下降，甚至可能导致无法正常工作。</p>
<p><img src="https://tva4.sinaimg.cn/large/007S2YVMgy1gdzjdvduhwj30db09bq38.jpg" alt="image"></p>
<h3 id="Beats-作为日志搜集器"><a href="#Beats-作为日志搜集器" class="headerlink" title="Beats 作为日志搜集器"></a>Beats 作为日志搜集器</h3><p>这种架构引入 Beats 作为日志搜集器。目前 Beats 包括四种：</p>
<p>Packetbeat（搜集网络流量数据）；<br>Topbeat（搜集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）；<br>Filebeat（搜集文件数据）；<br>Winlogbeat（搜集 Windows 事件日志数据）。<br>Beats 将搜集到的数据发送到 Logstash，经 Logstash 解析、过滤后，将其发送到 Elasticsearch 存储，并由 Kibana 呈现给用户。详见图 3。</p>
<p>图 3. Beats 作为日志搜集器<br><img src="https://tva4.sinaimg.cn/large/007S2YVMgy1gdzjd84rztj30gl0bx755.jpg" alt="image"></p>
<p>这种架构解决了 Logstash 在各服务器节点上占用系统资源高的问题。相比 Logstash，Beats 所占系统的 CPU 和内存几乎可以忽略不计。另外，Beats 和 Logstash 之间支持 SSL/TLS 加密传输，客户端和服务器双向认证，保证了通信安全。</p>
<p>因此这种架构适合对数据安全性要求较高，同时各服务器性能比较敏感的场景。</p>
<p>引入消息队列机制的架构<br>到笔者整理本文时，Beats 还不支持输出到消息队列，所以在消息队列前后两端只能是 Logstash 实例。这种架构使用 Logstash 从各个数据源搜集数据，然后经消息队列输出插件输出到消息队列中。目前 Logstash 支持 Kafka、Redis、RabbitMQ 等常见消息队列。然后 Logstash 通过消息队列输入插件从队列中获取数据，分析过滤后经输出插件发送到 Elasticsearch，最后通过 Kibana 展示。详见图 4。</p>
<h3 id="引入消息队列机制的架构"><a href="#引入消息队列机制的架构" class="headerlink" title="引入消息队列机制的架构"></a>引入消息队列机制的架构</h3><p>这种架构适合于日志规模比较庞大的情况。但由于 Logstash 日志解析节点和 Elasticsearch 的负荷比较重，可将他们配置为集群模式，以分担负荷。引入消息队列，均衡了网络传输，从而降低了网络闭塞，尤其是丢失数据的可能性，但依然存在 Logstash 占用系统资源过多的问题。</p>
<p>基于 Filebeat 架构的配置部署详解<br>前面提到 Filebeat 已经完全替代了 Logstash-Forwarder 成为新一代的日志采集器，同时鉴于它轻量、安全等特点，越来越多人开始使用它。这个章节将详细讲解如何部署基于 Filebeat 的 ELK 集中式日志解决方案，具体架构见图 5。</p>
<p><img src="https://tva3.sinaimg.cn/large/007S2YVMgy1gdzjcajurcj30jp0960tf.jpg" alt="image"></p>
<h3 id="基于-Filebeat-的-ELK-集群架构"><a href="#基于-Filebeat-的-ELK-集群架构" class="headerlink" title="基于 Filebeat 的 ELK 集群架构"></a>基于 Filebeat 的 ELK 集群架构</h3><p>因为免费的 ELK 没有任何安全机制，所以这里使用了 Nginx 作反向代理，避免用户直接访问 Kibana 服务器。加上配置 Nginx 实现简单的用户认证，一定程度上提高安全性。另外，Nginx 本身具有负载均衡的作用，能够提高系统访问性能。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S2YVMgy1gdzj9s0ovfj30n508wt9l.jpg" alt="image"></p>
<p>转载自 <a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk-filebeat/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-elk-filebeat/index.html</a></p>
]]></content>
      <categories>
        <category>日志采集</category>
      </categories>
  </entry>
  <entry>
    <title>ELK环境搭建</title>
    <url>/2020/04/19/Elk%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="ELK环境搭建"><a href="#ELK环境搭建" class="headerlink" title="ELK环境搭建"></a>ELK环境搭建</h1><p>[TOC]</p>
<p>ELK 是 ElasticSearch、 LogStash、 Kibana 三个开源工具的简称，现在还包括 Beats，其分工如下:</p>
<ul>
<li>LogStash/Beats: 负责数据的收集与处理</li>
<li>ElasticSearch: 一个开源的分布式搜索引擎，负责数据的存储、检索和分析</li>
<li>Kibana: 提供了可视化的界面。负责数据的可视化操作</li>
</ul>
<p>基于 ELK Stack 可以构建日志分析平台、数据分析搜索平台等非常有用的项目。</p>
<p>作为学习笔记的第一篇，简单介绍下 ELK 各个软件的安装与简单配置，快速的搭建一个日志的查询平台</p>
<h3 id="一-ElasticSearch-的安装与运行"><a href="#一-ElasticSearch-的安装与运行" class="headerlink" title="一. ElasticSearch 的安装与运行"></a>一. ElasticSearch 的安装与运行</h3><p>ES 是一个基于 Lucene 的使用 Java 开发的开源搜索引擎，因此其运行是基于 JVM 的，因此在安装之前需要保证已经安装了 Java 环境。ES 要求使用 Java8 或者更高版本的 Java 环境。</p>
<p>确定机器已经安装了 Java 环境后，就可以安装 ES 了。官网提供了压缩包可以直接下载，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载压缩包</span><br><span class="line">wget https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;elasticsearch&#x2F;elasticsearch-6.3.0.tar.gz</span><br><span class="line"># 解压</span><br><span class="line">tar -xzf elasticsearch-6.3.0.tar.gz</span><br><span class="line"># 进入文件</span><br><span class="line">cd elasticsearch-6.3.0&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>

<p>下载解压完成后进入目录，启动命令在 bin 目录下，直接运行命令就可以启动了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;elasticsearch</span><br></pre></td></tr></table></figure>

<p>ElasticSearch 的默认启动端口是 9200。手动访问出现如下信息说明启动成功。</p>
<p>集群搭建：</p>
<p><strong>ip:172.20.9.23</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#cluster.name: my-application</span><br><span class="line"> node.name: node-1 </span><br><span class="line"> path.data: &#x2F;data&#x2F;es-data</span><br><span class="line"># Path to log files:</span><br><span class="line"> path.logs: &#x2F;var&#x2F;log&#x2F;elasticsearch&#x2F;</span><br><span class="line"> network.host: 172.20.9.23</span><br><span class="line"> http.port: 9200</span><br><span class="line"> http.cors.enabled: true</span><br><span class="line"> http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"># 允许HTTP请求的方法类型 </span><br><span class="line"> http.cors.allow-methods: OPTIONS,HEAD,GET,POST,PUT,DELETE</span><br><span class="line"># 允许HTTP请求头返回类型</span><br><span class="line"> http.cors.allow-headers: X-Requested-With,Content-Type,Content-Length,Authorization,Content-Encoding,Accept-Encoding</span><br><span class="line"># 支持HTTP访问API 总开关</span><br><span class="line"> http.enabled: true</span><br><span class="line"> discovery.zen.ping.unicast.hosts: [&quot;172.20.9.23&quot;, &quot;172.20.9.22&quot;, &quot;172.20.9.24&quot;]</span><br><span class="line"># 节点角色</span><br><span class="line"> node.master: true</span><br><span class="line"> node.data: true</span><br><span class="line"> node.ingest: false</span><br><span class="line"> search.remote.connect: false</span><br><span class="line"> discovery.zen.minimum_master_nodes: 2</span><br><span class="line"> gateway.recover_after_nodes: 3</span><br></pre></td></tr></table></figure>

<p><strong>ip:172.20.9.22</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cluster.name: my-application</span><br><span class="line"> node.name: node-1 </span><br><span class="line"> path.data: &#x2F;data&#x2F;es-data</span><br><span class="line"># Path to log files:</span><br><span class="line"> path.logs: &#x2F;var&#x2F;log&#x2F;elasticsearch&#x2F;</span><br><span class="line"> network.host: 172.20.9.22</span><br><span class="line"> http.port: 9200</span><br><span class="line"> http.enabled: true</span><br><span class="line"> discovery.zen.ping.unicast.hosts: [&quot;172.20.9.23&quot;, &quot;172.20.9.22&quot;, &quot;172.20.9.24&quot;]</span><br><span class="line"># 节点角色</span><br><span class="line"> node.master: true</span><br><span class="line"> node.data: true</span><br><span class="line"> node.ingest: false</span><br><span class="line"> search.remote.connect: false</span><br><span class="line"> discovery.zen.minimum_master_nodes: 2</span><br><span class="line"> gateway.recover_after_nodes: 3</span><br></pre></td></tr></table></figure>

<p><strong>ip:172.20.9.24</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cluster.name: my-application</span><br><span class="line"> node.name: node-1 </span><br><span class="line"> path.data: &#x2F;data&#x2F;es-data</span><br><span class="line"># Path to log files:</span><br><span class="line"> path.logs: &#x2F;var&#x2F;log&#x2F;elasticsearch&#x2F;</span><br><span class="line"> network.host: 172.20.9.24</span><br><span class="line"> http.port: 9200</span><br><span class="line"> http.enabled: true</span><br><span class="line"> discovery.zen.ping.unicast.hosts: [&quot;172.20.9.23&quot;, &quot;172.20.9.22&quot;, &quot;172.20.9.24&quot;]</span><br><span class="line"># 节点角色</span><br><span class="line"> node.master: false</span><br><span class="line"> node.data: true</span><br><span class="line"> node.ingest: false</span><br><span class="line"> search.remote.connect: false</span><br><span class="line"> discovery.zen.minimum_master_nodes: 2</span><br><span class="line"> gateway.recover_after_nodes: 3</span><br></pre></td></tr></table></figure>

<h3 id="二-Head插件安装"><a href="#二-Head插件安装" class="headerlink" title="二.Head插件安装"></a>二.Head插件安装</h3><p><strong>（1）安装NodeJS</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# yum install -y nodejs</span><br><span class="line">或者自己下载tar文件解压</span><br></pre></td></tr></table></figure>

<p>wget <a href="https://npm.taobao.org/mirrors/node/latest-v4.x/node-v4.5.0-linux-x64.tar.gz" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/node/latest-v4.x/node-v4.5.0-linux-x64.tar.gz</a></p>
<p>tar -zxvf node-v4.5.0-linux-x64.tar.gz</p>
<p>配置下环境变量,编辑/etc/profile添加</p>
<p>export NODE_HOME=/usr/local/node-v4.5.0-linux-x64<br>export PATH=$PATH:$NODE_HOME/bin/<br>export NODE_PATH=$NODE_HOME/lib/node_modules</p>
<p>执行 source /etc/profile</p>
<p><strong>（2）安装npm</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]#  npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p><strong>（3）使用npm安装grunt</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# npm install -g grunt</span><br><span class="line">[root@node1 ~]#</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# npm install -g grunt-cli --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org --no-proxy</span><br><span class="line">[root@node1 ~]#</span><br></pre></td></tr></table></figure>

<p><strong>（4）版本确认</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[es@node1 ~]$ node -v</span><br><span class="line">[es@node1 ~]$ npm -v</span><br><span class="line">[es@node1 ~]$ grunt -version</span><br><span class="line">[es@node1 ~]$</span><br></pre></td></tr></table></figure>

<p><strong>（5）下载head插件源码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[es@node1 ~]$ wget https:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head&#x2F;archive&#x2F;master.zip</span><br><span class="line">[es@node1 ~]$ unzip master.zip</span><br></pre></td></tr></table></figure>

<p><strong>（6）下载依赖</strong><br>进入elasticsearch-head-master目录，执行下面命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[es@node1 elasticsearch-head-master]$ npm install</span><br><span class="line">[es@node1 elasticsearch-head-master]$</span><br></pre></td></tr></table></figure>

<p>如果上面命令安装较慢或失败，可以尝试国内镜像安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[es@node1 elasticsearch-head-master]$ sudo npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">[sudo] password for es: </span><br><span class="line">[es@node1 elasticsearch-head-master]$ cnpm install</span><br><span class="line">[es@node1 elasticsearch-head-master]$</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>（0）停止ElasticSearch</strong><br>如果ElasticSearch已经启动，需要先停止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[es@node1 ~]$ jps</span><br><span class="line">3261 Elasticsearch</span><br><span class="line">3375 Jps</span><br><span class="line">[es@node1 ~]$ kill 3261</span><br></pre></td></tr></table></figure>



<p><strong>（1）配置 ElasticSearch，使得HTTP对外提供服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[es@node1 elasticsearch-6.1.1]$ vi config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure>

<p>添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 增加新的参数，这样head插件可以访问es。设置参数的时候:后面要有空格</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>

<p><strong>（2）修改Head插件配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[es@node1 elasticsearch-head-master]$ vi Gruntfile.js</span><br></pre></td></tr></table></figure>

<p>找到connect：server，添加hostname一项，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect: &#123;</span><br><span class="line">                        server: &#123;</span><br><span class="line">                                options: &#123;</span><br><span class="line">                                        hostname: &#39;0.0.0.0&#39;,</span><br><span class="line">                                        port: 9100,</span><br><span class="line">                                        base: &#39;.&#39;,</span><br><span class="line">                                        keepalive: true</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><strong>（1）启动elasticsearch</strong><br>首先确认elasticsearch已经启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[es@node1 elasticsearch-6.1.1]$ bin&#x2F;elasticsearch -d</span><br><span class="line">[es@node1 elasticsearch-6.1.1]$ jps</span><br><span class="line">3451 Jps</span><br><span class="line">3436 Elasticsearch</span><br><span class="line">[es@node1 elasticsearch-6.1.1]$</span><br></pre></td></tr></table></figure>

<p><strong>（2）启动head</strong><br>通过命令<code>grunt server</code>启动head</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[es@node1 elasticsearch-head-master]$ grunt server</span><br><span class="line">需要在head的目录下运行</span><br></pre></td></tr></table></figure>

<p>或者通过命令<code>npm run start</code>也可以启动head</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[es@node1 elasticsearch-head-master]$ npm run start</span><br></pre></td></tr></table></figure>

<p><strong>（3）访问9100端口</strong><br><a href="http://node1:9100/" target="_blank" rel="noopener">http://172.20.9.23:9100/</a></p>
<h3 id="三-FileBeats-与-LogStash-的安装"><a href="#三-FileBeats-与-LogStash-的安装" class="headerlink" title="三. FileBeats 与 LogStash 的安装"></a>三. FileBeats 与 LogStash 的安装</h3><p>LogStash 可以用来对日志进行收集并进行过滤整理后输出到 ES 中，FileBeats 是一个更加轻量级的日志收集工具。<br>现在最常用的方式是通过 FileBeats 收集目标日志，然后统一输出到 LogStash 做进一步的过滤，在由 LogStash 输出到 ES 中进行存储。</p>
<h4 id="1-LogStash-的安装运行"><a href="#1-LogStash-的安装运行" class="headerlink" title="1. LogStash 的安装运行"></a>1. LogStash 的安装运行</h4><p>官方提供了压缩包下载， <a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="noopener">https://www.elastic.co/downloads/logstash</a> 。 下载完成后解压即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zxvf logstash-6.3.0.tar.gz</span><br><span class="line"># 进入目录</span><br><span class="line">cd logstash-6.3.0</span><br></pre></td></tr></table></figure>

<p>LogStash 的运行需要指定一个配置文件，来指定数据的流向，我们在当前目录下创建一个 first.conf 文件，其内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置输入为 beats</span><br><span class="line">input &#123;</span><br><span class="line">    beats &#123;</span><br><span class="line">            port &#x3D;&gt; &quot;5044&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 数据过滤</span><br><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">            match &#x3D;&gt; &#123; &quot;message&quot; &#x3D;&gt; &quot;%&#123;COMBINEDAPACHELOG&#125;&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    geoip &#123;</span><br><span class="line">            source &#x3D;&gt; &quot;clientip&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出到本机的 ES</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">            hosts &#x3D;&gt; [ &quot;172.20.9.23:9200&quot;  ]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面配置了 LogStash 输出日志到 ES 中，具体字段在后面的笔记中会详细介绍，这里先用起来再说。<br>配置完成后就可以通过如下方式启动 LogStash 了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;logstash -f first.conf --config.reload.automatic1</span><br></pre></td></tr></table></figure>

<p>可以看到命令行会打印出如下信息， 可以看到 LogStash 默认端口为 5044:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2018-03-08T23:12:44,087][WARN ][logstash.config.source.multilocal] Ignoring the &#39;pipelines.yml&#39; file because modules or command line options are specified</span><br><span class="line">[2018-03-08T23:12:44,925][INFO ][logstash.runner          ] Starting Logstash &#123;&quot;logstash.version&quot;&#x3D;&gt;&quot;6.2.2&quot;&#125;</span><br><span class="line">[2018-03-08T23:12:45,623][INFO ][logstash.agent           ] Successfully started Logstash API endpoint &#123;:port&#x3D;&gt;9600&#125;</span><br><span class="line">[2018-03-08T23:12:49,960][INFO ][logstash.pipeline        ] Starting pipeline &#123;:pipeline_id&#x3D;&gt;&quot;main&quot;, &quot;pipeline.workers&quot;&#x3D;&gt;4, &quot;pipeline.batch.size&quot;&#x3D;&gt;125, &quot;pipeline.batch.delay&quot;&#x3D;&gt;50&#125;</span><br><span class="line">[2018-03-08T23:12:50,882][INFO ][logstash.outputs.elasticsearch] Elasticsearch pool URLs updated &#123;:changes&#x3D;&gt;&#123;:removed&#x3D;&gt;[], :added&#x3D;&gt;[http:&#x2F;&#x2F;localhost:9200&#x2F;]&#125;&#125;</span><br><span class="line">[2018-03-08T23:12:50,894][INFO ][logstash.outputs.elasticsearch] Running health check to see if an Elasticsearch connection is working &#123;:healthcheck_url&#x3D;&gt;http:&#x2F;&#x2F;localhost:9200&#x2F;, :path&#x3D;&gt;&quot;&#x2F;&quot;&#125;</span><br><span class="line">[2018-03-08T23:12:51,303][WARN ][logstash.outputs.elasticsearch] Restored connection to ES instance &#123;:url&#x3D;&gt;&quot;http:&#x2F;&#x2F;localhost:9200&#x2F;&quot;&#125;</span><br><span class="line">[2018-03-08T23:12:51,595][INFO ][logstash.outputs.elasticsearch] ES Output version determined &#123;:es_version&#x3D;&gt;nil&#125;</span><br><span class="line">[2018-03-08T23:12:51,604][WARN ][logstash.outputs.elasticsearch] Detected a 6.x and above cluster: the &#96;type&#96; event field won&#39;t be used to determine the document _type &#123;:es_version&#x3D;&gt;6&#125;</span><br><span class="line">[2018-03-08T23:12:51,641][INFO ][logstash.outputs.elasticsearch] Using mapping template from &#123;:path&#x3D;&gt;nil&#125;</span><br><span class="line">[2018-03-08T23:12:51,676][INFO ][logstash.outputs.elasticsearch] Attempting to install template &#123;:manage_template&#x3D;&gt;&#123;&quot;template&quot;&#x3D;&gt;&quot;logstash-*&quot;, &quot;version&quot;&#x3D;&gt;60001, &quot;settings&quot;&#x3D;&gt;&#123;&quot;index.refresh_interval&quot;&#x3D;&gt;&quot;5s&quot;&#125;, &quot;mappings&quot;&#x3D;&gt;&#123;&quot;_default_&quot;&#x3D;&gt;&#123;&quot;dynamic_templates&quot;&#x3D;&gt;[&#123;&quot;message_field&quot;&#x3D;&gt;&#123;&quot;path_match&quot;&#x3D;&gt;&quot;message&quot;, &quot;match_mapping_type&quot;&#x3D;&gt;&quot;string&quot;, &quot;mapping&quot;&#x3D;&gt;&#123;&quot;type&quot;&#x3D;&gt;&quot;text&quot;, &quot;norms&quot;&#x3D;&gt;false&#125;&#125;&#125;, &#123;&quot;string_fields&quot;&#x3D;&gt;&#123;&quot;match&quot;&#x3D;&gt;&quot;*&quot;, &quot;match_mapping_type&quot;&#x3D;&gt;&quot;string&quot;, &quot;mapping&quot;&#x3D;&gt;&#123;&quot;type&quot;&#x3D;&gt;&quot;text&quot;, &quot;norms&quot;&#x3D;&gt;false, &quot;fields&quot;&#x3D;&gt;&#123;&quot;keyword&quot;&#x3D;&gt;&#123;&quot;type&quot;&#x3D;&gt;&quot;keyword&quot;, &quot;ignore_above&quot;&#x3D;&gt;256&#125;&#125;&#125;&#125;&#125;], &quot;properties&quot;&#x3D;&gt;&#123;&quot;@timestamp&quot;&#x3D;&gt;&#123;&quot;type&quot;&#x3D;&gt;&quot;date&quot;&#125;, &quot;@version&quot;&#x3D;&gt;&#123;&quot;type&quot;&#x3D;&gt;&quot;keyword&quot;&#125;, &quot;geoip&quot;&#x3D;&gt;&#123;&quot;dynamic&quot;&#x3D;&gt;true, &quot;properties&quot;&#x3D;&gt;&#123;&quot;ip&quot;&#x3D;&gt;&#123;&quot;type&quot;&#x3D;&gt;&quot;ip&quot;&#125;, &quot;location&quot;&#x3D;&gt;&#123;&quot;type&quot;&#x3D;&gt;&quot;geo_point&quot;&#125;, &quot;latitude&quot;&#x3D;&gt;&#123;&quot;type&quot;&#x3D;&gt;&quot;half_float&quot;&#125;, &quot;longitude&quot;&#x3D;&gt;&#123;&quot;type&quot;&#x3D;&gt;&quot;half_float&quot;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;</span><br><span class="line">[2018-03-08T23:12:51,773][INFO ][logstash.outputs.elasticsearch] New Elasticsearch output &#123;:class&#x3D;&gt;&quot;LogStash::Outputs::ElasticSearch&quot;, :hosts&#x3D;&gt;[&quot;&#x2F;&#x2F;localhost:9200&quot;]&#125;</span><br><span class="line">[2018-03-08T23:12:52,176][INFO ][logstash.filters.geoip   ] Using geoip database &#123;:path&#x3D;&gt;&quot;&#x2F;Users&#x2F;zouyingjie&#x2F;soft&#x2F;study&#x2F;ELK&#x2F;logstash-6.2.2&#x2F;vendor&#x2F;bundle&#x2F;jruby&#x2F;2.3.0&#x2F;gems&#x2F;logstash-filter-geoip-5.0.3-java&#x2F;vendor&#x2F;GeoLite2-City.mmdb&quot;&#125;</span><br><span class="line">[2018-03-08T23:12:53,026][INFO ][logstash.inputs.beats    ] Beats inputs: Starting input listener &#123;:address&#x3D;&gt;&quot;0.0.0.0:5044&quot;&#125;</span><br><span class="line">[2018-03-08T23:12:53,195][INFO ][logstash.pipeline        ] Pipeline started succesfully &#123;:pipeline_id&#x3D;&gt;&quot;main&quot;, :thread&#x3D;&gt;&quot;#&lt;Thread:0x66461e40 run&gt;&quot;&#125;</span><br><span class="line">[2018-03-08T23:12:53,290][INFO ][org.logstash.beats.Server] Starting server on port: 5044</span><br><span class="line">[2018-03-08T23:12:53,401][INFO ][logstash.agent           ] Pipelines running &#123;:count&#x3D;&gt;1, :pipelines&#x3D;&gt;[&quot;main&quot;]&#125;</span><br><span class="line">123456789101112131415161718</span><br></pre></td></tr></table></figure>

<h4 id="2-安装运行-FileBeats"><a href="#2-安装运行-FileBeats" class="headerlink" title="2. 安装运行 FileBeats"></a>2. 安装运行 FileBeats</h4><p>FileBeats 也提供了下载包，地址为 <a href="https://www.elastic.co/downloads/beats/filebeat" target="_blank" rel="noopener">https://www.elastic.co/downloads/beats/filebeat</a> 。找到系统对应的包下载后解压即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zxvf filebeat-6.3.0-darwin-x86_64.tar.gz</span><br><span class="line">cd filebeat-6.3.0-darwin-x86_6412</span><br></pre></td></tr></table></figure>

<p>进入目录编辑 filebeat.yml 找到对应的配置项，配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- type: log</span><br><span class="line">   # Change to true to enable this prospector configuration.</span><br><span class="line">    enabled: True</span><br><span class="line"></span><br><span class="line">    # Paths that should be crawled and fetched. Glob based paths.</span><br><span class="line">    # 读取 Nginx 的日志</span><br><span class="line">    paths:</span><br><span class="line">      - &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;*.log</span><br><span class="line"></span><br><span class="line">#----------------------------- Logstash output --------------------------------</span><br><span class="line"># 输出到本机的 LogStash</span><br><span class="line">output.logstash:</span><br><span class="line">  # The Logstash hosts</span><br><span class="line">  hosts: [&quot;172.20.9.23:5044&quot;，&quot;172.20.9.22:5044&quot;，&quot;172.20.9.24:5044&quot;]</span><br></pre></td></tr></table></figure>

<p>配置完成后执行如下命令，启动 FileBeat 即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># FileBeat 需要以 root 身份启动，因此先更改配置文件的权限</span><br><span class="line">sudo chown root filebeat.yml</span><br><span class="line">sudo .&#x2F;filebeat -e -c filebeat.yml -d &quot;publish&quot;</span><br></pre></td></tr></table></figure>

<h3 id="四-Kibana-的安装运行"><a href="#四-Kibana-的安装运行" class="headerlink" title="四. Kibana 的安装运行"></a>四. Kibana 的安装运行</h3><p>Kibana 也提供了对应的安装包下载，链接为 <a href="https://www.elastic.co/downloads/kibana" target="_blank" rel="noopener">https://www.elastic.co/downloads/kibana</a> , Mac、Linux、Win 都有对应的安装包，直接下载解压即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zxvf kibana-6.3.0-darwin-x86_64.tar.gz</span><br><span class="line">cd kibana-6.3.0-darwin-x86_64</span><br><span class="line"># 直接启动即可</span><br><span class="line">bin&#x2F;kibana</span><br></pre></td></tr></table></figure>

<p>Kibana 默认链接了本机的 9200 端口，其绑定的端口为 5601，启动成功后直接访问 172.20.9.23:5601 端口即可,界面如下。我因为安装了 x-pack 插件因此显示的项可能会多一些，这个暂时忽略.</p>
]]></content>
      <categories>
        <category>日志采集</category>
      </categories>
      <tags>
        <tag>日志采集</tag>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>Git约定</title>
    <url>/2020/04/19/Git%E7%BA%A6%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="Git约定"><a href="#Git约定" class="headerlink" title="Git约定"></a>Git约定</h1><p>[TOC]</p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ol>
<li><p>版本号分3段，比如 A.B.C。（主版本号.次版本号.修订号）</p>
<p>A 表示大版本号</p>
<p>B 表示功能更新</p>
<p>C 表示小修改</p>
<p>修复问题但不影响API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。</p>
<p>​</p>
</li>
<li><p>版本号修饰词</p>
<ul>
<li><p>版本号与修饰词之间，用<strong>中划线</strong>“-“连接。</p>
</li>
<li><p>测试或开发中的版本号，可以用日期做修饰</p>
</li>
<li><p>当开发产品或项目时，使用该版本号约定</p>
<blockquote>
<p>alpha: 内部版本<br>beta: 测试版<br>release：正式版发布<br>lts: 长期维护</p>
<p>示例：</p>
<p>1.0.0-alpha</p>
<p>1.0.0-alpha-20180101</p>
</blockquote>
</li>
<li><p>当开发工具模块时，使用下面的版本号约定</p>
<blockquote>
<p>snapshot</p>
<p>release</p>
<p>示例：</p>
<p>1.0.0-snapshot</p>
<p>1.0.0-release-20180101</p>
</blockquote>
</li>
<li><p>版本号默认起点：0.0.1</p>
</li>
<li><p>版本号发布后的软件，禁止修改，如需修改，必须以新版本发布</p>
</li>
<li><p>每当主版本号递增时，次版本号和修订号“必须 MUST ”归零</p>
</li>
<li><p>MAVEN项目的版本号命名和Git标签的版本号尽量保持一致。对alpha版本号和beta版本号允许maven和git不同。</p>
</li>
</ul>
</li>
<li><p>文档参考：<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">https://semver.org/lang/zh-CN/</a></p>
</li>
</ol>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><img src="https://tva1.sinaimg.cn/large/007S2YVMgy1gdzj05dq4vj30vy16cwhl.jpg" alt="image"></p>
<ol>
<li><p>必须存在的分支：master，develop</p>
</li>
<li><p>约定的分支命名：master，develop，feature，bugfix（取代hotfix命名），release。</p>
</li>
<li><p>分支名修饰名，按照任务名称或者任务编号命名，用<strong>中划线</strong>分割</p>
<p>示例：feature-user，bugfix-1101</p>
</li>
<li><p>release分支使用</p>
<ul>
<li>用途：更新版本号，修复bug，发布测试版本</li>
<li>release分支完成后，要合并到master上。</li>
<li>当项目较简单时，可以没有release分支，直接将develop合并至master</li>
</ul>
</li>
<li><p>bugfix如果是需要在master分支修复，则需要将bugfix分支同时合并到develop和master分支，并升级master版本号。</p>
</li>
<li><p>当根据该Git项目生产出多个子项目时，需要将master分支检出为多个受保护的项目分支，作为子项目的主分支</p>
</li>
<li><p>子项目分支可以从master分支合并稳定的新的特性功能，把master分支作为一个通用功能开发的主分支。</p>
</li>
<li><p>如果master分支的历史版本需要修复，那么需要将重新检出该历史版本做一个新的保护分支，作为历史版本的主分支，在该版本上修复bug。</p>
<p>历史版本主分支命名：主版本号.次版本号.x，示例：v1.0.x</p>
</li>
<li><p>文档参考：<a href="http://blog.csdn.net/hherima/article/details/50386011" target="_blank" rel="noopener">http://blog.csdn.net/hherima/article/details/50386011</a></p>
</li>
</ol>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ol>
<li><p>这里的Git标签，一般就是约定的Git版本号，尽量参考版本号的说明</p>
</li>
<li><p>标签必须打在master分支或release分支</p>
</li>
<li><p>标签约定用”v” + 版本号，例如：v1.0.0</p>
<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>约定</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate Validator 6.0.5.Final （一）</title>
    <url>/2020/04/19/Hibernate%20Validator%206.0.5.Final%20(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="Hibernate-Validator-6-0-5-Final-（一）"><a href="#Hibernate-Validator-6-0-5-Final-（一）" class="headerlink" title="Hibernate Validator 6.0.5.Final （一）"></a>Hibernate Validator 6.0.5.Final （一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>验证数据是所有应用程序层（从演示文稿到持久层）发生的常见任务。 通常在每个层中实现相同的验证逻辑，这是耗时且容易出错的。 为了避免重复这些验证，开发人员经常将验证逻辑直接捆绑到领域模型中，使用验证代码来混淆领域类，验证代码实际上是关于类本身的元数据。</p>
<a id="more"></a>

<p><img src="https://tva2.sinaimg.cn/large/007S2YVMgy1gdzj1klmqqj30i207sq3q.jpg" alt="image"></p>
<p>JSR 380 - Bean Validation 2.0 - 为实体和方法验证定义了元数据模型和API。 默认的元数据源是注解，可以通过使用XML覆盖和扩展元数据。 该API不绑定到特定的应用程序层或编程模型。 它特别与Web或持久层无关，可用于服务器端应用程序编程以及富客户端Swing应用程序开发人员。</p>
<p><img src="https://tvax4.sinaimg.cn/large/007S2YVMgy1gdzj1qdvcqj30i209mjsh.jpg" alt="image"></p>
<p>Hibernate Validator是JSR 380的参考实现。实现本身以及Bean Validation API和TCK都是在<a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache Software License 2.0</a>下提供和分发的。</p>
<p>Hibernate Validator 6和Bean Validation 2.0需要Java 8或更高版本。</p>
<h2 id="1-开始"><a href="#1-开始" class="headerlink" title="1.开始"></a>1.开始</h2><p>本章将向您展示如何开始使用Bean Validation的参考实现（RI）Hibernate Validator。为了以下快速启动，您需要：</p>
<ul>
<li>一个JDK 8</li>
<li><a href="http://maven.apache.org/" target="_blank" rel="noopener">Apache Maven</a></li>
<li>互联网连接（Maven必须下载所有必需的库）</li>
</ul>
<h3 id="1-1。-项目建立"><a href="#1-1。-项目建立" class="headerlink" title="1.1。 项目建立"></a>1.1。 项目建立</h3><p>为了在Maven项目中使用Hibernate Validator，只需将下面的依赖添加到你的<em>pom.xml中</em>：</p>
<p>例1.1：Hibernate验证器Maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.5.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个传递性的依赖于Bean Validation API（ <code>javax.validation:validation-api:2.0.0.Final</code> ）。</p>
<h4 id="1-1-1。-统一的EL"><a href="#1-1-1。-统一的EL" class="headerlink" title="1.1.1。 统一的EL"></a>1.1.1。 统一的EL</h4><p>Hibernate Validator需要实现统一表达式语言（ <a href="http://jcp.org/en/jsr/detail?id=341" target="_blank" rel="noopener">JSR 341</a> ）来评估约束违例消息中的动态表达式（参见<a href="#section-message-interpolation">第4.1节“默认消息插值”</a> ）。 当您的应用程序在JBoss AS等Java EE容器中运行时，容器已经提供了一个EL实现。 但是，在Java SE环境中，必须将实现作为依赖项添加到POM文件。 例如，您可以添加以下依赖项来使用JSR 341 <a href="https://javaee.github.io/uel-ri/" target="_blank" rel="noopener">参考实现</a> ：</p>
<p>例1.2：统一EL参考实现的Maven依赖关系</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1-b08<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>**</th>
<th>对于无法提供EL实现的环境，Hibernate Validator提供了<a href="#non-el-message-interpolator">第12.9节“ <code>ParameterMessageInterpolator</code> ”</a> 。 但是，使用此插补器不符合Bean Validation规范。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="1-1-2。-CDI"><a href="#1-1-2。-CDI" class="headerlink" title="1.1.2。 CDI"></a>1.1.2。 CDI</h4><p>Bean Validation定义了CDI的集成点（Contexts and Dependency Injection for Java  EE, <a href="http://jcp.org/en/jsr/detail?id=346" target="_blank" rel="noopener">JSR 346</a> ）。 如果您的应用程序在不提供此集成的环境中运行，您可以通过将以下Maven依赖项添加到您的POM来使用Hibernate Validator CDI可移植扩展：</p>
<p>例1.3：Hibernate Validator CDI可移植扩展Maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-cdi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.5.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，在Java EE应用程序服务器上运行的应用程序通常不需要添加此依赖项。 您可以在<a href="#section-integration-with-cdi">第11.3节“CDI”中</a>了解更多关于Bean Validation和CDI的集成。</p>
<h4 id="1-1-3。-与安全管理器一起运行"><a href="#1-1-3。-与安全管理器一起运行" class="headerlink" title="1.1.3。 与安全管理器一起运行"></a>1.1.3。 与安全管理器一起运行</h4><p>Hibernate Validator支持在启用<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html" target="_blank" rel="noopener">安全管理器的</a>情况下运行。 为此，您必须为Hibernate验证器和Bean验证API代码库分配多个权限。 以下显示了如何通过由Java默认策略实现处理的<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html" target="_blank" rel="noopener">策略文件</a>来执行此操作：</p>
<p>例1.4：使用Hibernate Validator和安全管理器的策略文件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">grant codeBase <span class="string">"file:path/to/hibernate-validator-6.0.5.Final.jar"</span> &#123;</span><br><span class="line">    permission java.lang.reflect.ReflectPermission <span class="string">"suppressAccessChecks"</span>;</span><br><span class="line">    permission java.lang.RuntimePermission <span class="string">"accessDeclaredMembers"</span>;</span><br><span class="line">    permission java.lang.RuntimePermission <span class="string">"setContextClassLoader"</span>;</span><br><span class="line"></span><br><span class="line">    permission org.hibernate.validator.HibernateValidatorPermission <span class="string">"accessPrivateMembers"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only needed when working with XML descriptors (validation.xml or XML constraint mappings)</span></span><br><span class="line">    permission java.util.PropertyPermission <span class="string">"mapAnyUriToUri"</span>, <span class="string">"read"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">grant codeBase <span class="string">"file:path/to/validation-api-2.0.0.Final.jar"</span> &#123;</span><br><span class="line">    permission java.io.FilePermission <span class="string">"path/to/hibernate-validator-6.0.5.Final.jar"</span>, <span class="string">"read"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所有需要特殊权限的API调用都是通过特权操作完成的。 这意味着只有Hibernate Validator和Bean Validation API本身需要列出的权限。 您不需要为调用Hibernate Validator的其他代码库分配任何权限。</p>
<h4 id="1-1-4。-在WildFly中更新Hibernate验证器"><a href="#1-1-4。-在WildFly中更新Hibernate验证器" class="headerlink" title="1.1.4。 在WildFly中更新Hibernate验证器"></a>1.1.4。 在WildFly中更新Hibernate验证器</h4><p><a href="http://wildfly.org/" target="_blank" rel="noopener">WildFly应用程序服务器</a>包含开箱即用的Hibernate Validator。 为了将Bean Validation API和Hibernate Validator的服务器模块更新到最新，可以使用WildFly的补丁机制。</p>
<p>您可以使用以下依赖项从<a href="http://sourceforge.net/projects/hibernate/files/hibernate-validator" target="_blank" rel="noopener">SourceForge</a>或Maven Central下载修补程序文件：</p>
<p>例1.5：Maven依赖于WildFly 11.0.0.Final补丁文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-modules<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.5.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>wildfly-11.0.0.Final-patch<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>zip<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们还为以前版本的WildFly提供了一个补丁：</p>
<p>例1.6：WildFly 10.1.0.Final补丁文件的Maven依赖关系</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-modules<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.5.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>wildfly-10.1.0.Final-patch<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>zip<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下载了补丁文件后，可以运行以下命令将其应用于WildFly：</p>
<p>例1.7：应用WildFly补丁</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">JBOSS_HOME/bin/jboss-cli.sh patch apply hibernate-validator-modules-6.0.5.Final-wildfly-11.0.0.Final-patch.zip</span></span><br></pre></td></tr></table></figure>

<p>如果您想要取消修补程序并返回最初随服务器提供的Hibernate Validator版本，请运行以下命令：</p>
<p>例1.8：回滚WildFly补丁</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">JBOSS_HOME/bin/jboss-cli.sh patch rollback --reset-configuration=<span class="literal">true</span></span></span><br></pre></td></tr></table></figure>

<p>一般来说，您可以在<a href="https://developer.jboss.org/wiki/SingleInstallationPatching/" target="_blank" rel="noopener">这里</a>和<a href="http://www.mastertheboss.com/jboss-server/jboss-configuration/managing-wildfly-and-eap-patches" target="_blank" rel="noopener">这里</a>了解更多关于WildFly修补程序的基础结构。</p>
<h4 id="1-1-5。-在Java-9上运行"><a href="#1-1-5。-在Java-9上运行" class="headerlink" title="1.1.5。 在Java 9上运行"></a>1.1.5。 在Java 9上运行</h4><p>从Hibernate Validator 6.0.5.Final开始，对Java 9和Java平台模块系统（JPMS）的支持就是实验性的。 目前还没有提供JPMS模块描述符，但Hibernate Validator可用作 automatic modules。</p>
<p>这些是使用<code>Automatic-Module-Name</code>头声明的模块名称 ：</p>
<ul>
<li>Bean验证API： <code>java.validation</code></li>
<li>Hibernate Validator核心： <code>org.hibernate.validator</code></li>
<li>Hibernate Validator CDI扩展： <code>org.hibernate.validator.cdi</code></li>
<li>Hibernate Validator测试实用程序： <code>org.hibernate.validator.testutils</code></li>
<li>Hibernate Validator注解处理器： <code>org.hibernate.validator.annotationprocessor</code></li>
</ul>
<p>这些模块名称是初步的，在未来版本中提供真实模块描述符时可能会更改。</p>
<p>当使用Bean验证XML描述符（ <em>META-INF / validation.xml</em> 和（或）约束映射文件）时，必须启用<code>java.xml.bind</code>模块。 通过追加<code>--add-modules java.xml.bind</code>到你的<em>java</em>调用。</p>
<table>
<thead>
<tr>
<th>**</th>
<th>在CDI中使用Hibernate Validator时，请注意不要启用JDK的<code>java.xml.ws.annotation</code>模块。 该模块包含JSR 250 API的一个子集（“Commons Annotations”），但缺少一些注解，如<code>javax.annotation.Priority</code> 。 这会导致Hibernate Validator的方法验证拦截器不被注册，即方法验证将不起作用。<br/><br/>相反，将完整的JSR 250 API添加到未命名模块（即类路径）中，例如通过引入<em>javax.annotation：javax.annotation-api<em>依赖关系（这里已经存在JSR 250 API的依赖关系</em>当依赖 hibernate.validator：hibernate-validator-cdi</em> ）。<br>如果由于某种原因需要启用<code>java.xml.ws.annotation</code>模块，则应使用完整API的内容修补它， 通过附加<code>--patch-module java.xml.ws.annotation=/path/to/complete-jsr250-api.jar</code>到你的<em>java</em>调用。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-2。-应用约束"><a href="#1-2。-应用约束" class="headerlink" title="1.2。 应用约束"></a>1.2。 应用约束</h3><p>让我们直接看一个例子，看看如何应用约束。</p>
<p>例1.9：带限制条件的Class Car</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String manufacturer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size</span>(min = <span class="number">2</span>, max = <span class="number">14</span>)</span><br><span class="line">    <span class="keyword">private</span> String licensePlate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seatCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String manufacturer, String licencePlate, <span class="keyword">int</span> seatCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.manufacturer = manufacturer;</span><br><span class="line">        <span class="keyword">this</span>.licensePlate = licencePlate;</span><br><span class="line">        <span class="keyword">this</span>.seatCount = seatCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getters and setters ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Size</code> <code>@Min</code> ， <code>@Size</code>和<code>@Min</code>注释用于声明应该应用于Car实例字段的约束：</p>
<ul>
<li><code>manufacturer</code>绝不能为<code>null</code></li>
<li><code>licensePlate</code>不能为<code>null</code>且<code>licensePlate</code>必须在2到14个字符之间</li>
<li><code>seatCount</code>必须至少为2</li>
</ul>
<table>
<thead>
<tr>
<th>**</th>
<th>您可以在GitHub上的Hibernate Validator <a href="https://github.com/hibernate/hibernate-validator/tree/master/documentation/src/test" target="_blank" rel="noopener">源代码仓库</a>中找到本参考指南中使用的所有示例的完整源代码。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-3。-验证约束"><a href="#1-3。-验证约束" class="headerlink" title="1.3。 验证约束"></a>1.3。 验证约束</h3><p>要执行这些约束的验证，请使用<code>Validator</code>实例。 我们来看一下<code>Car</code>的单元测试：</p>
<p>例1.10：Class CarTest显示验证示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintViolation;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Validation;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Validator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ValidatorFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.BeforeClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Validator validator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUpValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();</span><br><span class="line">        validator = factory.getValidator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manufacturerIsNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car( <span class="keyword">null</span>, <span class="string">"DD-AB-123"</span>, <span class="number">4</span> );</span><br><span class="line"></span><br><span class="line">        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =</span><br><span class="line">                validator.validate( car );</span><br><span class="line"></span><br><span class="line">        assertEquals( <span class="number">1</span>, constraintViolations.size() );</span><br><span class="line">        assertEquals( <span class="string">"must not be null"</span>, constraintViolations.iterator().next().getMessage() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">licensePlateTooShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car( <span class="string">"Morris"</span>, <span class="string">"D"</span>, <span class="number">4</span> );</span><br><span class="line"></span><br><span class="line">        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =</span><br><span class="line">                validator.validate( car );</span><br><span class="line"></span><br><span class="line">        assertEquals( <span class="number">1</span>, constraintViolations.size() );</span><br><span class="line">        assertEquals(</span><br><span class="line">                <span class="string">"size must be between 2 and 14"</span>,</span><br><span class="line">                constraintViolations.iterator().next().getMessage()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seatCountTooLow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car( <span class="string">"Morris"</span>, <span class="string">"DD-AB-123"</span>, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =</span><br><span class="line">                validator.validate( car );</span><br><span class="line"></span><br><span class="line">        assertEquals( <span class="number">1</span>, constraintViolations.size() );</span><br><span class="line">        assertEquals(</span><br><span class="line">                <span class="string">"must be greater than or equal to 2"</span>,</span><br><span class="line">                constraintViolations.iterator().next().getMessage()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">carIsValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car( <span class="string">"Morris"</span>, <span class="string">"DD-AB-123"</span>, <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line">        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =</span><br><span class="line">                validator.validate( car );</span><br><span class="line"></span><br><span class="line">        assertEquals( <span class="number">0</span>, constraintViolations.size() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>setUp()</code>方法中，从<code>ValidatorFactory</code>检索<code>Validator</code>对象。 <code>Validator</code>实例是线程安全的，可以重复使用多次。 因此，它可以安全地存储在一个静态字段中，并在测试方法中用于验证不同的<code>Car</code>实例。</p>
<p><code>validate()</code>方法返回一组<code>ConstraintViolation</code>实例，您可以遍历该实例以查看发生了哪些验证错误。 前三种测试方法显示了一些预期的约束违规：</p>
<ul>
<li><code>manufacturerIsNull()</code>违反了<code>manufacturerIsNull()</code>的<code>@NotNull</code>约束</li>
<li><code>@Size</code>约束违反了<code>licensePlateTooShort()</code></li>
<li><code>@Min</code>约束在<code>seatCountTooLow()</code>被违反</li>
</ul>
<p>如果对象验证成功， <code>validate()</code>将返回一个空集，如您在<code>carIsValid()</code>看到的。</p>
<p>请注意，仅使用包<code>javax.validation</code>中的类。 这些是从Javax Bean Validation API提供的。 没有从Hibernate Validator的类直接引用，编写出的代码具有移植性。</p>
<h3 id="1-4。-下一步该去哪里？"><a href="#1-4。-下一步该去哪里？" class="headerlink" title="1.4。 下一步该去哪里？"></a>1.4。 下一步该去哪里？</h3><p>通过Hibernate验证器和Bean验证的5分钟结束。 继续研究代码示例或查看<a href="#validator-further-reading">第14章“ <em>深入阅读”中</em></a>引用的更多示例。</p>
<p>要了解更多关于bean和属性的验证，请继续阅读<a href="#chapter-bean-constraints">第2章<em>声明和验证bean约束</em></a> 。 如果您有兴趣使用Bean验证来验证方法的前置和后置条件，请参阅<a href="#chapter-method-constraints">第3章<em>声明和验证方法约束</em></a> 。 如果您的应用程序具有特定的验证要求<a href="#validator-customconstraints">，请<em>参阅*第6章“ *创建自定义约束”</em></a> 。</p>
<h2 id="2-声明和验证bean约束"><a href="#2-声明和验证bean约束" class="headerlink" title="2.声明和验证bean约束"></a>2.声明和验证bean约束</h2><p>在本章中，您将学习如何<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.co.uk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/&usg=ALkJrhgD-MH0gmBhw9uAJj9NkshS0SvLog#section-declaring-bean-constraints" target="_blank" rel="noopener">声明bean</a> （见<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.co.uk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/&usg=ALkJrhgD-MH0gmBhw9uAJj9NkshS0SvLog#section-declaring-bean-constraints" target="_blank" rel="noopener">第2.1节“声明bean约束”</a> ）和验证（参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.co.uk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/&usg=ALkJrhgD-MH0gmBhw9uAJj9NkshS0SvLog#section-validating-bean-constraints" target="_blank" rel="noopener">第2.2节“验证bean约束”</a> ）。 <a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.co.uk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/&usg=ALkJrhgD-MH0gmBhw9uAJj9NkshS0SvLog#section-builtin-constraints" target="_blank" rel="noopener">第2.3节“内置约束”</a>提供了Hibernate Validator附带的所有内置约束的概述。</p>
<p>如果您有兴趣将约束应用于方法参数和返回值，请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.co.uk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/&usg=ALkJrhgD-MH0gmBhw9uAJj9NkshS0SvLog#chapter-method-constraints" target="_blank" rel="noopener">第3章<em>声明和验证方法约束</em></a> 。</p>
<h3 id="2-1。-声明bean约束"><a href="#2-1。-声明bean约束" class="headerlink" title="2.1。 声明bean约束"></a>2.1。 声明bean约束</h3><p>Bean验证中的约束通过Java注解来表达。 在本节中，您将学习如何使用这些注解来增强对象模型。 有四种类型的bean约束：</p>
<ul>
<li>field constraints（字段约束）</li>
<li>property constraints（属性约束）</li>
<li>container element constraints（容器元素约束，Java泛型元素约束）</li>
<li>class constraints（类约束）</li>
</ul>
<table>
<thead>
<tr>
<th>**</th>
<th>并不是所有的约束都可以放在所有这些层次上。 实际上，Bean Validation定义的默认约束都不能放在类级别。 约束注解中的<code>java.lang.annotation.Target</code>注解本身决定了哪些元素可以放置一个约束。 有关更多信息请参见<a href="#validator-customconstraints">第6章<em>创建自定义约束</em></a> 。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-1-1。-字段级别约束"><a href="#2-1-1。-字段级别约束" class="headerlink" title="2.1.1。 字段级别约束"></a>2.1.1。 字段级别约束</h4><p>约束可以通过注解一个类的字段来表示。 <a href="">示例2.1“字段级别约束”</a>显示了字段级别的配置示例：</p>
<p>例2.1：字段约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.fieldlevel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String manufacturer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AssertTrue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRegistered;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String manufacturer, <span class="keyword">boolean</span> isRegistered)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.manufacturer = manufacturer;</span><br><span class="line">        <span class="keyword">this</span>.isRegistered = isRegistered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getters and setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用字段级别约束时，字段访问策略用于访问要验证的值。 这意味着验证引擎直接访问实例变量，即使存在这样的访问器，也不会调用属性访问器方法。</p>
<p>约束可以应用于任何访问类型（公共，私人等）的字段。 不过，不支持静态字段的约束。</p>
<table>
<thead>
<tr>
<th>**</th>
<th>在验证字节码增强对象时，应该使用属性级别约束，因为字节码增强库将无法通过反射来确定字段访问。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-1-2。-属性级别约束"><a href="#2-1-2。-属性级别约束" class="headerlink" title="2.1.2。 属性级别约束"></a>2.1.2。 属性级别约束</h4><p>如果您的模型类符合<a href="http://www.oracle.com/technetwork/articles/javaee/spec-136004.html" target="_blank" rel="noopener">JavaBean</a>标准，则也可以注释一个bean类的属性，而不是其字段。<a href="">例2.2“属性级约束”</a>使用与<a href="">例2.1“字段级约束”中</a>相同的实体，但是使用属性级约束。</p>
<p>例子2.2：属性级约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.propertylevel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String manufacturer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRegistered;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String manufacturer, <span class="keyword">boolean</span> isRegistered)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.manufacturer = manufacturer;</span><br><span class="line">        <span class="keyword">this</span>.isRegistered = isRegistered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getManufacturer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> manufacturer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setManufacturer</span><span class="params">(String manufacturer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.manufacturer = manufacturer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AssertTrue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRegistered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isRegistered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegistered</span><span class="params">(<span class="keyword">boolean</span> isRegistered)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isRegistered = isRegistered;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>**</th>
<th>该属性的getter方法必须被注解，而不是其setter。 这样也可以限制当没有Getter方法时的只读属性。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>使用属性级别约束时，使用属性访问策略访问要验证的值，即验证引擎通过属性访问器方法访问状态。</p>
<table>
<thead>
<tr>
<th>**</th>
<th>建议在一个类中使用字段<em>或</em>属性级别注解。 不建议同时注解字段和getter方法，因为这会导致字段被验证两次。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-1-3。-容器元素约束"><a href="#2-1-3。-容器元素约束" class="headerlink" title="2.1.3。 容器元素约束"></a>2.1.3。 容器元素约束</h4><p>可以直接在泛型化参数的泛型参数中指定约束：这些约束称为容器元素约束。</p>
<p>这要求在约束定义中通过<code>@Target</code>指定<code>ElementType.TYPE_USE</code> 。 从Bean Validation 2.0开始，内置的Bean Validation以及Hibernate Validator特定的约束指定了<code>ElementType.TYPE_USE</code>的校验注解可以直接在这种情况下使用。</p>
<p>Hibernate Validator验证在以下标准Java容器上指定的容器元素约束：</p>
<ul>
<li><code>java.util.Iterable</code>实现（例如<code>List</code> s， <code>Set</code> s），</li>
<li><code>java.util.Map</code>实现，支持键和值，</li>
<li><code>java.util.Optional</code> ， <code>java.util.OptionalInt</code> ， <code>java.util.OptionalDouble</code> ， <code>java.util.OptionalLong</code> ，</li>
<li>JavaFX的<code>javafx.beans.observable.ObservableValue</code>的各种实现。</li>
</ul>
<p>它还支持自定义容器类型的容器元素约束（请参见<a href="#chapter-valueextraction">第7章， <em>值提取</em></a> ）。</p>
<table>
<thead>
<tr>
<th>**</th>
<th>在hibernate validator 6之前的版本中，支持容器元素约束的一个子集， 在容器级别需要<code>@Valid</code>注解来启用它们。 从Hibernate Validator 6开始，这不再是必需的。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>下面介绍几个例子，说明各种Java类型的容器元素约束。</p>
<p>在这些示例中， <code>@ValidPart</code>是一个允许在<code>TYPE_USE</code>上下文中使用的自定义约束。</p>
<h5 id="2-1-3-1。-使用Iterable"><a href="#2-1-3-1。-使用Iterable" class="headerlink" title="2.1.3.1。 使用Iterable"></a>2.1.3.1。 使用<code>Iterable</code></h5><p>在<code>Iterable</code>类型参数上应用约束时，Hibernate Validator会验证每个元素。 <a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.co.uk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/&usg=ALkJrhgD-MH0gmBhw9uAJj9NkshS0SvLog#example-container-element-constraints-iterable" target="_blank" rel="noopener">例2.3，“<code>Set</code>上的容器元素约束”</a>显示了一个带有容器元素约束的<code>Set</code>的例子。</p>
<p>例2.3： <code>Set</code>上的容器元素约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.containerelement.set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;<span class="meta">@ValidPart</span> String&gt; parts = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPart</span><span class="params">(String part)</span> </span>&#123;</span><br><span class="line">        parts.add( part );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car.addPart( <span class="string">"Wheel"</span> );</span><br><span class="line">car.addPart( <span class="keyword">null</span> );</span><br><span class="line"></span><br><span class="line">Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );</span><br><span class="line"></span><br><span class="line">assertEquals( <span class="number">1</span>, constraintViolations.size() );</span><br><span class="line"></span><br><span class="line">ConstraintViolation&lt;Car&gt; constraintViolation =</span><br><span class="line">        constraintViolations.iterator().next();</span><br><span class="line">assertEquals(</span><br><span class="line">        <span class="string">"'null' is not a valid car part."</span>,</span><br><span class="line">        constraintViolation.getMessage()</span><br><span class="line">);</span><br><span class="line">assertEquals( <span class="string">"parts[].&lt;iterable element&gt;"</span>,</span><br><span class="line">        constraintViolation.getPropertyPath().toString() );</span><br></pre></td></tr></table></figure>

<p>请注意属性路径如何明确指出违规来自可迭代元素。</p>
<h5 id="2-1-3-2。-与List"><a href="#2-1-3-2。-与List" class="headerlink" title="2.1.3.2。 与List"></a>2.1.3.2。 与<code>List</code></h5><p>当在<code>List</code>类型参数上应用约束时，Hibernate Validator会验证每个元素。 <a href="">例2.4，“<code>List</code>上的容器元素约束”</a>显示了一个带容器元素约束的<code>List</code>的例子。</p>
<p>例2.4： <code>List</code>上的容器元素约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.containerelement.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="meta">@ValidPart</span> String&gt; parts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPart</span><span class="params">(String part)</span> </span>&#123;</span><br><span class="line">        parts.add( part );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car.addPart( <span class="string">"Wheel"</span> );</span><br><span class="line">car.addPart( <span class="keyword">null</span> );</span><br><span class="line"></span><br><span class="line">Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );</span><br><span class="line"></span><br><span class="line">assertEquals( <span class="number">1</span>, constraintViolations.size() );</span><br><span class="line"></span><br><span class="line">ConstraintViolation&lt;Car&gt; constraintViolation =</span><br><span class="line">        constraintViolations.iterator().next();</span><br><span class="line">assertEquals(</span><br><span class="line">        <span class="string">"'null' is not a valid car part."</span>,</span><br><span class="line">        constraintViolation.getMessage()</span><br><span class="line">);</span><br><span class="line">assertEquals( <span class="string">"parts[1].&lt;list element&gt;"</span>,</span><br><span class="line">        constraintViolation.getPropertyPath().toString() );</span><br></pre></td></tr></table></figure>

<p>在这里，属性路径也包含无效元素的索引。</p>
<h5 id="2-1-3-3。-与Map"><a href="#2-1-3-3。-与Map" class="headerlink" title="2.1.3.3。 与Map"></a>2.1.3.3。 与<code>Map</code></h5><p>容器元素约束也在Map键和值上进行验证。 <a href="">例2.5，“映射键和值的容器元素约束”</a>显示了一个关于键和值约束的<code>Map</code>的例子。</p>
<p>例2.5：映射键和值的容器元素约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.containerelement.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> FuelConsumption &#123;</span><br><span class="line">        CITY,</span><br><span class="line">        HIGHWAY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;<span class="meta">@NotNull</span> FuelConsumption, <span class="meta">@MaxAllowedFuelConsumption</span> Integer&gt; fuelConsumption = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFuelConsumption</span><span class="params">(FuelConsumption consumption, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        fuelConsumption.put( consumption, value );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car.setFuelConsumption( Car.FuelConsumption.HIGHWAY, <span class="number">20</span> );</span><br><span class="line"></span><br><span class="line">Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );</span><br><span class="line"></span><br><span class="line">assertEquals( <span class="number">1</span>, constraintViolations.size() );</span><br><span class="line"></span><br><span class="line">ConstraintViolation&lt;Car&gt; constraintViolation =</span><br><span class="line">        constraintViolations.iterator().next();</span><br><span class="line">assertEquals(</span><br><span class="line">        <span class="string">"20 is outside the max fuel consumption."</span>,</span><br><span class="line">        constraintViolation.getMessage()</span><br><span class="line">);</span><br><span class="line">assertEquals(</span><br><span class="line">        <span class="string">"fuelConsumption[HIGHWAY].&lt;map value&gt;"</span>,</span><br><span class="line">        constraintViolation.getPropertyPath().toString()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car.setFuelConsumption( <span class="keyword">null</span>, <span class="number">5</span> );</span><br><span class="line"></span><br><span class="line">Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );</span><br><span class="line"></span><br><span class="line">assertEquals( <span class="number">1</span>, constraintViolations.size() );</span><br><span class="line"></span><br><span class="line">ConstraintViolation&lt;Car&gt; constraintViolation =</span><br><span class="line">        constraintViolations.iterator().next();</span><br><span class="line">assertEquals(</span><br><span class="line">        <span class="string">"must not be null"</span>,</span><br><span class="line">        constraintViolation.getMessage()</span><br><span class="line">);</span><br><span class="line">assertEquals(</span><br><span class="line">        <span class="string">"fuelConsumption&lt;K&gt;[].&lt;map key&gt;"</span>,</span><br><span class="line">        constraintViolation.getPropertyPath().toString()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>违反约束的属性路径特别有趣：</p>
<ul>
<li>无效元素的key包含在属性路径中（在第二个示例中，key为<code>null</code> ）。</li>
<li>在第一个例子中，违规涉及<code>&lt;map value&gt;</code> ，第二个是<code>&lt;map key&gt;</code> 。</li>
<li>在第二个例子中，您可能已经注意到泛型参数<code>&lt;K&gt;</code>的存在，稍后会有更多介绍。</li>
</ul>
<h5 id="2-1-3-4。-用java-util-Optional"><a href="#2-1-3-4。-用java-util-Optional" class="headerlink" title="2.1.3.4。 用java.util.Optional"></a>2.1.3.4。 用<code>java.util.Optional</code></h5><p>当在<code>Optional</code>的type参数上应用一个约束时，Hibernate Validator会自动打开类型并验证内部值。 <a href="">例2.6，“可选的容器元素约束”</a>显示了带有容器元素约束的可选项。</p>
<p>示例2.6：可选的容器元素约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.containerelement.optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Optional&lt;<span class="meta">@MinTowingCapacity</span>(<span class="number">1000</span>) Integer&gt; towingCapacity = Optional.empty();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTowingCapacity</span><span class="params">(Integer alias)</span> </span>&#123;</span><br><span class="line">        towingCapacity = Optional.of( alias );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car.setTowingCapacity( <span class="number">100</span> );</span><br><span class="line"></span><br><span class="line">Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );</span><br><span class="line"></span><br><span class="line">assertEquals( <span class="number">1</span>, constraintViolations.size() );</span><br><span class="line"></span><br><span class="line">ConstraintViolation&lt;Car&gt; constraintViolation = constraintViolations.iterator().next();</span><br><span class="line">assertEquals(</span><br><span class="line">        <span class="string">"Not enough towing capacity."</span>,</span><br><span class="line">        constraintViolation.getMessage()</span><br><span class="line">);</span><br><span class="line">assertEquals(</span><br><span class="line">        <span class="string">"towingCapacity"</span>,</span><br><span class="line">        constraintViolation.getPropertyPath().toString()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在这里，属性路径只包含属性的名称，因为我们正在考虑将<code>Optional</code> 作为“透明”容器。</p>
<h5 id="2-1-3-5。-使用自定义容器类型"><a href="#2-1-3-5。-使用自定义容器类型" class="headerlink" title="2.1.3.5。 使用自定义容器类型"></a>2.1.3.5。 使用自定义容器类型</h5><p>容器元素约束也可以用于自定义容器。</p>
<p>必须为自定义类型注册<code>ValueExtractor</code> ，以允许检索要验证的值（有关如何实现自己的<code>ValueExtractor</code>以及如何注册的更多信息，请参阅<a href="#chapter-valueextraction">第7章， <em>值提取</em></a> ）。</p>
<p><a href="">例2.7，“自定义容器类型的容器元素约束”</a>显示了一个具有泛型参数约束的自定义泛型类型。</p>
<p>例2.7：自定义容器类型的容器元素约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.containerelement.custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GearBox&lt;<span class="meta">@MinTorque</span>(<span class="number">100</span>) Gear&gt; gearBox;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGearBox</span><span class="params">(GearBox&lt;Gear&gt; gearBox)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gearBox = gearBox;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.containerelement.custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GearBox</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Gear</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T gear;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GearBox</span><span class="params">(T gear)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gear = gear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gear <span class="title">getGear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.gear;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.containerelement.custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gear</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer torque;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Gear</span><span class="params">(Integer torque)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.torque = torque;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getTorque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> torque;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeGear</span> <span class="keyword">extends</span> <span class="title">Gear</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AcmeGear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>( <span class="number">100</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.containerelement.custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GearBoxValueExtractor</span> <span class="keyword">implements</span> <span class="title">ValueExtractor</span>&lt;<span class="title">GearBox</span>&lt;@<span class="title">ExtractedValue</span> ?&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extractValues</span><span class="params">(GearBox&lt;@ExtractedValue ?&gt; originalValue, ValueExtractor.ValueReceiver receiver)</span> </span>&#123;</span><br><span class="line">        receiver.value( <span class="keyword">null</span>, originalValue.getGear() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car.setGearBox( <span class="keyword">new</span> GearBox&lt;&gt;( <span class="keyword">new</span> Gear.AcmeGear() ) );</span><br><span class="line"></span><br><span class="line">Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );</span><br><span class="line">assertEquals( <span class="number">1</span>, constraintViolations.size() );</span><br><span class="line"></span><br><span class="line">ConstraintViolation&lt;Car&gt; constraintViolation =</span><br><span class="line">        constraintViolations.iterator().next();</span><br><span class="line">assertEquals(</span><br><span class="line">        <span class="string">"Gear is not providing enough torque."</span>,</span><br><span class="line">        constraintViolation.getMessage()</span><br><span class="line">);</span><br><span class="line">assertEquals(</span><br><span class="line">        <span class="string">"gearBox"</span>,</span><br><span class="line">        constraintViolation.getPropertyPath().toString()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="2-1-3-6。-嵌套的容器元素"><a href="#2-1-3-6。-嵌套的容器元素" class="headerlink" title="2.1.3.6。 嵌套的容器元素"></a>2.1.3.6。 嵌套的容器元素</h5><p>嵌套的容器元素也支持约束。</p>
<p>在<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.co.uk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/&usg=ALkJrhgD-MH0gmBhw9uAJj9NkshS0SvLog#example-container-element-nested" target="_blank" rel="noopener">例2.8“嵌套容器元素</a>约束条件中验证<code>Car</code>对象时， <code>Part</code>和<code>Manufacturer</code>上的<code>@NotNull</code>约束条件都将被强制执行。</p>
<p>例子2.8：嵌套的容器元素的约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.containerelement.nested;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;<span class="meta">@NotNull</span> Part, List&lt;<span class="meta">@NotNull</span> Manufacturer&gt;&gt; partManufacturers =</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-4。-类级别约束"><a href="#2-1-4。-类级别约束" class="headerlink" title="2.1.4。 类级别约束"></a>2.1.4。 类级别约束</h4><p>最后但并非最不重要的，还可以在类上设置一个约束。 在这种情况下，单个属性并不是验证的目标，而是完整的对象。 如果验证依赖于对象的多个属性之间的相关性，则类级约束是有用的。</p>
<p><a href="">例2.9中的类级别约束“</a> <code>Car</code>具有<code>seatCount</code>和<code>passengers</code>这两个属性，应该确保乘客名单没有比可用座位更多的条目。 为此， <code>@ValidPassengerCount</code>约束被添加到类级别上。 该约束的验证者可以访问完整的<code>Car</code>对象，从而可以比较座位和乘客的数量。</p>
<p>请参阅<a href="#section-class-level-constraints">第6.2节“类级约束”</a>以详细了解如何实现此自定义约束。</p>
<p>例2.9：类级约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.classlevel;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ValidPassengerCount</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seatCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Person&gt; passengers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-5。-约束继承"><a href="#2-1-5。-约束继承" class="headerlink" title="2.1.5。 约束继承"></a>2.1.5。 约束继承</h4><p>当一个类实现了一个接口或者扩展了另一个类的时候，在父类型上声明的所有约束注解的应用方式与在类本身上指定的约束相同。 为了使事情更清晰，让我们看看下面的例子：</p>
<p>例2.10：约束继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String manufacturer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getManufacturer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> manufacturer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RentalCar</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rentalStation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRentalStation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rentalStation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里类<code>RentalCar</code>是<code>Car</code>一个子类，并添加属性<code>rentalStation</code> 。 如果<code>RentalCar</code>的实例被验证，则不仅会校验<code>rentalStation</code>的<code>@NotNull</code>约束，还会对父类的<code>manufacturer</code>的约束进行校验。</p>
<p>如果<code>Car</code>不是超类，而是由<code>RentalCar</code>实现的接口，情况如上相同 。</p>
<p>如果方法被覆盖，约束注解将被聚合。 因此，如果<code>RentalCar</code>覆盖了<code>Car</code>的<code>getManufacturer()</code>方法，则除了超类的<code>@NotNull</code>约束之外，还会校验在重写方法中注解的任何约束。</p>
<h4 id="2-1-6。-对象级联校验"><a href="#2-1-6。-对象级联校验" class="headerlink" title="2.1.6。 对象级联校验"></a>2.1.6。 对象级联校验</h4><p>Bean验证API不仅允许验证一个类的实例，也能实现完整的对象关联校验（级联验证）。为了实现级联校验，只要在字段或属性上增加注解<code>@Valid</code>。<a href="">2.11，“级联验证”</a>。</p>
<p>实施例2.11：级联验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.objectgraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Person driver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.objectgraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果实例<code>Car</code>被验证，被引用的<code>Person</code>对象也将被验证，因为<code>driver</code>字段被<code>@Valid</code>注解。因此<code>Person</code>的name为null，Car的校验也会失败。</p>
<p>对象关联的验证是递归的，也就是说，如果对级联验证点标记的对象本身具有有<code>@Valid</code>注解的属性，则这些引用也将由验证引擎跟踪。验证引擎将确保在级联验证期间不会出现无限循环，例如，如果两个对象互相持有引用。</p>
<p>需要注意的是<code>null</code>值在级联验证过程中被忽略。</p>
<p>作为约束条件，对象关联的验证也适用于容器的元素。这意味着可以对任意泛型参数的泛型类型使用<code>@Valid</code>，这将导致父对象被校验时每个容器内的元素被校验。</p>
<table>
<thead>
<tr>
<th>**</th>
<th>级联验证还支持约束嵌套容器内的元素。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>实施例2.12：容器的级联验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.objectgraph.containerelement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="meta">@NotNull</span> <span class="meta">@Valid</span> Person&gt; passengers = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;<span class="meta">@Valid</span> Part, List&lt;<span class="meta">@Valid</span> Manufacturer&gt;&gt; partManufacturers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.objectgraph.containerelement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Part</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter02.objectgraph.containerelement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manufacturer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当验证的实例<code>Car</code>中所示的类<a href="">实施例2.12，“级联容器的验证”</a>，一个<code>ConstraintViolation</code>将被创建：</p>
<ul>
<li>如果任何的<code>Person</code>对象有一个<code>null</code>名称;</li>
<li>如果任何Map中的<code>Part</code>对象有一个<code>null</code>名称;</li>
<li>如果任何的<code>Manufacturer</code>对象有一个<code>null</code>名字。</li>
</ul>
<table>
<thead>
<tr>
<th>**</th>
<th>在之前的6个版本，Hibernate验证支持的级联验证的容器元素的子集，它是在容器级别实现的（例如，你会用<code>@Valid private List&lt;Person&gt;</code>启用级联验证<code>Person</code>）。这仍然是支持，但不建议使用。请使用容器元素级别<code>@Valid</code>的注解，因为它更具表现力。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-2。-验证Bean约束"><a href="#2-2。-验证Bean约束" class="headerlink" title="2.2。 验证Bean约束"></a>2.2。 验证Bean约束</h3><p><code>Validator</code>接口在Bean验证中最重要的对象。下一节将展示如何获取一个<code>Validator</code>实例。之后，您将学习如何使用<code>Validator</code>接口中的不同的方法。</p>
<h4 id="2-2-1。-获取Validator实例"><a href="#2-2-1。-获取Validator实例" class="headerlink" title="2.2.1。 获取Validator实例"></a>2.2.1。 获取<code>Validator</code>实例</h4><p>校验对象实例的第一步是获取一个<code>Validator</code>实例。实现这个的过程，就是通过<code>Validation</code>类和<code>ValidatorFactory</code>。最简单的方法是使用静态方法<code>Validation#buildDefaultValidatorFactory()</code>：</p>
<p>实施例2.13： <code>Validation#buildDefaultValidatorFactory()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();</span><br><span class="line">validator = factory.getValidator();</span><br></pre></td></tr></table></figure>

<p>这个启动步骤可以创建一个默认配置的验证器。请参阅<a href="#chapter-bootstrapping">第9章，<em>引导</em></a>更多地了解不同的引导方法和如何获得特定配置的<code>Validator</code>实例。</p>
<h4 id="2-2-2。-验证方法"><a href="#2-2-2。-验证方法" class="headerlink" title="2.2.2。 验证方法"></a>2.2.2。 验证方法</h4><p><code>Validator</code>接口包含验证整个实体或实体单一属性的三种方法。</p>
<p>这三种方法返回<code>Set&lt;ConstraintViolation&gt;</code>。如果<code>Set&lt;ConstraintViolation&gt;</code>为空，则验证成功。否则一个<code>ConstraintViolation</code>实例中添加了每个违反约束。</p>
<p>在执行校验时，所有的验证方法都有方法参数来约定校验分组。如果未指定参数，则默认验证组（<code>javax.validation.groups.Default</code>使用）。验证组的主题进行了详细讨论<a href="#chapter-groups">第5章，<em>分组的约束</em></a>。</p>
<h5 id="2-2-2-1。-Validator-validate"><a href="#2-2-2-1。-Validator-validate" class="headerlink" title="2.2.2.1。 Validator#validate()"></a>2.2.2.1。 <code>Validator#validate()</code></h5><p>使用<code>validate()</code>方法执行给定的bean的所有约束验证。<a href="">例2.14，“使用<code>Validator#validate()</code>”</a>展示了例2.2属性校验的代码，其不能满足该<code>@NotNull</code>上约束<code>manufacturer</code>属性。因此，验证调用返回一个<code>ConstraintViolation</code>对象。</p>
<p>例如2.14：使用 <code>Validator#validate()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Car( <span class="keyword">null</span>, <span class="keyword">true</span> );</span><br><span class="line"></span><br><span class="line">Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );</span><br><span class="line"></span><br><span class="line">assertEquals( <span class="number">1</span>, constraintViolations.size() );</span><br><span class="line">assertEquals( <span class="string">"must not be null"</span>, constraintViolations.iterator().next().getMessage() );</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-2。-Validator-validateProperty"><a href="#2-2-2-2。-Validator-validateProperty" class="headerlink" title="2.2.2.2。 Validator#validateProperty()"></a>2.2.2.2。 <code>Validator#validateProperty()</code></h5><p>使用<code>validateProperty()</code>，你可以验证一个给定对象的指定名称的属性。属性名称必须符合JavaBeans的规范。</p>
<p>例如2.15：使用 <code>Validator#validateProperty()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Car( <span class="keyword">null</span>, <span class="keyword">true</span> );</span><br><span class="line"></span><br><span class="line">Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateProperty(</span><br><span class="line">        car,</span><br><span class="line">        <span class="string">"manufacturer"</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">assertEquals( <span class="number">1</span>, constraintViolations.size() );</span><br><span class="line">assertEquals( <span class="string">"must not be null"</span>, constraintViolations.iterator().next().getMessage() );</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-3。-Validator-validateValue"><a href="#2-2-2-3。-Validator-validateValue" class="headerlink" title="2.2.2.3。 Validator#validateValue()"></a>2.2.2.3。 <code>Validator#validateValue()</code></h5><p>通过使用该<code>validateValue()</code>方法，您对校验指定对象的属性赋予指定的值，判断是否能校验通过：</p>
<p>实施例2.16：使用 <code>Validator#validateValue()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateValue(</span><br><span class="line">        Car<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">        "manufacturer",</span><br><span class="line">        <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">assertEquals( <span class="number">1</span>, constraintViolations.size() );</span><br><span class="line">assertEquals( <span class="string">"must not be null"</span>, constraintViolations.iterator().next().getMessage() );</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>**</th>
<th><code>@Valid</code>不会被触发<code>validateProperty()</code>或<code>validateValue()</code>。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><code>Validator#validateProperty()</code>例如在集成Bean验证的成JSF 2中使用（见<a href="#section-presentation-layer">第11.2节，“JSF＆Seam”</a>），校验那些在表单中的属性值，但是尚未被传入模型对象之前。</p>
<h4 id="2-2-3。-ConstraintViolation"><a href="#2-2-3。-ConstraintViolation" class="headerlink" title="2.2.3。 ConstraintViolation"></a>2.2.3。 <code>ConstraintViolation</code></h4><h5 id="2-2-3-1。ConstraintViolation方法"><a href="#2-2-3-1。ConstraintViolation方法" class="headerlink" title="2.2.3.1。ConstraintViolation方法"></a>2.2.3.1。<code>ConstraintViolation</code>方法</h5><p>现在是时候细看<code>ConstraintViolation</code>。使用<code>ConstraintViolation</code>中不同的方法可以获得很多有关验证失败的原因的有用信息。下面给出了这些方法的概述。下面示例中错误信息的值参考自<a href="">例2.14，“使用<code>Validator#validate()</code>”</a>。</p>
<ul>
<li><p><code>getMessage()</code></p>
<p>插值后的错误信息</p>
<p>“must not be null”</p>
</li>
<li><p><code>getMessageTemplate()</code></p>
<p>尚未插值的错误信息字符串</p>
<p>“{… NotNull.message}”</p>
</li>
<li><p><code>getRootBean()</code></p>
<p>最顶层被校验的对象</p>
<p>car</p>
</li>
<li><p><code>getRootBeanClass()</code></p>
<p>顶层被校验的对象的类</p>
<p><code>Car.class</code></p>
</li>
<li><p><code>getLeafBean()</code></p>
<p>如果一个bean约束，返回bean的实例; 如果一个属性约束，则返回托管属性的bean实例的</p>
</li>
<li><p><code>getPropertyPath()</code></p>
<p>属性路径从根bean的到被校验的对象</p>
<p>返回一个节点<code>PROPERTY</code>，并命名为“manufacturer”</p>
</li>
<li><p><code>getInvalidValue()</code></p>
<p>返回未通过校验的值</p>
</li>
<li><p><code>getConstraintDescriptor()</code></p>
<p>返回校验约束的元数据</p>
<p><code>@NotNull</code></p>
</li>
</ul>
<h5 id="2-2-3-2。-利用属性路径"><a href="#2-2-3-2。-利用属性路径" class="headerlink" title="2.2.3.2。 利用属性路径"></a>2.2.3.2。 利用属性路径</h5><p>为了确定触发约束的元素，你需要使用<code>getPropertyPath()</code>的方法确定约束元素的路径。</p>
<p>返回的<code>Path</code>是校验元素表示的<code>Node</code> 的路径组成的。</p>
<p><code>Path</code>和各种类型的<code>Node</code>的详细信息参考<code>ConstraintViolation</code>部分。</p>
<h3 id="2-3。-内置的约束"><a href="#2-3。-内置的约束" class="headerlink" title="2.3。 内置的约束"></a>2.3。 内置的约束</h3><p>Hibernate验证包括一组基本的通用的约束。这些是最重要的由Bean验证规范中定义的约束条件（见<a href="#validator-defineconstraints-spec">第2.3.1节“Bean验证约束”</a>）。此外，Hibernate验证提供了有用的自定义约束条件（见<a href="#validator-defineconstraints-hv-constraints">第2.3.2节“附加约束”</a>）。</p>
<h4 id="2-3-1。-Bean验证约束"><a href="#2-3-1。-Bean验证约束" class="headerlink" title="2.3.1。 Bean验证约束"></a>2.3.1。 Bean验证约束</h4><p>下面可以找到所有的Bean Validation API定义的约束。所有这些约束只能在字段或属性上使用，没有支持类级别的校验约束。如果你使用了Hibernate ORM，一些约束可以直接在DDL模型操作时使用。</p>
<table>
<thead>
<tr>
<th>**</th>
<th>Hibernate验证允许一些限制约束超出标准的校验规范（例如<code>@Max</code>可应用于字符串）。依托这个功能会影响Bean验证提供者之间的应用程序的可移植性。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p><code>@AssertFalse</code></p>
<p>检查被注解的元素是假的。支持的数据类型<code>Boolean</code> ， <code>boolean</code>。 Hibernate的元数据影响没有</p>
</li>
<li><p><code>@AssertTrue</code></p>
<p>检查被注解的元素是真实的。支持的数据类型<code>Boolean</code> ， <code>boolean</code>。 Hibernate的元数据影响没有</p>
</li>
<li><p><code>@DecimalMax(value=, inclusive=)</code></p>
<p>检查被注解的值是否小于规定的最大值，当<code>inclusive</code>=false。否则，校验该值是否小于或等于指定的最大值。参数值是根据所述最大值的字符串表示<code>BigDecimal</code>字符串表示。支持的数据类型<code>BigDecimal</code>，<code>BigInteger</code>，<code>CharSequence</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>和原始类型的相应的包装; 通过HV另外支持：任何<code>Number</code>和<code>javax.money.MonetaryAmount</code>的子类（如果<a href="">JSR 354 API</a>在项目中被引入）。Hibernate的元数据影响没有</p>
</li>
<li><p><code>@DecimalMin(value=, inclusive=)</code></p>
<p>检查注释的值是否大于指定的最小值，当较大<code>inclusive</code>=false。否则判断该值是否大于或等于指定的最小值。参数值是根据所述最小值的字符串表示<code>BigDecimal</code>字符串表示。支持的数据类型<code>BigDecimal</code>，<code>BigInteger</code>，<code>CharSequence</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>和原始类型的相应的包装; 通过HV另外支持：任何<code>Number</code>和<code>javax.money.MonetaryAmount</code>的子类。Hibernate的元数据影响没有</p>
</li>
<li><p><code>@Digits(integer=, fraction=)</code></p>
<p>检查注释的值的整数位数是否到达<code>integer</code>大小和小数位数是否到达<code>fraction</code>。支持的数据类型<code>BigDecimal</code>，<code>BigInteger</code>，<code>CharSequence</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>和原始类型的相应的包装; 通过HV另外支持：任何<code>Number</code>的子类型。Hibernate的元数据影响：定义数据库列的精度和规模（precision and scale）</p>
</li>
<li><p><code>@Email</code></p>
<p>检查指定的字符序列是否是一个有效的电子邮件地址。可选参数<code>regexp</code>和<code>flags</code>允许指定附加的正则表达式（包括正则表达式标志）。支持的数据类型<code>CharSequence</code>。 Hibernate的元数据影响没有</p>
</li>
<li><p><code>@Future</code></p>
<p>检查注释的日期是否在将来。支持的数据类型<code>java.util.Date</code>，<code>java.util.Calendar</code>，<code>java.time.Instant</code>，<code>java.time.LocalDate</code>，<code>java.time.LocalDateTime</code>，<code>java.time.LocalTime</code>，<code>java.time.MonthDay</code>，<code>java.time.OffsetDateTime</code>，<code>java.time.OffsetTime</code>，<code>java.time.Year</code>，<code>java.time.YearMonth</code>，<code>java.time.ZonedDateTime</code>，<code>java.time.chrono.HijrahDate</code>，<code>java.time.chrono.JapaneseDate</code>，<code>java.time.chrono.MinguoDate</code>，<code>java.time.chrono.ThaiBuddhistDate</code>; 通过HV另外的支持，如果<a href="">Joda Time</a>的日期/时间API被引入类路径：那么任何<code>ReadablePartial</code>和<code>ReadableInstant</code>的实现类都会支持。Hibernate的元数据影响没有</p>
</li>
<li><p><code>@FutureOrPresent</code></p>
<p>检查注释的日期是否在当前或将来。支持的数据类型<code>java.util.Date</code>，<code>java.util.Calendar</code>，<code>java.time.Instant</code>，<code>java.time.LocalDate</code>，<code>java.time.LocalDateTime</code>，<code>java.time.LocalTime</code>，<code>java.time.MonthDay</code>，<code>java.time.OffsetDateTime</code>，<code>java.time.OffsetTime</code>，<code>java.time.Year</code>，<code>java.time.YearMonth</code>，<code>java.time.ZonedDateTime</code>，<code>java.time.chrono.HijrahDate</code>，<code>java.time.chrono.JapaneseDate</code>，<code>java.time.chrono.MinguoDate</code>，<code>java.time.chrono.ThaiBuddhistDate</code>; 通过HV另外的支持，如果<a href="">Joda Time</a>的日期/时间API被引入类路径：那么任何<code>ReadablePartial</code>和<code>ReadableInstant</code>的实现类都会支持。Hibernate的元数据影响没有</p>
</li>
<li><p><code>@Max(value=)</code></p>
<p>检查注释的值是否小于或等于指定的最大值。支持的数据类型<code>BigDecimal</code>，<code>BigInteger</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>和原始类型的相应的包装; 通过HV另外支持：任何的<code>CharSequence</code>（可以被转为数字的字符串），<code>Number</code>和<code>javax.money.MonetaryAmount</code>的子类型。Hibernate的元数据影响：添加列检查约束</p>
</li>
<li><p><code>@Min(value=)</code></p>
<p>检查注释的值是否大于或等于规定的最小值。支持的数据类型<code>BigDecimal</code>，<code>BigInteger</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>和原始类型的相应的包装; 通过HV另外支持：任何的<code>CharSequence</code>（可以被转为数字的字符串），<code>Number</code>和<code>javax.money.MonetaryAmount</code>的子类型。Hibernate的元数据影响：添加列检查约束</p>
</li>
<li><p><code>@NotBlank</code></p>
<p>检查该被注解的字符序列不为null且长度是大于0。与<code>@NotEmpty</code>不同的是，这个约束只可用于字符序列，并且尾部空格都被忽略。支持的数据类型<code>CharSequence</code>。 Hibernate的元数据影响没有</p>
</li>
<li><p><code>@NotEmpty</code></p>
<p>检查注释元素是否不为null，也不是空字符串。支持的数据类型<code>CharSequence</code>，<code>Collection</code>，<code>Map</code>和数组。Hibernate的元数据影响没有</p>
</li>
<li><p><code>@NotNull</code></p>
<p>检查批注的值不为 <code>null</code>。支持的数据类型：任何类型。Hibernate的元数据影响：定义列不可为空</p>
</li>
<li><p><code>@Negative</code></p>
<p>检查该元素是严格为负。零值被视为非法。支持的数据类型<code>BigDecimal</code>，<code>BigInteger</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>和原始类型的相应的包装; 通过HV另外支持：任何<code>CharSequence</code>（可以被转为数字的字符串），任何的<code>Number</code>和<code>javax.money.MonetaryAmount</code>的子类型。Hibernate的元数据影响没有</p>
</li>
<li><p><code>@NegativeOrZero</code></p>
<p>检查该元素是负的或零。支持的数据类型<code>BigDecimal</code>，<code>BigInteger</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>和原始类型的相应的包装; 通过HV另外支持：任何<code>CharSequence</code>（可以被转为数字的字符串），任何的<code>Number</code>和<code>javax.money.MonetaryAmount</code>的子类型。Hibernate的元数据影响没有</p>
</li>
<li><p><code>@Null</code></p>
<p>检查批注的值是 <code>null</code>。支持的数据类型：任何类型。Hibernate的元数据影响没有</p>
</li>
<li><p><code>@Past</code></p>
<p>检查注释的日期是否过去。支持的数据类型<code>java.util.Date</code>，<code>java.util.Calendar</code>，<code>java.time.Instant</code>，<code>java.time.LocalDate</code>，<code>java.time.LocalDateTime</code>，<code>java.time.LocalTime</code>，<code>java.time.MonthDay</code>，<code>java.time.OffsetDateTime</code>，<code>java.time.OffsetTime</code>，<code>java.time.Year</code>，<code>java.time.YearMonth</code>，<code>java.time.ZonedDateTime</code>，<code>java.time.chrono.HijrahDate</code>，<code>java.time.chrono.JapaneseDate</code>，<code>java.time.chrono.MinguoDate</code>，<code>java.time.chrono.ThaiBuddhistDate</code>; 通过HV此外支持，如果<a href="">Joda Time</a>的日期/时间API被引入类路径：那么任何<code>ReadablePartial</code>和<code>ReadableInstant</code>的实现类都会支持。Hibernate的元数据影响没有</p>
</li>
<li><p><code>@PastOrPresent</code></p>
<p>检查注释的日期是否是在过去或当前日期。支持的数据类型<code>java.util.Date</code>，<code>java.util.Calendar</code>，<code>java.time.Instant</code>，<code>java.time.LocalDate</code>，<code>java.time.LocalDateTime</code>，<code>java.time.LocalTime</code>，<code>java.time.MonthDay</code>，<code>java.time.OffsetDateTime</code>，<code>java.time.OffsetTime</code>，<code>java.time.Year</code>，<code>java.time.YearMonth</code>，<code>java.time.ZonedDateTime</code>，<code>java.time.chrono.HijrahDate</code>，<code>java.time.chrono.JapaneseDate</code>，<code>java.time.chrono.MinguoDate</code>，<code>java.time.chrono.ThaiBuddhistDate</code>; 通过HV此外支持，如果<a href="">Joda Time</a>的日期/时间API被引入类路径：那么任何<code>ReadablePartial</code>和<code>ReadableInstant</code>的实现类都会支持。Hibernate的元数据影响没有</p>
</li>
<li><p><code>@Pattern(regex=, flags=)</code></p>
<p>如果被注解的字符串匹配正则表达式检查。 支持的数据类型<code>CharSequence</code>。 Hibernate的元数据影响没有</p>
</li>
<li><p><code>@Positive</code></p>
<p>检查该元素是严格为正。零值被视为非法。支持的数据类型<code>BigDecimal</code>，<code>BigInteger</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>和原始类型的相应的包装; 通过HV另外支持：任何<code>CharSequence</code>（可以被转为数字的字符串），任何的<code>Number</code>和<code>javax.money.MonetaryAmount</code>的子类型。Hibernate的元数据影响没有</p>
</li>
<li><p><code>@PositiveOrZero</code></p>
<p>检查该元件是正数或零。支持的数据类型<code>BigDecimal</code>，<code>BigInteger</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>和原始类型的相应的包装; 通过HV另外支持：任何<code>CharSequence</code>（可以被转为数字的字符串），任何的<code>Number</code>和<code>javax.money.MonetaryAmount</code>的子类型。Hibernate的元数据影响没有</p>
</li>
<li><p><code>@Size(min=, max=)</code></p>
<p>检查已注释元素的大小在<code>min</code>和<code>max</code>（含）之间。支持的数据类型<code>CharSequence</code>，<code>Collection</code>，<code>Map</code>和数组。Hibernate的元数据影响：定义列长度将被设置为 <code>max</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>**</th>
<th>上面列出的每个约束都至少有3个参数：message，groups，payload。这是Bean验证规范的要求。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-3-2。-附加约束"><a href="#2-3-2。-附加约束" class="headerlink" title="2.3.2。 附加约束"></a>2.3.2。 附加约束</h4><p>除了由Bean验证API规范定义的约束，Hibernate验证提供了在下面列出了一些有用的自定义约束。这些约束适用于字段/属性的水平，仅<code>@ScriptAssert</code>是一个类级别的约束。</p>
<ul>
<li><p><code>@CreditCardNumber(ignoreNonDigitCharacters=)</code></p>
<p>判断被注解的字符序列是否通过卢恩校验和测试的检查。注意，这种验证的目的是检查用户的错误，而不是信用卡的有效性！又见<a href="">解剖学信用卡号码</a>。<code>ignoreNonDigitCharacters</code>允许忽略非数字字符。默认值是<code>false</code> 。</p>
<p>支持的数据类型<code>CharSequence</code>。 </p>
<p>Hibernate的元数据影响没有</p>
</li>
<li><p><code>@Currency(value=)</code></p>
<p>检查该注解值的货币单位。<code>javax.money.MonetaryAmount</code>是指定的货币单位的一部分。</p>
<p>支持的数据类型任何的<code>javax.money.MonetaryAmount</code>的子类型（如果<a href="">JSR 354 API</a>或其实现在项目路径中）。</p>
<p>Hibernate的元数据影响没有</p>
</li>
<li><p><code>@DurationMax(days=, hours=, minutes=, seconds=, millis=, nanos=, inclusive=)</code></p>
<p>该被注解的<code>java.time.Duration</code>元素不大于从注解参数构成的一个过程范围。如果相等是允许的，则<code>inclusive</code>标志设置为<code>true</code>。</p>
<p>支持的数据类型<code>java.time.Duration</code>。 </p>
<p>Hibernate的元数据影响没有</p>
</li>
<li><p><code>@DurationMin(days=, hours=, minutes=, seconds=, millis=, nanos=, inclusive=)</code></p>
<p>该被注解的<code>java.time.Duration</code>元素不小于于从注解参数构成的一个过程范围。如果相等是允许的，则<code>inclusive</code>标志设置为<code>true</code>。</p>
<p>支持的数据类型<code>java.time.Duration</code>。 </p>
<p>Hibernate的元数据影响没有</p>
</li>
<li><p><code>@EAN</code></p>
<p>检查批注的字符序列是一个有效的<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.co.uk&sl=en&sp=nmt4&tl=zh-CN&u=http://en.wikipedia.org/wiki/International_Article_Number_%2528EAN%2529&usg=ALkJrhhu4j_3PTtfRnDuhHEepZysGKGc5w" target="_blank" rel="noopener">EAN</a>条码。类型决定条形码类型。默认为EAN-13。</p>
<p>支持的数据类型<code>CharSequence</code>。 </p>
<p>Hibernate的元数据影响没有</p>
</li>
<li><p><code>@Length(min=, max=)</code></p>
<p>验证该注释字符序列长度在<code>min</code>和<code>max</code>之间， 包含最大最小值。支持的数据类型<code>CharSequence</code>。 Hibernate的元数据影响：定义列长度将被设置为最大值</p>
</li>
<li><p><code>@CodePointLength(min=, max=, normalizationStrategy=)</code></p>
<p>验证注释字符序列的代码点长度在<code>min</code>和<code>max</code>之间，包括最大最小值。验证标准值由<code>normalizationStrategy</code>设定。</p>
<p>支持的数据类型<code>CharSequence</code>。</p>
<p>Hibernate的元数据影响没有</p>
</li>
<li><p><code>@LuhnCheck(startIndex= , endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=)</code></p>
<p>检查该注释的字符序列中的数字传递卢恩校验和算法（也参见<a href="http://en.wikipedia.org/wiki/Luhn_algorithm" target="_blank" rel="noopener">Luhn算法</a>）。<code>startIndex</code>和<code>endIndex</code>允许仅在指定范围内的子字符串校验。<code>checkDigitIndex</code>允许于该字符序列作为校验位中使用的任意的数字。如果没有指定假设校验码在指定范围的一部分。最后但并非最不重要的，<code>ignoreNonDigitCharacters</code>可以忽略非数字字符。</p>
<p>支持的数据类型<code>CharSequence</code>。</p>
<p>Hibernate的元数据影响没有</p>
</li>
<li><p><code>@Mod10Check(multiplier=, weight=, startIndex=, endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=)</code></p>
<p>检查该注释的字符序列中的数字传递的一般模10校验和算法。<code>multiplier</code>确定用于奇数乘法器（默认为3），<code>weight</code>为偶数（默认为1）的重量。<code>startIndex</code>并<code>endIndex</code>允许运行仅在指定的子串的算法。<code>checkDigitIndex</code>允许于该字符序列作为校验位中使用的任意的数字。如果没有指定假设校验码在指定范围的一部分。最后但并非最不重要的，<code>ignoreNonDigitCharacters</code>可以忽略非数字字符。</p>
<p>支持的数据类型<code>CharSequence</code></p>
<p>Hibernate的元数据影响没有</p>
</li>
<li><p><code>@Mod11Check(threshold=, startIndex=, endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=, treatCheck10As=, treatCheck11As=)</code></p>
<p>检查该注释的字符序列中的数字传递模11校验和算法。<code>threshold</code>指定用于MOD11乘数生长的阈值; 如果没有指定值的乘数将无限增长。<code>treatCheck10As</code>和<code>treatCheck11As</code>指定的检验数字时要使用的模11的校验和等于10或11，分别。默认为X和0，分别。<code>startIndex</code>，<code>endIndex</code> <code>checkDigitIndex</code>并<code>ignoreNonDigitCharacters</code>携带相同的语义<code>@Mod10Check</code>。</p>
<p>支持的数据类型<code>CharSequence</code></p>
<p>Hibernate的元数据影响没有</p>
</li>
<li><p><code>@Range(min=, max=)</code></p>
<p>检查注解值是否位于（含）指定的最小值和最大值之间。</p>
<p>支持的数据类型<code>BigDecimal</code>，<code>BigInteger</code>，<code>CharSequence</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>和原始类型的相应的包装。</p>
<p>Hibernate的元数据影响没有。</p>
</li>
<li><p><code>@SafeHtml(whitelistType= , additionalTags=, additionalTagsWithAttributes=, baseURI=)</code></p>
<p>检查注释的值是否包含潜在的恶意片段如<code>&lt;script/&gt;</code>。为了使用此约束，jsoup库必须在类路径中。通过<code>whitelistType</code>预定义的白名单类型和<code>additionalTags</code>或<code>additionalTagsWithAttributes</code>可以精确控制校验过程。前者允许添加标签没有任何属性，而后者则允许指定标签和可选允许的属性以及使用注解属性接受的协议<code>@SafeHtml.Tag</code>。此外，<code>baseURI</code>允许指定URI用于解析相对URI的基础。</p>
<p>支持的数据类型<code>CharSequence</code>。 </p>
<p>Hibernate的元数据影响没有</p>
</li>
<li><p><code>@ScriptAssert(lang=, script=, alias=, reportOn=)</code></p>
<p>检查是否给定的脚本可以成功地对注解的元素进行评估。为了使用此约束，在Java脚本API的实现如由JSR 223（“脚本用于Java定义TM平台”）必须是类路径的一部分。待评估的表达式可以写成任何脚本或表达式语言，其中JSR 223兼容引擎可以在类路径上找到。虽然这是一类级别的约束，可以使用<code>reportOn</code>属性上的特定属性，而不是整个对象报告约束冲突。</p>
<p>支持的数据类型任何类型。</p>
<p>Hibernate的元数据影响没有</p>
</li>
<li><p><code>@UniqueElements</code></p>
<p>检查批注的集合只包含独特的元素。判断元素是否相等使用的是<code>equals()</code>方法。默认的消息不包含重复元素的列表，但是你可以通过重写信息并使用它包含<code>{duplicates}</code>消息参数。也包括在违反约束的动态负载重复元素的列表。</p>
<p>支持的数据类型<code>Collection</code>。 </p>
<p>Hibernate的元数据影响没有</p>
</li>
<li><p><code>@URL(protocol=, host=, port=, regexp=, flags=)</code></p>
<p>检查注释的字符序列是根据RFC2396有效的URL。如果任何可选参数<code>protocol</code>，<code>host</code>或<code>port</code>指定时，对应的URL片段必须在指定的值相匹配。可选参数<code>regexp</code>和<code>flags</code>允许指定附加的正则表达式（包括正则表达式标志），其的URL必须匹配。每默认此约束使用的<code>java.net.URL</code>构造函数来验证一个给定的字符串是否代表一个合法的URL。正则表达式基于版本也可用- <code>RegexpURLValidator</code>-其可以通过XML来配置（参见<a href="">第8.2节“经由映射约束<code>constraint-mappings</code>”</a>）或编程API（见<a href="">第12.13.2“添加约束定义编程”</a>）。</p>
<p>支持的数据类型<code>CharSequence</code>。 </p>
<p>Hibernate的元数据影响没有</p>
</li>
</ul>
<h5 id="2-3-2-1。具体国家限制"><a href="#2-3-2-1。具体国家限制" class="headerlink" title="2.3.2.1。具体国家限制"></a>2.3.2.1。具体国家限制</h5><p>Hibernate验证还提供了一些国家的具体限制，例如对于社会安全号码的验证。</p>
<table>
<thead>
<tr>
<th>**</th>
<th>如果你必须实现一个国家相关的特定的约束，可以考虑向Hibernate Validator提出贡献。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p><code>@CNPJ</code></p>
<p>批注的字符序列代表的巴西企业纳税人登记号检查（Cadastro德佩索阿Juríeddica）支持的数据类型<code>CharSequence</code>Hibernate的元数据影响没有国家巴西</p>
</li>
<li><p><code>@CPF</code></p>
<p>批注的字符序列代表巴西个体纳税人登记号检查（Cadastro德佩索阿Fídsica）支持的数据类型<code>CharSequence</code>Hibernate的元数据影响没有国家巴西</p>
</li>
<li><p><code>@TituloEleitoral</code></p>
<p>被注解字符序列代表巴西选举人ID卡号码检查（<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.co.uk&sl=en&sp=nmt4&tl=zh-CN&u=http://www.exceldoseujeito.com.br/2008/12/19/validar-cpf-cnpj-e-titulo-de-eleitor-parte-ii/&usg=ALkJrhhHHVCUUpeVpVzAxXIwMH7v3Drrng" target="_blank" rel="noopener">性标题Eleitoral</a>）支持的数据类型<code>CharSequence</code>Hibernate的元数据影响没有国家巴西</p>
</li>
<li><p><code>@NIP</code></p>
<p>检查该注释字符序列代表波兰VAT标识号（<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.co.uk&sl=en&sp=nmt4&tl=zh-CN&u=https://pl.wikipedia.org/wiki/NIP&usg=ALkJrhhg0v-xCoR1qFGHD9kzAkmmyUWHUw" target="_blank" rel="noopener">NIP</a>）支持的数据类型<code>CharSequence</code>Hibernate的元数据影响没有国家波兰</p>
</li>
<li><p><code>@PESEL</code></p>
<p>检查批注的字符序列代表波兰国家识别号码（<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.co.uk&sl=en&sp=nmt4&tl=zh-CN&u=https://pl.wikipedia.org/wiki/PESEL&usg=ALkJrhjM6oo5wSOngPLa9fFtNDXWwLG7Mg" target="_blank" rel="noopener">PESEL</a>）支持的数据类型<code>CharSequence</code>Hibernate的元数据影响没有国家波兰</p>
</li>
<li><p><code>@REGON</code></p>
<p>检查该注释字符序列代表一个波兰纳税人识别号（<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.co.uk&sl=en&sp=nmt4&tl=zh-CN&u=https://pl.wikipedia.org/wiki/REGON&usg=ALkJrhhE9cpJ9MqZ2Kw0wVL02RJHEZO4Tg" target="_blank" rel="noopener">REGON</a>）。可同时适用于9个14位版本的REGON支持的数据类型<code>CharSequence</code>Hibernate的元数据影响没有国家波兰</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>**</th>
<th>在某些情况下，无论是Bean验证约束，还输Hibernate验证所提供的自定义约束，都不能满足您的要求。在这种情况下，你可以很容易地编写你自己的约束。你可以找到更多信息<a href="">第6章，<em>创建自定义的约束</em></a>。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java动态绑定和静态绑定</title>
    <url>/2020/04/19/Java%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="Java动态绑定和静态绑定"><a href="#Java动态绑定和静态绑定" class="headerlink" title="Java动态绑定和静态绑定"></a>Java动态绑定和静态绑定</h1><p>[TOC]</p>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>动态绑定是指编译器无法解析调用，仅仅在运行时绑定数据的功能。</p>
<p>Java的动态绑定，最直观的使用方法就是多态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    someMethod() &#123;</span><br><span class="line">        System.out.print(<span class="string">"superclass say"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span>｛</span></span><br><span class="line"><span class="class">	<span class="title">someMethod</span>() </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"subclass say"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">｝</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">SuperClass superClass1 = <span class="keyword">new</span> SuperClass();</span><br><span class="line">SuperClass superClass2 = <span class="keyword">new</span> SubClass();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">superClass1.someMethod(); <span class="comment">// SuperClass version is called</span></span><br><span class="line">superClass2.someMethod(); <span class="comment">// SubClass version is called</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>因此，我们看到Java中的动态绑定只是绑定方法调用（只有在子类中可以覆盖的继承方法，因此编译器可能无法确定要调用的方法版本），具体取决于实际的对象类型和不在对象引用的声明类型上。 </p>
<h2 id="静态绑定（或提前绑定）"><a href="#静态绑定（或提前绑定）" class="headerlink" title="静态绑定（或提前绑定）"></a>静态绑定（或提前绑定）</h2><p>如果编译器可以在编译时解析绑定的对象关系，那么称为静态绑定或提前绑定。</p>
<p>所有实例方法调用总是在运行时解析，但所有静态方法调用都在编译时自行解析，因此我们对静态方法调用进行静态绑定。因为静态方法是类方法，因此可以使用类名本身访问它们（实际上它们只是使用它们相应的类名而不是使用对象引用来使用）因此需要解析它们的访问权限在编译期间只使用编译时类型信息。这就是为什么静态方法实际上不能被覆盖的原因。阅读更多 - <a href="http://geekexplains.blogspot.com/2008/06/can-you-override-static-methods-in-java.html" target="_blank" rel="noopener">您可以覆盖Java中的静态方法吗</a>？ </p>
<p>类似地，访问Java中的所有成员变量遵循静态绑定，因为Java不支持（事实上，它不鼓励）成员变量的多态行为。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> String someVariable = <span class="string">"Some Variable in SuperClass"</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> String someVariable = <span class="string">"Some Variable in SubClass"</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(SuperClass superClass)</span> </span>&#123;</span><br><span class="line">	    System.out.println(superClass.someVariable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperClass superClass1 = <span class="keyword">new</span> SuperClass();</span><br><span class="line">        SuperClass superClass2 = <span class="keyword">new</span> SubClass();</span><br><span class="line">        say(superClass1);</span><br><span class="line">        say(supperClass2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Output:-</span><br><span class="line">Some Variable in SuperClass</span><br><span class="line">Some Variable in SuperClass</span><br></pre></td></tr></table></figure>

<p>我们可以观察到，在这两种情况下，成员变量仅基于对象引用的声明类型进行解析，编译器只能在编译时查找，因此在这种情况下可以进行静态绑定。静态绑定的另一个例子是’private’方法，因为它们永远不会被继承，并且编译只能在编译时解析对任何私有方法的调用。</p>
<p>更新[2008年6月24日]：阅读更多内容以了解<a href="http://geekexplains.blogspot.com/2008/06/field-hiding-in-java-fields-are-only.html" target="_blank" rel="noopener">Java中的字段隐藏是如何工作的？</a></p>
<p>转载：<a href="http://geekexplains.blogspot.com/2008/06/dynamic-binding-vs-static-binding-in.html" target="_blank" rel="noopener">http://geekexplains.blogspot.com/2008/06/dynamic-binding-vs-static-binding-in.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java日志规范简约</title>
    <url>/2020/04/19/Java%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83%E7%AE%80%E7%BA%A6/</url>
    <content><![CDATA[<h1 id="Java日志规范简约"><a href="#Java日志规范简约" class="headerlink" title="Java日志规范简约"></a>Java日志规范简约</h1><p>[TOC]</p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><table>
<thead>
<tr>
<th>版本</th>
<th>日期</th>
<th>修订人</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1.0.0</td>
<td>2018-07-10</td>
<td>沈兵</td>
<td></td>
</tr>
</tbody></table>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol>
<li>自定义公共异常模块<a href="http://172.20.15.8/trendy-commons/trendy-commons" target="_blank" rel="noopener"><strong>trendy-commons-base</strong></a>，所有的自定义异常必须实现<code>ITrendytechException</code>接口，所有的运行时异常继承<code>UncheckedException</code></li>
<li>对外API的异常，尽量使用带自定义返回码的异常<code>UncheckedCodeException</code>，并根据异常码转换成用户可以理解的信息并反馈</li>
<li>业务异常、或大部分受检异常，必须使用运行时异常，除非你是有经验的并决定这是一个受检异常，那么你可以自己抛出并提供try-catch处理</li>
<li>在方法上注释上尽量写出方法内可能抛出的异常，及抛出的原因、解决方式，尤其是自定义的业务异常。</li>
<li>明确定义的自定义异常名称</li>
<li>方法出错，按具体情况决定返回错误码还是抛出异常，不要一味以为返回错误码或抛异常总是最好的</li>
<li>SpringWeb项目必须统一处理异常，并且返回统一的数据格式到前端</li>
<li>异常捕获的日志，不要重复打印log，如果有统一的异常处理，那么仅在统一处理的地方打印日志</li>
<li>异常的日志记录必须符合规范<code>logger.error(&quot;error msg&quot;, e)</code>，必须打印异常日志，并详细说明日志的发生原因，有必要的情况下必须记录方法参数、错误的运行结果</li>
<li>必须清楚的认识<code>IllegalArgumentException</code>、IllegalStateException、NullPointException等基本异常，并且在符合条件的情况下使用</li>
<li>catch 时请分清稳定代码和非稳 定代码，稳定代码指的是无论如何不会出错的代码。   对于非稳定代码的 catch 尽可能进行区分 异常类型，再做对应的异常处理。 </li>
<li>有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。 </li>
<li>finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。 </li>
<li>不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。 </li>
<li>方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分 </li>
<li>异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。 </li>
</ol>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ol>
<li>公司提供统一的业务日志的切面框架<a href="http://172.20.15.8/trendy-commons/trendy-commons" target="_blank" rel="noopener">trendy-commons-log</a></li>
<li>一般情况下的异常日志必须用<code>logger.error(&quot;msg&quot;, e)</code>记录。msg必须记录有效的异常信息，e打印异常堆栈</li>
<li>特殊情况下，有的异常被捕获后不处理，例如：用try-catch尝试返回<code>null</code>，那么也要打印<code>logger.warn(&quot;msg&quot;)</code>或<code>log.info(&quot;msg&quot;)</code></li>
<li>Java异常的日志必须仅打印一次，重复打印会产生过多的冗余</li>
<li>统一采用<code>SLF4J</code>做统一的日志操作框架，底层可以采用Logback或Log4J</li>
<li>SLF4J统一用<code>static final</code>修饰日志对象</li>
<li>Springboot建议采用默认的Logback框架</li>
<li>所有的jar包中不推荐包含log4j.xml、log4j.properties、logback.xml文件，避免干扰实际的业务系统</li>
<li>日志存储周期必须定义，防止写满服务器，常用1到3个月</li>
<li>必须使用<code>SLF4J</code>的日志占位符拼接日志信息</li>
<li>生产环境禁用debug日志</li>
<li>可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从</li>
<li>对<code>InvocationTargetException</code>,必须打印TargetException信息</li>
<li>禁止敏感业务信息记录入日志文件，例如密码</li>
<li>多业务的情况可以根据业务拆成多个日志文件</li>
<li>公司提供统一的日志采集的配置文件，其他项目必须基于该配置文件进行修订</li>
<li>日志文件的名称必须规范：日志等级.主机.项目名.业务名.log，示例：<code>info.app.log</code>，<code>info.app_name.business.log</code>，<code>info.app_name.business.date.log</code>，<code>info.host.app_name.business.log</code></li>
</ol>
]]></content>
      <categories>
        <category>日志采集</category>
      </categories>
      <tags>
        <tag>log</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Java开发约定</title>
    <url>/2020/04/19/Java%E7%BA%A6%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="Java约定"><a href="#Java约定" class="headerlink" title="Java约定"></a>Java约定</h1><p>[TOC]</p>
<h3 id="必须遵循Maven项目的基本约定"><a href="#必须遵循Maven项目的基本约定" class="headerlink" title="必须遵循Maven项目的基本约定"></a>必须遵循Maven项目的基本约定</h3><h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><ul>
<li>方法名，简短并准确表达语义，几乎所有的方法名，都应该是<strong>动名词形式</strong>。</li>
<li>方法参数，2-5个可以不用封装成对象。超过5个，考虑封装成对象。</li>
</ul>
<h3 id="DAO层"><a href="#DAO层" class="headerlink" title="DAO层"></a>DAO层</h3><ul>
<li>DAO层的接口名，以DAO或Mapper结尾。</li>
<li>遵循CRUD的命名规则，selectByXX，insert，update，delete。</li>
<li>添加或删除外键（关联关系）时，方法命名：insertXXRelation，deleteXXRelation</li>
<li>额外允许的命名：countXX，sumXX等</li>
<li>不允许的命名：validateXX</li>
<li>用户DAO，它的列表、分页方法永远不要查询出密码。提供单独的一个接口查询密码，仅仅在校验的时候使用。</li>
</ul>
<h3 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h3><ul>
<li>Service层接口名，以Service结尾。</li>
<li>命名方式：getByXX, getPageByXX，save，update, delete等；按当前业务类名称可以省略方法名，如<code>UserService</code>的<code>getUserById</code>方法可以省略为<code>getById</code>。</li>
<li>其他命名方式：add/remove，bind/unbind，validateXX等</li>
<li>尽量不要给关联关系表，建立Service接口，可以将其功能移到具体的业务对象的服务类中。</li>
</ul>
<h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><ul>
<li>类名以Controller结尾</li>
<li>方法命名参考Service层</li>
<li>方法长度尽量简短，可以写一些提取参数的代码段，具体业务转到Service处理。</li>
<li>永远不要将Request、Response、Session对象传递到Service层。</li>
</ul>
<h3 id="Entity层"><a href="#Entity层" class="headerlink" title="Entity层"></a>Entity层</h3><ul>
<li>实体类尽量简单，但是可以写一些辅助方法，例如<code>User</code>类中增加<code>isEnabled</code>方法直接判断status属性字符串。</li>
<li>重新实现<code>toString</code>方法</li>
<li>可以增加数据库不存在的额外字段，但是要有说明或注解。</li>
</ul>
<h3 id="Utils"><a href="#Utils" class="headerlink" title="Utils"></a>Utils</h3><ul>
<li>包名以utils命名</li>
<li>类名以Utils结尾</li>
<li>辅助类可以不以utils结尾，例如：<code>MailSender</code>， 多个辅助类按情形可以都放在utils包中，或者重新建包。</li>
<li>私有化Utils类构造方法</li>
</ul>
<h3 id="值对象、业务对象分包、命名"><a href="#值对象、业务对象分包、命名" class="headerlink" title="值对象、业务对象分包、命名"></a>值对象、业务对象分包、命名</h3><ul>
<li><p>Java界常见对象缩写</p>
<blockquote>
<p>PO(persistant object) 持久对象</p>
<p>DO（Domain Object）领域对象</p>
<p>TO(Transfer Object) ，数据传输对象</p>
<p>DTO（Data Transfer Object）数据传输对象</p>
<p>VO(view object) 视图对象</p>
<p>BO(business object) 业务对象</p>
<p>POJO(plain ordinary java object) 简单无规则 java 对象</p>
<p>DAO(data access object) 数据访问对象</p>
</blockquote>
</li>
<li><p>由于强类型带来的繁琐的数据格式转换问题，导致了很多的逻辑混淆。这里约定：</p>
<ul>
<li>定义vo包为业务拓展数据类型的包。</li>
<li>拓展类以VO结尾</li>
</ul>
</li>
</ul>
<h3 id="Contants常量"><a href="#Contants常量" class="headerlink" title="Contants常量"></a>Contants常量</h3><ul>
<li>数据库类型字段，可以用常量表示的一定用常量表示。</li>
<li>常量名称必须全部大写。</li>
<li>常量类可以嵌套表示，例如<code>A1.B1.XXX=&quot;xxx&quot;</code></li>
<li>用class定义常量，而不是interface。</li>
<li>常量可以定义在常量包中，如果使用范围不广，也可以定义在实体类中。</li>
<li>可以用枚举表示常量，增强常量的信息和行为。</li>
</ul>
<p>​</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>约定</tag>
      </tags>
  </entry>
  <entry>
    <title>Log4j</title>
    <url>/2020/04/19/Log4j/</url>
    <content><![CDATA[<h1 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h1><h2 id="Log4j输出格式控制"><a href="#Log4j输出格式控制" class="headerlink" title="Log4j输出格式控制"></a>Log4j输出格式控制</h2><p><a href="https://blog.csdn.net/reserved_person/article/details/52849505" target="_blank" rel="noopener">https://blog.csdn.net/reserved_person/article/details/52849505</a></p>
]]></content>
      <categories>
        <category>日志采集</category>
      </categories>
      <tags>
        <tag>log</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Logback</title>
    <url>/2020/04/19/Logback/</url>
    <content><![CDATA[<h1 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h1><p>[TOC]</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>LogBack分为3个组件，logback-core, logback-classic 和 logback-access。 </p>
<ul>
<li><p>logback-core提供了LogBack的核心功能，是另外两个组件的基础。 </p>
</li>
<li><p>logback-classic则实现了Slf4j的API，所以当想配合Slf4j使用时，则需要引入这个包。</p>
</li>
<li><p>logback-access是为了集成Servlet环境而准备的，可提供HTTP-access的日志接口 </p>
</li>
</ul>
<h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p><strong>OFF</strong>、 <strong>FATAL</strong>、 <strong>ERROR</strong>、 <strong>WARN</strong>、 <strong>INFO</strong>、 <strong>DEBUG</strong>、 <strong>ALL</strong> </p>
<h2 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h2><p>Logback整体流程：Logger 产生日志信息；Layout修饰这条msg的显示格式；Filter过滤显示的内容；Appender具体的显示 。</p>
<h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也可以定义日志类型、级别 </p>
<h3 id="Appender"><a href="#Appender" class="headerlink" title="Appender"></a>Appender</h3><p>用于指定日志输出的目的地，目的地可以是控制台、文件、远程套接字服务器、 MySQL、 PostreSQL、Oracle和其他数据库、 JMS和远程UNIX Syslog守护进程等。 </p>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>修饰日志的格式</p>
<h3 id="logger-context"><a href="#logger-context" class="headerlink" title="logger context"></a>logger context</h3><p>各个logger 都被关联到一个 LoggerContext，LoggerContext负责制造logger，也负责以树结构排列各logger。其他所有logger也通过org.slf4j.LoggerFactory 类的静态方法getLogger取得。 getLogger方法以 logger名称为参数。用同一名字调用LoggerFactory.getLogger 方法所得到的永远都是同一个logger对象的引用。</p>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Logback的过滤器基于三值逻辑（ternary logic），允许把它们组装或成链，从而组成任意的复合过滤策略。过滤器很大程度上受到Linux的iptables启发。这里的所谓三值逻辑是说，过滤器的返回值只能是ACCEPT、DENY和NEUTRAL的其中一个。</p>
<p>如果返回DENY，那么记录事件立即被抛弃，不再经过剩余过滤器；</p>
<p>如果返回NEUTRAL，那么有序列表里的下一个过滤器会接着处理记录事件；</p>
<p>如果返回ACCEPT，那么记录事件被立即处理，不再经过剩余过滤器。</p>
<p><a href="https://blog.csdn.net/d8111/article/details/45249555" target="_blank" rel="noopener">https://blog.csdn.net/d8111/article/details/45249555</a></p>
<h3 id="Marker"><a href="#Marker" class="headerlink" title="Marker"></a>Marker</h3><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>如果配置文件 logback-test.xml 和 logback.xml 都不存在，那么 logback 默认地会调用BasicConfigurator ，创建一个最小化配置。最小化配置由一个关联到根 logger 的ConsoleAppender 组成。输出用模式为%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n 的 PatternLayoutEncoder 进行格式化。root logger 默认级别是 DEBUG。 </p>
<p><a href="https://www.cnblogs.com/reason-cai/p/6763108.html" target="_blank" rel="noopener">https://www.cnblogs.com/reason-cai/p/6763108.html</a></p>
<p><a href="https://blog.csdn.net/yingxiake/article/details/51274426" target="_blank" rel="noopener">https://blog.csdn.net/yingxiake/article/details/51274426</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span> <span class="attr">value</span>=<span class="string">"/home"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按照每天生成日志文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志文件输出的文件名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/TestWeb.log.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志文件最大的大小--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 日志输出级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>日志采集</category>
      </categories>
      <tags>
        <tag>log</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Logstash插件</title>
    <url>/2020/04/19/Logstash%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="Logstash插件"><a href="#Logstash插件" class="headerlink" title="Logstash插件"></a>Logstash插件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">插件获取地址：</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;logstash-plugins </span><br><span class="line"></span><br><span class="line">在线安装:</span><br><span class="line">&#x2F;plugin install  logstash-input-jdbc</span><br><span class="line"></span><br><span class="line">升级插件：</span><br><span class="line">&#x2F;plugin update logstash-input-jdbc</span><br><span class="line">卸载插件：</span><br><span class="line">&#x2F;plugin uninstall  logstash-input-jdbc</span><br><span class="line"></span><br><span class="line">淘宝源地址： https:&#x2F;&#x2F;ruby.taobao.org</span><br></pre></td></tr></table></figure>

<h3 id="Logstash插件分类"><a href="#Logstash插件分类" class="headerlink" title="Logstash插件分类"></a>Logstash插件分类</h3><ul>
<li>inputs 输入</li>
<li>codecs 解码</li>
<li>filters 过滤</li>
<li>outputs 输出</li>
</ul>
<h3 id="Logstash-input插件"><a href="#Logstash-input插件" class="headerlink" title="Logstash_input插件"></a>Logstash_input插件</h3><p><strong>stdin标准输入</strong></p>
<p>可用参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参数               Input Type                Required        Default Value</span><br><span class="line">add_field            hash                      No                 &#123;&#125;</span><br><span class="line">codec                codec                     NO                 &quot;line&quot;</span><br><span class="line">tags                 array                     NO             </span><br><span class="line">type                 string                    NO</span><br></pre></td></tr></table></figure>

<p><strong>file文件输入</strong></p>
<p>可用参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">        #file插件的参数</span><br><span class="line">        codec&#x3D;&gt;...                        #可选项                codec,         默认是plain,可通过这个参数设置编码方式</span><br><span class="line">        discover_interval&#x3D;&gt;...            #可选项                number,        logstash没隔多久去检查一次被监听的path下是否有新文件,默认值是15秒</span><br><span class="line">        exclude&#x3D;&gt;...                      #可选项                array,         不想被监听的文件可以排除出去,这里跟path一样支持glob展开</span><br><span class="line">        sincedb_path&#x3D;&gt;...                 #可选项                string,        如果你不想用默认的$HOME&#x2F;.sincedb,可以通过这个配置定义sincedb文件到其他位置    </span><br><span class="line">        stat_interval...                  #可选项                number,        logstash没隔多久检查一次被监听文件状态(是否有更新),默认是1秒</span><br><span class="line">        start_position...                 #可选项                string,        logstash从什么位置开始读取文件数据,默认是结束位置,也就是说logstash进程会以类似tial -f的形式运行.如果你是要导入一个完整的文件,把这个设定可以改成&quot;beginning&quot;,logstash进程就会从文件开头读取,有点类似cat</span><br><span class="line">        path&#x3D;&gt;...                         #必选项                array,         处理的文件的路径,可以定义多个路径</span><br><span class="line">        tags&#x3D;&gt;...                         #可选项                array,         在数据处理的过程中,由具体的插件来添加或者删除的标记</span><br><span class="line">        type&#x3D;&gt;...                         #可选项                string,        自定义将要处理事件类型,可以自己随便定义,比如处理的是linux的系统日志,可以定义为&quot;syslog&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例1:过滤nginx的访问日志和错误日志</p>
<p>配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ELK-STACK logstash-1.5.5]# cat conf&#x2F;test1.conf</span><br><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">        path &#x3D;&gt; [&quot;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log&quot;]</span><br><span class="line">        type &#x3D;&gt; &quot;accesslog&quot;</span><br><span class="line">        start_position &#x3D;&gt; &quot;beginning&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    file &#123;</span><br><span class="line">        path &#x3D;&gt; [&quot;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log&quot;]</span><br><span class="line">        type &#x3D;&gt; &quot;errorlog&quot;</span><br><span class="line">        start_position &#x3D;&gt; &quot;beginning&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">output &#123;</span><br><span class="line">    stdout&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ELK-STACK logstash-1.5.5]# .&#x2F;bin&#x2F;logstash -f conf&#x2F;test1.conf</span><br><span class="line">Logstash startup completed</span><br><span class="line">2017-02-23T08:00:25.757Z 0.0.0.0 2017&#x2F;02&#x2F;23 12:14:01 [error] 2145#0: *47 open() &quot;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;zabbix&quot; failed (2: No such file or directory), client: 172.16.2.64, server: _, request: &quot;GET &#x2F;zabbix HTTP&#x2F;1.1&quot;, host: &quot;172.16.1.225&quot;</span><br><span class="line">2017-02-23T08:00:25.757Z 0.0.0.0 172.16.2.64 - - [23&#x2F;Feb&#x2F;2017:12:14:01 +0800] &quot;GET &#x2F;zabbix HTTP&#x2F;1.1&quot; 404 3650 &quot;-&quot; &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;56.0.2924.87 Safari&#x2F;537.36&quot; &quot;-&quot;</span><br><span class="line">2017-02-23T08:01:09.785Z 0.0.0.0 172.16.2.64 - - [23&#x2F;Feb&#x2F;2017:16:01:09 +0800] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 3700 &quot;-&quot; &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_12) AppleWebKit&#x2F;602.1.50 (KHTML, like Gecko) Version&#x2F;10.0 Safari&#x2F;602.1.50&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure>

<p><strong>TCP/UDP输入</strong></p>
<p>TCP</p>
<p>语法格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    tcp &#123;</span><br><span class="line">        #tcp插件的参数                           类型            默认值</span><br><span class="line">        add_field&#x3D;&gt;...            #可选项        hash           &#123;&#125;</span><br><span class="line">        codec&#x3D;&gt;...                #可选项                       plain</span><br><span class="line">        data_timeout&#x3D;&gt;...        #可选项         Number         1</span><br><span class="line">        host&#x3D;&gt;...                #可选项                        0.0.0.0                </span><br><span class="line">        mode&#x3D;&gt;...                #可选项                       值是[&quot;server&quot;,&quot;client&quot;]其中之一,默认是server    </span><br><span class="line">        port&#x3D;&gt;...                #必填项         number        端口号,需要和另一端匹配</span><br><span class="line">        ssl_cacert&#x3D;&gt;...            #可选项</span><br><span class="line">        ssl_cert&#x3D;&gt;...            #可选项</span><br><span class="line">        ssl_enable...            #可选项</span><br><span class="line">        ssk_key&#x3D;&gt;...            #可选项</span><br><span class="line">        ssl_key_passphrase&#x3D;&gt;...    #可选项</span><br><span class="line">        ssl_verify...            #可选项</span><br><span class="line">        tags&#x3D;&gt;...                #可选项         array         </span><br><span class="line">        type&#x3D;&gt;...                #可选项         string         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UDP</p>
<p>语法格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    udp &#123;</span><br><span class="line">        #可用参数  </span><br><span class="line">                                                                 #默认值</span><br><span class="line">        add_field&#x3D;&gt;...            #hash类型            #可选项      默认&#123;&#125;</span><br><span class="line">        host&#x3D;&gt;...                #string类型           #可选项      默认0.0.0.0 </span><br><span class="line">        port&#x3D;&gt;...                #number类型           #必填项      端口号,需要和另一端匹配</span><br><span class="line">        tags&#x3D;&gt;...                #array类型            #必填项</span><br><span class="line">        type&#x3D;&gt;...                #string类型           #可选项</span><br><span class="line">        workers&#x3D;&gt;...            #number类型            #默认2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="Logstash-codec插件"><a href="#Logstash-codec插件" class="headerlink" title="Logstash_codec插件"></a>Logstash_codec插件</h3><p>介绍: codec:编码,解码(json,msgpack,edn)</p>
<p>放置位置: input{}和output()字段里的任何插件里(比如说input里file插件里 input{file{codec=&gt;json}})</p>
<p><strong>codec插件之plain</strong></p>
<p>介绍:plain是一个空的解析器，它可以让用户自己指定格式</p>
<p><strong>codec之json</strong></p>
<p>介绍</p>
<ul>
<li>如果输入到logstash的内容是json格式,可以在input字段加入codec=&gt;json来进行解析</li>
<li>如果想让logstash输出为json格式,可以在output字段加入codec=&gt;json</li>
</ul>
<p>语法格式: codec=&gt; json</p>
<p>实例1:输出json化</p>
<p>配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ELK-STACK logstash-1.5.5]# cat conf&#x2F;json.conf</span><br><span class="line">input &#123;</span><br><span class="line">    stdin &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">output &#123;</span><br><span class="line">    stdout &#123;</span><br><span class="line">        codec &#x3D;&gt; json</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ELK-STACK logstash-1.5.5]# .&#x2F;bin&#x2F;logstash -f conf&#x2F;json.conf</span><br><span class="line">Logstash startup completed             #等待logstash启动成功       </span><br><span class="line">hello.world                            #输入一个字符串的hello.world</span><br><span class="line">&#123;&quot;message&quot;:&quot;hello.world&quot;,&quot;@version&quot;:&quot;1&quot;,&quot;@timestamp&quot;:&quot;2017-02-24T09:01:11.425Z&quot;,&quot;host&quot;:&quot;0.0.0.0&quot;&#125;  #可以看到输入是以json化的格式输出的</span><br></pre></td></tr></table></figure>

<p><strong>codec之json_lines</strong></p>
<p>介绍: 如果你的json文件比较长,需要换行的话,那么久得用到json_lines了</p>
<p><strong>codec之rubydebug</strong></p>
<p>介绍: rubydebug将采用Ruby Awsome Print库来解析日志</p>
<p>实例1:通过rubydebug输出键值对</p>
<p>配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> cat conf&#x2F;rubydebug.conf</span><br><span class="line">input &#123;</span><br><span class="line">    stdin &#123;</span><br><span class="line">        codec &#x3D;&gt; json       #输入为json格式,所以用codec&#x3D;&gt;json来解析</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    stdout &#123;</span><br><span class="line">        codec &#x3D;&gt;rubydebug  #让输出的格式为rubydebug模式,就是把键值对输出</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ELK-STACK logstash-1.5.5]# .&#x2F;bin&#x2F;logstash -f conf&#x2F;rubydebug.conf</span><br><span class="line">Logstash startup completed</span><br><span class="line">&#123;&quot;bookname&quot;:&quot;elk stack&quot;&#125;             #这是输入的键值对</span><br><span class="line">&#123;                                        </span><br><span class="line">      &quot;bookname&quot; &#x3D;&gt; &quot;elk stack&quot;,    #这是以rubydebug的模式输出键值对</span><br><span class="line">      &quot;@version&quot; &#x3D;&gt; &quot;1&quot;,            #这是以rubydebug的模式输出键值对</span><br><span class="line">    &quot;@timestamp&quot; &#x3D;&gt; &quot;2017-02-24T09:29:50.777Z&quot;,</span><br><span class="line">          &quot;host&quot; &#x3D;&gt; &quot;0.0.0.0&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;&quot;bookname&quot;:&quot;elk stack&quot;,&quot;price&quot;:29&#125;           #这是输入的键值对</span><br><span class="line">&#123;</span><br><span class="line">      &quot;bookname&quot; &#x3D;&gt; &quot;elk stack&quot;,               #这是以rubydebug的模式输出键值对</span><br><span class="line">         &quot;price&quot; &#x3D;&gt; 29,                        #这是以rubydebug的模式输出键值对</span><br><span class="line">      &quot;@version&quot; &#x3D;&gt; &quot;1&quot;,</span><br><span class="line">    &quot;@timestamp&quot; &#x3D;&gt; &quot;2017-02-24T09:31:08.224Z&quot;,</span><br><span class="line">          &quot;host&quot; &#x3D;&gt; &quot;0.0.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>codec之multiline</strong></p>
<p>介绍: 有些时候，应用程序调试日志会包含非常丰富的内容，为一个事件打印出很多行内容。这种日志通常都很难通过命令行解析的方式做分析;而 logstash 正为此准备好了 codec/multiline 插件</p>
<p>语法格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin &#123;</span><br><span class="line">        codec &#x3D;&gt;multiline &#123;</span><br><span class="line">            charset&#x3D;&gt;...          #可选                      字符编码         </span><br><span class="line">            max_bytes&#x3D;&gt;...        #可选     bytes类型            设置最大的字节数</span><br><span class="line">            max_lines&#x3D;&gt;...        #可选     number类型           设置最大的行数,默认是500行</span><br><span class="line">            multiline_tag...      #可选     string类型           设置一个事件标签,默认是multiline</span><br><span class="line">            pattern&#x3D;&gt;...          #必选     string类型           设置匹配的正则表达式</span><br><span class="line">            patterns_dir&#x3D;&gt;...     #可选     array类型           可以设置多个正则表达式</span><br><span class="line">            negate&#x3D;&gt;...           #可选     boolean类型         设置true是向前匹配,设置false向后匹配,默认是FALSE</span><br><span class="line">            what&#x3D;&gt;...             #必选                        设置未匹配的内容是向前合并还是先后合并,previous,next两个值选择</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Logstash-filter插件"><a href="#Logstash-filter插件" class="headerlink" title="Logstash_filter插件"></a>Logstash_filter插件</h3><p><strong>json filter</strong></p>
<p>介绍:如果数据格式是json,那么可以通过它把数据解析成你想要的数据结构</p>
<p>语法格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">    json &#123;</span><br><span class="line">        add_field&#x3D;&gt;...            #可选项         #hash          添加属性,默认&#123;&#125;</span><br><span class="line">        add_tag&#x3D;&gt;...              #可选项         #array          添加标识,默认&#123;&#125;</span><br><span class="line">        remove_field&#x3D;&gt;...         #可选项         #array         删除属性,默认&#123;&#125;</span><br><span class="line">        remove_tag&#x3D;&gt;...            #可选项         #array         删除标识,默认&#123;&#125;</span><br><span class="line">        source&#x3D;&gt;...                #必选项         #string       指定来源数据</span><br><span class="line">        target&#x3D;&gt;...                #可选项         #string        定义将要解析的目标字段</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>实例1:解析json数据</p>
<p>配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim conf&#x2F;filter_json.conf</span><br><span class="line"> input &#123;</span><br><span class="line">     stdin &#123;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> filter &#123;</span><br><span class="line">     json &#123;</span><br><span class="line">         source &#x3D;&gt; &quot;message&quot;</span><br><span class="line">         target &#x3D;&gt; &quot;content&quot;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> output &#123;</span><br><span class="line">         stdout &#123;</span><br><span class="line">             codec&#x3D;&gt;rubydebug</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ELK-STACK logstash-1.5.5]# .&#x2F;bin&#x2F;logstash -f conf&#x2F;filter_json.conf</span><br><span class="line">Logstash startup completed</span><br><span class="line">&#123;&quot;name&quot;:&quot;zhai&quot;,&quot;age&quot;:12&#125;       #输入被解析的值</span><br><span class="line">&#123;</span><br><span class="line">       &quot;message&quot; &#x3D;&gt; &quot;&#123;\&quot;name\&quot;:\&quot;zhai\&quot;,\&quot;age\&quot;:12&#125;&quot;,</span><br><span class="line">      &quot;@version&quot; &#x3D;&gt; &quot;1&quot;,</span><br><span class="line">    &quot;@timestamp&quot; &#x3D;&gt; &quot;2017-02-27T08:31:13.193Z&quot;,</span><br><span class="line">          &quot;host&quot; &#x3D;&gt; &quot;0.0.0.0&quot;,</span><br><span class="line">       &quot;content&quot; &#x3D;&gt; &#123;</span><br><span class="line">        &quot;name&quot; &#x3D;&gt; &quot;zhai&quot;,   #这里就是json字段里的name</span><br><span class="line">         &quot;age&quot; &#x3D;&gt; 12        #这里就是json字段里的age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>grok filter</strong></p>
<p>介绍</p>
<ul>
<li>grok是目前logstash里最好的一种解析各种非结构化的日志数据的工具</li>
<li>grok可以过滤日志中你想要的字段</li>
<li>官方patterns地址:<a href="https://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns" target="_blank" rel="noopener">https://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns</a></li>
<li>测试grok匹配规则的网址:grokdebug.herokuapp.com</li>
</ul>
<p>可用参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">        match&#x3D;&gt;...        #可选项        写匹配规则</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>kv filter</strong></p>
<p>介绍: 通过指定一个分隔符,截取key,value</p>
<p>KV插件设置一定的格式，来读取字段中的键值对</p>
<p>其中有两个比较重要的参数，如下：</p>
<ul>
<li>field_split</li>
<li>value_split</li>
</ul>
<p>field_split为两个键值对间的分隔符，而value_split则是两个key,value之间的分隔符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">若要切割的字段如下： </span><br><span class="line">message&#x3D;”messagid&#x3D;123&amp;name&#x3D;logstash” </span><br><span class="line">kv的配置如下： </span><br><span class="line">kv&#123; </span><br><span class="line">source&#x3D;&gt;”message” </span><br><span class="line">field_split &#x3D;&gt;”&amp;” </span><br><span class="line">value_split &#x3D;&gt;”&#x3D;” </span><br><span class="line">&#125; </span><br><span class="line">则message会把切割成 </span><br><span class="line">messageid&#x3D;”123” </span><br><span class="line">name&#x3D;”logstash”</span><br></pre></td></tr></table></figure>

<h3 id="mutate插件"><a href="#mutate插件" class="headerlink" title="mutate插件"></a>mutate插件</h3><p>mutate插件可以把一些字符串替换成别的字符串，通过gsub来实现。或者通过split来切割不同的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mutate &#123; </span><br><span class="line">gsub&#x3D;&gt;[“message”, “\n”, “$”] </span><br><span class="line">split&#x3D;&gt;[“message”,”keyword”] </span><br><span class="line">&#125;</span><br><span class="line">这样配置，message会把message字段中的\n替换成$,并且根据keyword把messageqi切割字符串，通过message，message来获取字段。</span><br></pre></td></tr></table></figure>

<h3 id="Logstash-output插件"><a href="#Logstash-output插件" class="headerlink" title="Logstash_output插件"></a>Logstash_output插件</h3><p>介绍: logstash output就是如何让数据经过logstash的解析和处理后,把结果输出</p>
<p><strong>输出到file</strong></p>
<p>可用参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path &#x3D;&gt; &quot;&#x2F;root&#x2F;access_result&quot;                 #结果输出到文件里</span><br><span class="line">path &#x3D;&gt; &quot;&#x2F;root&#x2F;%&#123;+YYYY.MM.dd&#125;-%&#123;host&#125;-access&quot; #结果输出到文件里,以时间命名文件</span><br><span class="line">message_format &#x3D;&gt; &quot;%&#123;ip&#125;&quot;                      #只输出filter过滤出来的指定字段</span><br></pre></td></tr></table></figure>

<p><strong>输出到elasticsearch</strong></p>
<ul>
<li>elasticsearch就是数据库</li>
<li>把logstash解析过滤的结果输出到elasticsearch里</li>
</ul>
<p>实例1:输出到elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        host &#x3D;&gt; &quot;172.16.1.225&quot;             #elasticsearch的地址,或者cluster&#x3D;&gt;&quot;ClusterName&quot;</span><br><span class="line">        protocol &#x3D;&gt;&quot;http&quot;            </span><br><span class="line">        index&#x3D;&gt;&quot;test_output-%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;    #在elasticsearch里创建索引,索引名称设置,type就是document_type的值,test_output-nginx-2017-02-28</span><br><span class="line">        document_type&#x3D;&gt;&quot;nginx&quot;</span><br><span class="line">        worker&#x3D;&gt;5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Output插件WebHDFS介绍"><a href="#Output插件WebHDFS介绍" class="headerlink" title="Output插件WebHDFS介绍"></a>Output插件WebHDFS介绍</h3><p>webhdfs插件主要是把日志上传到HDFS文件系统中，其格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webhdfs&#123; </span><br><span class="line">host &#x3D;&gt; “127.0.0.1” </span><br><span class="line">port &#x3D;&gt; 50070 </span><br><span class="line">user &#x3D;&gt; “hadoop” </span><br><span class="line">path &#x3D;&gt; “&#x2F;logstash&#x2F;data” </span><br><span class="line">codec &#x3D;&gt; plain </span><br><span class="line">&#123; </span><br><span class="line">charset&#x3D;&gt;”UTF-8” </span><br><span class="line">format&#x3D;&gt;”%&#123;message&#125;” </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>日志采集</category>
      </categories>
      <tags>
        <tag>日志采集</tag>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>RPM命令</title>
    <url>/2020/04/19/RPM%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="RPM命令"><a href="#RPM命令" class="headerlink" title="RPM命令"></a>RPM命令</h1><p>[TOC]</p>
<p><strong>rpm命令</strong>是RPM软件包的管理工具。rpm原本是Red Hat Linux发行版专门用来管理Linux各项套件的程序，由于它遵循GPL规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM套件管理方式的出现，让Linux易于安装，升级，间接提升了Linux的适用度。<br> <a id="more"></a> </p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm(选项)(参数)</span><br></pre></td></tr></table></figure>

<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a：查询所有套件；</span><br><span class="line">-b&lt;完成阶段&gt;&lt;套件档&gt;+或-t &lt;完成阶段&gt;&lt;套件档&gt;+：设置包装套件的完成阶段，并指定套件档的文件名称；</span><br><span class="line">-c：只列出组态配置文件，本参数需配合&quot;-l&quot;参数使用；</span><br><span class="line">-d：只列出文本文件，本参数需配合&quot;-l&quot;参数使用；</span><br><span class="line">-e&lt;套件档&gt;或--erase&lt;套件档&gt;：删除指定的套件；</span><br><span class="line">-f&lt;文件&gt;+：查询拥有指定文件的套件；</span><br><span class="line">-h或--hash：套件安装时列出标记；</span><br><span class="line">-i：显示套件的相关信息；</span><br><span class="line">-i&lt;套件档&gt;或--install&lt;套件档&gt;：安装指定的套件档；</span><br><span class="line">-l：显示套件的文件列表；</span><br><span class="line">-p&lt;套件档&gt;+：查询指定的RPM套件档；</span><br><span class="line">-q：使用询问模式，当遇到任何问题时，rpm指令会先询问用户；</span><br><span class="line">-R：显示套件的关联性信息；</span><br><span class="line">-s：显示文件状态，本参数需配合&quot;-l&quot;参数使用；</span><br><span class="line">-U&lt;套件档&gt;或--upgrade&lt;套件档&gt;：升级指定的套件档；</span><br><span class="line">-v：显示指令执行过程；</span><br><span class="line">-vv：详细显示指令执行过程，便于排错。</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>软件包：指定要操纵的rpm软件包。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>如何安装rpm软件包</strong></p>
<p>rpm软件包的安装可以使用程序rpm来完成。执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh your-package.rpm</span><br></pre></td></tr></table></figure>

<p>其中your-package.rpm是你要安装的rpm包的文件名，一般置于当前目录下。</p>
<p>安装过程中可能出现下面的警告或者提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... conflict with ...</span><br></pre></td></tr></table></figure>

<p>可能是要安装的包里有一些文件可能会覆盖现有的文件，缺省时这样的情况下是无法正确安装的可以用<code>rpm --force -i</code>强制安装即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... is needed by ...</span><br><span class="line">... is not installed ...</span><br></pre></td></tr></table></figure>

<p>此包需要的一些软件你没有安装可以用<code>rpm --nodeps -i</code>来忽略此信息，也就是说<code>rpm -i --force --nodeps</code>可以忽略所有依赖关系和文件问题，什么包都能安装上，但这种强制安装的软件包不能保证完全发挥功能。</p>
<p><strong>如何安装.src.rpm软件包</strong></p>
<p>有些软件包是以.src.rpm结尾的，这类软件包是包含了源代码的rpm包，在安装时需要进行编译。这类软件包有两种安装方法：</p>
<p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -i your-package.src.rpm</span><br><span class="line">cd &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;SPECS</span><br><span class="line">rpmbuild -bp your-package.specs             #一个和你的软件包同名的specs文件</span><br><span class="line">cd &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;BUILD&#x2F;your-package&#x2F;      #一个和你的软件包同名的目录</span><br><span class="line">.&#x2F;configure                                 #这一步和编译普通的源码软件一样，可以加上参数</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -i you-package.src.rpm</span><br><span class="line">cd &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;SPECS</span><br></pre></td></tr></table></figure>

<p>前两步和方法一相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpmbuild -bb your-package.specs       #一个和你的软件包同名的specs文件</span><br></pre></td></tr></table></figure>

<p>这时在<code>/usr/src/redhat/RPM/i386/</code>（根据具体包的不同，也可能是i686,noarch等等）在这个目录下，有一个新的rpm包，这个是编译好的二进制文件。</p>
<p>执行<code>rpm -i new-package.rpm</code>即可安装完成。</p>
<p><strong>如何卸载rpm软件包</strong></p>
<p>使用命令<code>rpm -e</code>包名，包名可以包含版本号等信息，但是不可以有后缀.rpm，比如卸载软件包proftpd-1.2.8-1，可以使用下列格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -e proftpd-1.2.8-1</span><br><span class="line">rpm -e proftpd-1.2.8</span><br><span class="line">rpm -e proftpd-</span><br><span class="line">rpm -e proftpd</span><br></pre></td></tr></table></figure>

<p>不可以是下列格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -e proftpd-1.2.8-1.i386.rpm</span><br><span class="line">rpm -e proftpd-1.2.8-1.i386</span><br><span class="line">rpm -e proftpd-1.2</span><br><span class="line">rpm -e proftpd-1</span><br></pre></td></tr></table></figure>

<p>有时会出现一些错误或者警告：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... is needed by ...</span><br></pre></td></tr></table></figure>

<p>这说明这个软件被其他软件需要，不能随便卸载，可以用rpm -e –nodeps强制卸载</p>
<p><strong>如何不安装但是获取rpm包中的文件</strong></p>
<p>使用工具<a href="http://man.linuxde.net/rpm2cpio" target="_blank" rel="noopener">rpm2cpio</a>和<a href="http://man.linuxde.net/cpio" target="_blank" rel="noopener">cpio</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm2cpio xxx.rpm | cpio -vi</span><br><span class="line">rpm2cpio xxx.rpm | cpio -idmv</span><br><span class="line">rpm2cpio xxx.rpm | cpio --extract --make-directories</span><br></pre></td></tr></table></figure>

<p>参数i和extract相同，表示提取文件。v表示指示执行进程，d和make-directory相同，表示根据包中文件原来的路径建立目录，m表示保持文件的更新时间。</p>
<p><strong>如何查看与rpm包相关的文件和其他信息</strong></p>
<p>下面所有的例子都假设使用软件包<a href="http://man.linuxde.net/mysql" target="_blank" rel="noopener">mysql</a>-3.23.54a-11</p>
<p>1、我的系统中安装了那些rpm软件包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa 讲列出所有安装过的包</span><br></pre></td></tr></table></figure>

<p>如果要查找所有安装过的包含某个字符串sql的软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep sql</span><br></pre></td></tr></table></figure>

<p>2、如何获得某个软件包的文件全名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -q mysql</span><br></pre></td></tr></table></figure>

<p>可以获得系统中安装的mysql软件包全名，从中可以获得当前软件包的版本等信息。这个例子中可以得到信息mysql-3.23.54a-11</p>
<p>3、一个rpm包中的文件安装到那里去了？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ql 包名</span><br></pre></td></tr></table></figure>

<p>注意这里的是不包括.rpm后缀的软件包的名称，也就是说只能用mysql或者mysql-3.23.54a-11而不是mysql-3.23.54a-11.rpm。如果只是想知道可执行程序放到那里去了，也可以用<a href="http://man.linuxde.net/which" target="_blank" rel="noopener">which</a>，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which mysql</span><br></pre></td></tr></table></figure>

<p>4、一个rpm包中包含那些文件。</p>
<ul>
<li>一个没有安装过的软件包，使用<code>rpm -qlp ****.rpm</code></li>
<li>一个已经安装过的软件包，还可以使用<code>rpm -ql ****.rpm</code></li>
</ul>
<p>5、如何获取关于一个软件包的版本，用途等相关信息？</p>
<ul>
<li>一个没有安装过的软件包，使用<code>rpm -qip ****.rpm</code></li>
<li>一个已经安装过的软件包，还可以使用<code>rpm -qi ****.rpm</code></li>
</ul>
<p>6、某个程序是哪个软件包安装的，或者哪个软件包包含这个程序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qf &#96;which 程序名&#96;    #返回软件包的全名</span><br><span class="line">rpm -qif &#96;which 程序名&#96;   #返回软件包的有关信息</span><br><span class="line">rpm -qlf &#96;which 程序名&#96;   #返回软件包的文件列表</span><br></pre></td></tr></table></figure>

<p>注意，这里不是引号，而是<code>，就是键盘左上角的那个键。也可以使用</code>rpm -qilf`，同时输出软件包信息和文件列表。</p>
<p>7、某个文件是哪个软件包安装的，或者哪个软件包包含这个文件。</p>
<p>注意，前一个问题中的方法，只适用与可执行的程序，而下面的方法，不仅可以用于可执行程序，也可以用于普通的任何文件。前提是知道这个文件名。首先获得这个程序的完整路径，可以用<a href="http://man.linuxde.net/whereis" target="_blank" rel="noopener">whereis</a>或者which，然后使用<code>rpm -qf</code>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis ftptop</span><br><span class="line">ftptop: &#x2F;usr&#x2F;bin&#x2F;ftptop &#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;ftptop.1.gz</span><br><span class="line"></span><br><span class="line">rpm -qf &#x2F;usr&#x2F;bin&#x2F;ftptop</span><br><span class="line">proftpd-1.2.8-1</span><br><span class="line"></span><br><span class="line">rpm -qf &#x2F;usr&#x2F;share&#x2F;doc&#x2F;proftpd-1.2.8&#x2F;rfc&#x2F;rfc0959.txt</span><br><span class="line">proftpd-1.2.8-1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Restful 接口规范调研与解析</title>
    <url>/2020/04/19/Restful%20%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83%E8%B0%83%E7%A0%94%E4%B8%8E%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Restful-接口规范调研与解析"><a href="#Restful-接口规范调研与解析" class="headerlink" title="Restful 接口规范调研与解析"></a>Restful 接口规范调研与解析</h2><table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">日期</th>
<th align="center">人员</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v0.1</td>
<td align="center">2017-11-27</td>
<td align="center">沈兵</td>
</tr>
</tbody></table>
<p>[TOC]</p>
<h3 id="1-简易理解"><a href="#1-简易理解" class="headerlink" title="1. 简易理解"></a>1. 简易理解</h3><ol>
<li><p>基于HTTP Method对资源CRUD</p>
<table>
<thead>
<tr>
<th>HTTP Method</th>
<th>URI</th>
<th>HTTP body</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>/users</td>
<td>无</td>
<td>用户列表</td>
</tr>
<tr>
<td>GET</td>
<td>/users/uid</td>
<td>无</td>
<td>用户信息</td>
</tr>
<tr>
<td>POST</td>
<td>/users</td>
<td><code>{&quot;name&quot;:&quot;xx&quot;,&quot;age&quot;18}</code></td>
<td>创建用户</td>
</tr>
<tr>
<td>PATCH</td>
<td>/users/uid</td>
<td><code>{&quot;name&quot;:&quot;xx&quot;}</code></td>
<td>修改用户（部分更新）</td>
</tr>
<tr>
<td>PUT</td>
<td>/users/uid</td>
<td><code>{&quot;name&quot;:&quot;aa&quot;,&quot;age&quot;15}</code></td>
<td>修改用户（全量更新）</td>
</tr>
<tr>
<td>DELETE</td>
<td>/users/uid</td>
<td>无</td>
<td>删除用户</td>
</tr>
</tbody></table>
<p>​</p>
</li>
<li><p>使用HTTP状态码准确描述相应结果</p>
<p>200：ok</p>
<p>201：created</p>
<p>204：no content</p>
<p>400: bad request</p>
<p>401: not authorized</p>
<p>403: forbidden</p>
<p>500: server error</p>
</li>
<li><p>使用Content-Type准确描述资源内容</p>
<table>
<thead>
<tr>
<th>Content-Type</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>application/json</td>
<td>JSON</td>
</tr>
<tr>
<td>application/xml</td>
<td>XML</td>
</tr>
<tr>
<td>text/html</td>
<td>HTML</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="2-描述性理解"><a href="#2-描述性理解" class="headerlink" title="2. 描述性理解"></a>2. 描述性理解</h3><pre><code>1. URI表示资源，使用名词而不是动词，且推荐用复数
 2. 保证HTTP Method本身的状态表示。HEAD、GET、PUT是幂等操作；同时使用HTTP Method本身的语义操作资源。
  3. 使用正确的HTTP Status Code表示访问状态</code></pre><h3 id="3-论文版理解"><a href="#3-论文版理解" class="headerlink" title="3. 论文版理解"></a>3. 论文版理解</h3><p>REST风格的架构所具有的6个的主要特征（<a href="http://www.infoq.com/cn/articles/understanding-restful-style）：" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/understanding-restful-style）：</a></p>
<ul>
<li>面向资源（Resource Oriented）</li>
<li>可寻址（Addressability）</li>
<li>连通性（Connectedness）</li>
<li>无状态（Statelessness）</li>
<li>统一接口（Uniform Interface）</li>
<li>超文本驱动（Hypertext Driven）</li>
</ul>
<p>面向资源：URI以资源抽象为核心展开，可以更好地实现面向资源的抽象、开发编程、缓存、测试。</p>
<p>可寻址：1. 实现从服务器端到客户端的资源状态转移，将原本在服务器端保存的资源状态用客户端保存。2. 使用带有约定性的URI资源表述，可以更方便的推断出其他的URI资源。</p>
<p>连通性：资源与资源间并非孤立，而是存在某种关联。使用资源状态转移的特性，在资源间通过“链接”互相联系。</p>
<p>无状态：服务器端不保存上一次访问的状态。实现服务端和客户端更松散的耦合，有利于测试。</p>
<p>统一接口：利用HTTP标准方法或约定好的使用方法，可以针对资源开发出更统一的URI资源列表及资源操作接口。</p>
<p>超文本驱动（Hypermedia As The Engine Of Application State，HATEOAS）：资源之间通过超链接相互关联，超链接既代表资源之间的关系，也代表可执行的状态迁移。在超媒体之中不仅仅包含数据，还包含了状态迁移的语义。这里的“超链接”代表了一个超文本资源，超文本驱动简义为使用代表超文本资源的超链接驱动资源的操作，将超链接传输到客户端（意味着资源状态迁移）取代了对服务端状态的依赖。</p>
<h3 id="4-名词解释："><a href="#4-名词解释：" class="headerlink" title="4. 名词解释："></a>4. 名词解释：</h3><p>资源状态转移与无状态服务器：</p>
<blockquote>
<p>例如我订阅了一个人的博客，想要获取他发表的所有文章（这里『他发表的所有文章』就是一个<strong>资源Resource</strong>）。于是我就向他的服务发出请求，说『我要获取你发表的所有文章，最好是atom格式的』，这时候服务器向你返回了atom格式的文章列表第一页（这里『atom格式的文章列表』就是<strong>表征Representation</strong>）。</p>
<p>你看到了第一页的页尾，想要看第二页，这时候有趣的事情就来了。如果服务器记录了应用的状态（stateful），那么你只要向服务询问『我要看下一页』，那么服务器自然就会返回第二页。类似的，如果你当前在第二页，想服务器请求『我要看下一页』，那就会得到第三页。但是REST的服务器恰恰是无状态的（stateless），服务器并没有保持你当前处于第几页，也就无法响应『下一页』这种具有状态性质的请求。因此客户端需要去维护当前应用的状态（application state），也就是『如何获取下一页资源』。当然，『下一页资源』的业务逻辑必然是由服务端来提供。服务器在文章列表的atom表征中加入一个URI超链接（hyper link），指向下一页文章列表对应的资源。客户端就可以使用<strong>统一接口（Uniform Interface）</strong>的方式，从这个URI中获取到他想要的下一页文章列表资源。上面的『能够进入下一页』就是应用的<strong>状态（State）。</strong>服务器把『能够进入下一页』这个状态以atom表征形式<strong>传输（Transfer）</strong>给客户端就是<strong>表征状态传输（REpresentational State Transfer）</strong>这个概念。</p>
<p><a href="https://www.zhihu.com/question/28557115" target="_blank" rel="noopener">https://www.zhihu.com/question/28557115</a></p>
</blockquote>
<p>连通性与超媒体：</p>
<blockquote>
<p>在絕大多數情況下，資源並不會孤立地存在，必然與其他資源具有某種關聯。既然我們推薦資源采用具有可尋址性的URL 來標識，那麼我們就可以利用它來將相關的資源關聯起來。比如采用XML 來表示一部電影的信息，那麼我們可以采用如下的形式利用URL 將相關的資源（導演、領銜主演、主演、編劇以及海報等）關聯在一起。當用戶得到這樣一份文檔的時候，可以利用文檔自身的內容獲得某部影片的基本信息，還可以利用相關的“鏈接”得到其他相關內容的詳細信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;movie&gt; </span><br><span class="line">&lt;name&gt;魔鬼代言人&lt;&#x2F;name&gt; </span><br><span class="line">&lt;genre&gt;劇情|懸疑|驚悚&lt;&#x2F;genre&gt; </span><br><span class="line">&lt;directors&gt; </span><br><span class="line">&lt;add ref&#x3D;&quot;http:&#x2F;&#x2F;www.artech.com&#x2F;directors&#x2F;taylor-hackford&quot;&gt; </span><br><span class="line">泰勒.海克福德&lt;&#x2F;add&gt; </span><br><span class="line">&lt;&#x2F;directors&gt; </span><br><span class="line">&lt;starring&gt; </span><br><span class="line">&lt;add ref &#x3D; &quot;http:&#x2F;&#x2F;www.artech.com&#x2F;actors&#x2F;al-pacino&quot;&gt;阿爾.帕西諾&lt;&#x2F;add&gt; </span><br><span class="line">&lt;add ref &#x3D; &quot;http:&#x2F;&#x2F;www.artech.com&#x2F;actors&#x2F;keanu-reeves &quot;&gt;基諾.李維斯&lt;&#x2F;add&gt; </span><br><span class="line">&lt;&#x2F;starring&gt; </span><br><span class="line">&lt;supportingActors&gt; </span><br><span class="line">&lt;add ref &#x3D; &quot;http:&#x2F;&#x2F;www.artech.com&#x2F;actors&#x2F;charlize-theron &quot;&gt;查理茲.塞隆&lt;&#x2F;add&gt; </span><br><span class="line">&lt;add ref &#x3D; &quot;http:&#x2F;&#x2F;www.artech.com&#x2F;actors&#x2F;jeffrey-jones &quot;&gt;傑弗瑞.琼斯&lt;&#x2F;add&gt; </span><br><span class="line">&lt;add ref &#x3D; &quot;http:&#x2F;&#x2F;www.artech.com&#x2F;actors&#x2F;connie-nielsen&quot;&gt;康尼.尼爾森&lt;&#x2F;add&gt; </span><br><span class="line">&lt;&#x2F;supportingActors&gt; </span><br><span class="line">&lt;scriptWriters&gt; </span><br><span class="line">&lt;add ref &#x3D; &quot;http:&#x2F;&#x2F;www.artech.com&#x2F;scriptwriters&#x2F;jonathan-lemkin&quot;&gt; </span><br><span class="line">喬納森·萊姆金  </span><br><span class="line">&lt;&#x2F;add&gt; </span><br><span class="line">&lt;add ref &#x3D; &quot;http:&#x2F;&#x2F;www.artech.com&#x2F;scriptwriters&#x2F;tony-gilroy&quot;&gt; </span><br><span class="line">托尼·吉爾羅伊&lt;&#x2F;add&gt; </span><br><span class="line">&lt;&#x2F;scriptWriters&gt; </span><br><span class="line">&lt;language&gt;英語&lt;&#x2F;language&gt; </span><br><span class="line">&lt;poster ref &#x3D; &quot;http:&#x2F;&#x2F;www.artech.com&#x2F;images&#x2F;the-devil-s-advocate&quot;&#x2F;&gt; </span><br><span class="line">&lt;story&gt;...&lt;&#x2F;story&gt; </span><br><span class="line">&lt;&#x2F;movie&gt; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具有上述內容的文檔可以視為一份超文本/超媒體文檔。Fielding 在他的論文中將REST定位為“分佈式超媒體應用”的架構風格，而超媒體的核心就是利用“鏈接”將相關的信息結成一個非線性的網，所以從這一點也可以看出REST 和“使用鏈接關聯相關的資源”這個特性是吻合的。</p>
<p><a href="http://www.wenwenti.info/article/143292" target="_blank" rel="noopener">http://www.wenwenti.info/article/143292</a></p>
</blockquote>
<p>优点：</p>
<ul>
<li>简单性</li>
</ul>
<p>采用REST架构风格，对于开发、测试、运维人员来说，都会更简单。可以充分利用大量HTTP服务器端和客户端开发库、Web功能测试/性能测试工具、HTTP缓存、HTTP代理服务器、防火墙。这些开发库和基础设施早已成为了日常用品，不需要什么火箭科技（例如神奇昂贵的应用服务器、中间件）就能解决大多数可伸缩性方面的问题。</p>
<ul>
<li>可伸缩性</li>
</ul>
<p>充分利用好通信链各个位置的HTTP缓存组件，可以带来更好的可伸缩性。其实很多时候，在Web前端做性能优化，产生的效果不亚于仅仅在服务器端做性能优化，但是HTTP协议层面的缓存常常被一些资深的架构师完全忽略掉。</p>
<ul>
<li>松耦合</li>
</ul>
<p>统一接口+超文本驱动，带来了最大限度的松耦合。允许服务器端和客户端程序在很大范围内，相对独立地进化。对于设计面向企业内网的API来说，松耦合并不是一个很重要的设计关注点。但是对于设计面向互联网的API来说，松耦合变成了一个必选项，不仅在设计时应该关注，而且应该放在最优先位置。</p>
<p>​    </p>
<p>缺点：</p>
<p>​    对实时性要求很高的应用，REST的表现不如DO和RPC。</p>
<h3 id="5-Restful-复杂需求："><a href="#5-Restful-复杂需求：" class="headerlink" title="5. Restful 复杂需求："></a>5. Restful 复杂需求：</h3><ol>
<li><h4 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h4><ul>
<li><p>DELETE  /users/1,2,3</p>
</li>
<li><p>DELETE /users?id=1&amp;id=2</p>
</li>
<li><p>DELETE /users?id[]=1&amp;id[]=2</p>
</li>
<li><p>POST /users/deletes   （用deletes表示批量）</p>
<p>​    用POST JSON替代DELETE</p>
<p>​    request body: <code>{&quot;userIds&quot;:[&quot;1&quot;, &quot;2&quot;]}</code></p>
<p>​    </p>
<p>​    或用POST JSON创建一个ID列表的资源。 用DELETE删除这个ID集合资源表示的用户</p>
<p>​    response body: <code>{&quot;id&quot;:1, &quot;userIds&quot;:[&quot;1&quot;, &quot;2&quot;]}</code></p>
<p>​    DELETE /users/deletes/1</p>
</li>
<li><p>DELETE /users</p>
<p>​    request body: <code>{&quot;userIds&quot;:[&quot;1&quot;, &quot;2&quot;]}</code></p>
</li>
</ul>
</li>
<li><h4 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h4><ul>
<li><p>PUT  /users</p>
<p>request body: <code>[{&quot;id&quot;:1, &quot;name&quot;:&quot;xx&quot;}, {&quot;id&quot;:2,&quot;name&quot;:&quot;ss&quot;}]</code></p>
</li>
<li><p>PUT /users</p>
<p>request body: <code>{&quot;users&quot;:[{&quot;id&quot;:1, &quot;name&quot;:&quot;xx&quot;}, {&quot;id&quot;:2,&quot;name&quot;:&quot;ss&quot;}]}</code></p>
</li>
</ul>
</li>
<li><h4 id="多对多关联关系"><a href="#多对多关联关系" class="headerlink" title="多对多关联关系"></a>多对多关联关系</h4><ul>
<li><p>/memberships</p>
<ol>
<li>如果希望同时获取多对多关系本身的属性,例如team下的一些信息：教练…等。使用/memberships/shipId可以更清楚的表示出来一组关系。</li>
<li>关于缓存，如果使用/teams/3/players/失效时，可能同时需要/players/5/teams/失效，但是使用/memberships/，仅仅一个资源表示关联关系，可以减少服务端或者客户端关于缓存的操作。</li>
<li>通过/teams/tid/ players或者/players/uid/teams,如果当你需要增加一种新的关联关系，例如：过去的team成员列表, 可能需要在现有的请求体、响应体中增加历史成员列表以适应接口的变更。但是使用/memberships/{id}/表示多对多关系时，可以通过/players/5/memberships/ 和/players/5/past_memberships/来处理这些关联关系，通过增加接口数量保证原有接口的稳定性。</li>
<li>这里在使用/memberships时，无法获取players列表中的详细信息，而是link列表。如果需要详细信息，可以使用/users?teamId=xx，通过用户列表接口去查询用户列表。</li>
</ol>
</li>
<li><p>/teams/tid/users</p>
<p>更容易理解，但是有悖于Restful理解。/teams/tid/users应该是一组关系，但是返回值通常被定义为用户资源列表。如果理解为这是用户资源，那么POST和DELETE操作理论上应该是用户创建和用户删除。</p>
<p>如果/teams/tid/users使用超媒体链接表示用户关系，那么前后台业务都会增加，很难通过链接数组获取用户列表。</p>
</li>
</ul>
</li>
<li><h4 id="分页接口定义"><a href="#分页接口定义" class="headerlink" title="分页接口定义"></a>分页接口定义</h4><p>是否有必要在响应结果上区分page接口和list接口呢？</p>
<p>分页接口一般存在total表示总数，更多的可以返回当前页、总页数、当前排序等其他分页相关的元数据。</p>
<p>而列表接口并不存在分页信息，理论上列表接口的标准返回形式是对象数组。</p>
</li>
</ol>
<p>   在page接口的响应体上一搬是两种情况（属于广泛使用）：</p>
<ul>
<li><p>带有分页元信息的响应体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;page&quot;:1,</span><br><span class="line">  &quot;total&quot;:10,</span><br><span class="line">  &quot;records&quot;:[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用和列表接口一样的数据结构</p>
<p>在HTTP header中增加X-Total-Count表示总数的元信息。</p>
<p>增加Link header表示上一页、下一页的超链接。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Header</span><br><span class="line">X-Total-Count:10</span><br><span class="line">X-Current-Page:2</span><br><span class="line">Link: &lt;http:&#x2F;&#x2F;xx?page&#x3D;3&gt;;rel&#x3D;&quot;next&quot;,&lt;http:&#x2F;&#x2F;xx?page&#x3D;1&gt;;rel&#x3D;&quot;pre&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Response Body</span><br><span class="line">[&#123;</span><br><span class="line">  &quot;id&quot;:&quot;xx&quot;,</span><br><span class="line">  &quot;name&quot;:&quot;xx&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;id&quot;:&quot;ss&quot;,</span><br><span class="line">  &quot;name&quot;:&quot;ss&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>



<ol start="5">
<li><h4 id="查询语言的定义"><a href="#查询语言的定义" class="headerlink" title="查询语言的定义"></a>查询语言的定义</h4><p>如果存在多个参数，既有精确匹配，又有模糊匹配，是否需要将模糊匹配的参数增加后缀，例如<code>like</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;users?name&#x3D;shen&amp;nameLike&#x3D;shen&amp;email&#x3D;shen@qq.com&amp;emailLike&#x3D;qq.com</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="PATCH方法的应用"><a href="#PATCH方法的应用" class="headerlink" title="PATCH方法的应用"></a>PATCH方法的应用</h4><p>patch方法使用较少。是否在真正遇到patch时用PUT或POST替代？</p>
</li>
<li><h4 id="重定义HTTP-Method"><a href="#重定义HTTP-Method" class="headerlink" title="重定义HTTP Method"></a>重定义HTTP Method</h4><p>在文件移动、复制等特殊行为，是否应该使用 HTTP Header <strong>X-HTTP-Method-Override</strong> 来覆盖POST方法表示的method.</p>
<p><code>X-HTTP-Method-Override:COPY</code></p>
<p>或者自定义更多的HTTP Method，例如<code>COPY</code>， <code>MOVE</code></p>
</li>
<li><h4 id="版本号定义"><a href="#版本号定义" class="headerlink" title="版本号定义"></a>版本号定义</h4><ul>
<li><p>在URI上定义版本号</p>
<p><code>/v1/xxx</code></p>
</li>
<li><p>在查询参数上定义版本号</p>
<p><code>/xxx?version=v1</code></p>
</li>
<li><p>在Header中定义版本号</p>
<p><code>X-Project-Version:v1</code></p>
</li>
</ul>
</li>
<li><h4 id="Token使用"><a href="#Token使用" class="headerlink" title="Token使用"></a>Token使用</h4><ul>
<li><p>使用Header携带Token</p>
<p><code>X-Auth-Token:xxxx</code></p>
</li>
<li><p>使用查询参数</p>
<p><code>/xxx?token=xxxx</code></p>
</li>
</ul>
</li>
</ol>
<h3 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h3><h4 id="HTTP-Method："><a href="#HTTP-Method：" class="headerlink" title="HTTP Method："></a>HTTP Method：</h4><blockquote>
<p>HEAD 和OPTIONS 相對少見。從資源操作的語義來講，一個針對某個目標資源發送的HEAD 請求一般不是為瞭獲取目標資源本身的內容，而是希望得到描述資源的元數據信息。服務器一般將對應資源的元數據置於響應的報頭集合返回給客戶端，所以這樣的響應一般不具有主體部分。OPTIONS 請求一般是一種“探測”請求，其目的在於確定針對某個目標地址的真實請求應該具有怎樣的約束（比如應該采用怎樣的HTTP 方法或者必須攜帶怎樣的自定義報頭），然後根據其約束發送符合條件的請求。比如針對“跨域資源”的預檢（Preflight）請求采用的HTTP方法就是OPTIONS。</p>
<p>POST 和PUT 請求一般將所加資源的內容置於請求的主體。但是對於PUT 請求來說，如果添加資源的內容完全可以由其URI 來提供，這樣的請求可以不需要主體部分。比如我們通過請求添加一個用於控制權限的角色，標識添加角色的URI 由其角色名稱來決定，並且不需要指定除角色名稱的其他信息，那麼我們隻要發送如下一個不含主體的PUT 請求即可。</p>
<p><code>PUT http://www.artech.com/roles/admin HTTP/1.1</code></p>
<p>除瞭進行資源的添加，PUT 請求還能用於資源的修改。由於請求包含提交資源的標識（可以放在URI 中，也可以置於主體部分的資源內容中），所以服務端能夠定位到對應的資源並予以修改。對於POST 和PUT 這兩種HTTP 方法，也存在一種一刀切的說法：POST 用於添加，PUT 用於修改。我個人比較認可的是：如果PUT 提供的資源不存在，則做添加操作，否則做修改操作。</p>
<p>對於發送PUT 請求以修改某個存在的資源，服務器一般會通過提供資源將原有資源整體“覆蓋”掉。如果需要進行“局部”修改，我們推薦采用PATCH 方法，因為從語義上講“PATCH”就是打補丁的意思。</p>
<p>關於HTTP 請求采用的這些方法，具有兩個基本特性，即“安全性”和“冪等性”。對於上述7 種HTTP 方法，GET、HEAD 和OPTIONS 均被認為是安全的方法，因為它們旨在實現對數據的獲取，並不具有“邊界效應（Side Effect④）”。至於其他4 個HTTP 方法，由於它們會導致服務端資源的變化，所以被認為是不安全的方法。</p>
<p>冪等性（Idempotent）是一個數學上的概念，在這裡表示發送一次和多次請求引起的邊界效應是一致的。在網速不夠快的情況下，客戶端發送一個請求後不能立即得到響應，由於不能確定請求是否被成功提交，所以它有可能會再次發送另一個相同的請求。冪等性決定瞭第二個請求是否有效。</p>
<p>上述3 種安全的HTTP方法（GET、HEAD和OPTIONS）均被視為冪等方法。由於DELETE和PATCH 請求操作的是現有的某個資源，所以它們都是冪等方法。對於PUT 請求，隻有在對應資源不存在的情況下服務器才會進行添加操作，否則隻進行修改操作，所以它也是冪等方法。至於POST，由於它總是進行添加操作，如果服務器接收到兩次相同的POST 操作，將導致兩個相同的資源被創建，所以這是一個非冪等的方法。</p>
<p><a href="http://www.wenwenti.info/article/143292" target="_blank" rel="noopener">http://www.wenwenti.info/article/143292</a></p>
</blockquote>
<h4 id="分布式架构风格比较："><a href="#分布式架构风格比较：" class="headerlink" title="分布式架构风格比较："></a>分布式架构风格比较：</h4><blockquote>
<p>从架构风格的抽象高度来看，常见的分布式应用架构风格有三种：</p>
<ul>
<li>分布式对象（Distributed Objects，简称DO）</li>
</ul>
<p>架构实例有CORBA/RMI/EJB/DCOM/.NET Remoting等等</p>
<ul>
<li>远程过程调用（Remote Procedure Call，简称RPC）</li>
</ul>
<p>架构实例有SOAP/XML-RPC/Hessian/Flash AMF/DWR等等</p>
<ul>
<li>表述性状态转移（Representational State Transfer，简称REST）</li>
</ul>
<p>架构实例有HTTP/WebDAV</p>
<p>DO和RPC这两种架构风格在企业应用中非常普遍，而REST则是Web应用的架构风格，它们之间有非常大的差别。</p>
<p>REST与DO的差别在于：</p>
<ul>
<li>REST支持抽象（即建模）的工具是资源，DO支持抽象的工具是对象。在不同的编程语言中，对象的定义有很大差别，所以DO风格的架构通常都是与某种编程语言绑定的。跨语言交互即使能实现，实现起来也会非常复杂。而REST中的资源，则完全中立于开发平台和编程语言，可以使用任何编程语言来实现。</li>
<li>DO中没有统一接口的概念。不同的API，接口设计风格可以完全不同。DO也不支持操作语义对于中间组件的可见性。</li>
<li>DO中没有使用超文本，响应的内容中只包含对象本身。REST使用了超文本，可以实现更大粒度的交互，交互的效率比DO更高。</li>
<li>REST支持数据流和管道，DO不支持数据流和管道。</li>
<li>DO风格通常会带来客户端与服务器端的紧耦合。在三种架构风格之中，DO风格的耦合度是最大的，而REST的风格耦合度是最小的。REST松耦合的源泉来自于统一接口+超文本驱动。</li>
</ul>
<p>REST与RPC的差别在于：</p>
<ul>
<li><p>REST支持抽象的工具是资源，RPC支持抽象的工具是过程。REST风格的架构建模是以名词为核心的，RPC风格的架构建模是以动词为核心的。简单类比一下，REST是面向对象编程，RPC则是面向过程编程。</p>
</li>
<li><p>RPC中没有统一接口的概念。不同的API，接口设计风格可以完全不同。RPC也不支持操作语义对于中间组件的可见性。</p>
</li>
<li><p>RPC中没有使用超文本，响应的内容中只包含消息本身。REST使用了超文本，可以实现更大粒度的交互，交互的效率比RPC更高。</p>
</li>
<li><p>REST支持数据流和管道，RPC不支持数据流和管道。</p>
</li>
<li><p>因为使用了平台中立的消息，RPC风格的耦合度比DO风格要小一些，但是RPC风格也常常会带来客户端与服务器端的紧耦合。支持统一接口+超文本驱动的REST风格，可以达到最小的耦合度。</p>
<p><a href="http://www.infoq.com/cn/articles/understanding-restful-style" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/understanding-restful-style</a></p>
</li>
</ul>
</blockquote>
<h4 id="基于HTTP的API的分类"><a href="#基于HTTP的API的分类" class="headerlink" title="基于HTTP的API的分类"></a>基于HTTP的API的分类</h4><blockquote>
<p><a href="http://www.jalg.net/classification_of_http_apis.html" target="_blank" rel="noopener">http://www.jalg.net/classification_of_http_apis.html</a></p>
<p>表示我们目前设计的并不是Restful的API。</p>
</blockquote>
<h4 id="OData和GraphQL"><a href="#OData和GraphQL" class="headerlink" title="OData和GraphQL"></a>OData和GraphQL</h4><blockquote>
<p>开放数据协议（Open Data Protocol，缩写OData）是一种描述如何创建和访问<a href="https://baike.baidu.com/item/Restful" target="_blank" rel="noopener">Restful</a>服务的<a href="https://baike.baidu.com/item/OASIS/4235159" target="_blank" rel="noopener">OASIS</a>标准。</p>
<p><a href="http://www.odata.org/getting-started/basic-tutorial/" target="_blank" rel="noopener">http://www.odata.org/getting-started/basic-tutorial/</a></p>
<p>GraphQL是一种支持API的查询语言，用户提高数据交互的效率。</p>
<p><a href="https://github.com/airplake/GraphQL-Learn-Chinese" target="_blank" rel="noopener">https://github.com/airplake/GraphQL-Learn-Chinese</a></p>
<p><a href="http://www.jianshu.com/p/2ec22fc1219c" target="_blank" rel="noopener">http://www.jianshu.com/p/2ec22fc1219c</a></p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title>Restful约定</title>
    <url>/2020/04/19/Restful%E7%BA%A6%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="Restful约定"><a href="#Restful约定" class="headerlink" title="Restful约定"></a>Restful约定</h1><p>[TOC]</p>
<p>Restful的复杂之处不在于它的定义与难以理解，而在与它未定义的部分。为了编写一个完全Restful的接口，我们可能要写出很多古怪而复杂的代码。所以为了统一开发人员的理解与开发过程，这里约定一些在Restful的规范，它不是标准的Restful定义，但是尽量利用Restful的优点。</p>
<a id="more"></a>

<h3 id="URI命名"><a href="#URI命名" class="headerlink" title="URI命名"></a>URI命名</h3><ul>
<li><p>以资源路径命名，路径名称必须是名词</p>
</li>
<li><p>名词表示资源集合，使用复数形式； 单数资源，可以使用单数形式</p>
</li>
<li><p>子资源：/资源名/id/子资源名/id</p>
</li>
<li><p>uri命名建议：不用大写，用中杠 <strong>-</strong> 不用下杠 <strong>_</strong> </p>
</li>
<li><p>示例：</p>
<blockquote>
<p>/users</p>
<p>/users/1</p>
<p>/users/1/name</p>
<p>/users/validation</p>
<p>/users/name-validation</p>
<p>/orgs/1/users</p>
</blockquote>
</li>
</ul>
<h3 id="基于HTTP-Method语义对资源CRUD"><a href="#基于HTTP-Method语义对资源CRUD" class="headerlink" title="基于HTTP Method语义对资源CRUD"></a>基于HTTP Method语义对资源CRUD</h3><table>
<thead>
<tr>
<th>HTTP Method</th>
<th>URI</th>
<th>HTTP body</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>/users</td>
<td>无</td>
<td>用户列表</td>
</tr>
<tr>
<td>GET</td>
<td>/users/uid</td>
<td>无</td>
<td>用户信息</td>
</tr>
<tr>
<td>POST</td>
<td>/users</td>
<td><code>{&quot;name&quot;:&quot;xx&quot;,&quot;age&quot;18}</code></td>
<td>创建用户</td>
</tr>
<tr>
<td>PATCH</td>
<td>/users/uid</td>
<td><code>{&quot;name&quot;:&quot;xx&quot;}</code></td>
<td>修改用户（部分更新）</td>
</tr>
<tr>
<td>PUT</td>
<td>/users/uid</td>
<td><code>{&quot;name&quot;:&quot;aa&quot;,&quot;age&quot;15}</code></td>
<td>修改用户（全量更新）</td>
</tr>
<tr>
<td>DELETE</td>
<td>/users/uid</td>
<td>无</td>
<td>删除用户</td>
</tr>
</tbody></table>
<h3 id="使用HTTP状态码准确描述相应结果"><a href="#使用HTTP状态码准确描述相应结果" class="headerlink" title="使用HTTP状态码准确描述相应结果"></a>使用HTTP状态码准确描述相应结果</h3><p>200：ok</p>
<p>201：created</p>
<p>204：no content</p>
<p>400: bad request</p>
<p>401: not authorized</p>
<p>403: forbidden</p>
<p>500: server error</p>
<h3 id="使用Content-Type准确描述资源内容"><a href="#使用Content-Type准确描述资源内容" class="headerlink" title="使用Content-Type准确描述资源内容"></a>使用Content-Type准确描述资源内容</h3><table>
<thead>
<tr>
<th>Content-Type</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>application/json</td>
<td>JSON</td>
</tr>
<tr>
<td>application/xml</td>
<td>XML</td>
</tr>
<tr>
<td>text/html</td>
<td>HTML</td>
</tr>
</tbody></table>
<h3 id="统一的错误返回值"><a href="#统一的错误返回值" class="headerlink" title="统一的错误返回值"></a>统一的错误返回值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;message&quot;:&quot;用户未认证&quot;,</span><br><span class="line">    &quot;code&quot;: &quot;1001&quot;,</span><br><span class="line">    &quot;data&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><ul>
<li><p>第一种，优先考虑使用</p>
<p><code>DELETE  /users/1,2,3</code></p>
</li>
<li><p>第二种</p>
<p><code>DELETE /users?id=1&amp;id=2</code></p>
</li>
</ul>
<h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>request:</p>
<p><code>PUT  /users</code></p>
<p>body: </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"id"</span>:<span class="number">1</span>, <span class="attr">"name"</span>:<span class="string">"xx"</span>&#125;, &#123;<span class="attr">"id"</span>:<span class="number">2</span>,<span class="attr">"name"</span>:<span class="string">"ss"</span>&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="分页接口"><a href="#分页接口" class="headerlink" title="分页接口"></a>分页接口</h3><ul>
<li><p>第一种，常用，优先考虑使用</p>
<p>带有分页元信息的响应体</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"page"</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">"total"</span>:<span class="number">10</span>,</span><br><span class="line">  <span class="attr">"records"</span>:[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>第二种</p>
<p> 在HTTP header中增加X-Total-Count表示总数的元信息。</p>
<p>   增加Link header表示上一页、下一页的超链接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Header</span><br><span class="line">X-Total-Count:10</span><br><span class="line">X-Current-Page:2</span><br><span class="line">Link: &lt;http:&#x2F;&#x2F;xx?page&#x3D;3&gt;;rel&#x3D;&quot;next&quot;,&lt;http:&#x2F;&#x2F;xx?page&#x3D;1&gt;;rel&#x3D;&quot;pre&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Response Body</span></span><br><span class="line">[&#123;</span><br><span class="line">  <span class="attr">"id"</span>:<span class="string">"xx"</span>,</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"xx"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">"id"</span>:<span class="string">"ss"</span>,</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"ss"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="查询语言的定义"><a href="#查询语言的定义" class="headerlink" title="查询语言的定义"></a>查询语言的定义</h3><p>如果存在多个参数，既有精确匹配，又有模糊匹配</p>
<p><code>/users?name=shen&amp;nameLike=shen&amp;email=shen@qq.com&amp;emailLike=qq.com</code></p>
<h3 id="PATCH与POST"><a href="#PATCH与POST" class="headerlink" title="PATCH与POST"></a>PATCH与POST</h3><p>从现在开始尽量使用PATCH，旧版本可以用POST替代PATCH</p>
<h3 id="版本号定义"><a href="#版本号定义" class="headerlink" title="版本号定义"></a>版本号定义</h3><ul>
<li><p>在URI上定义版本号，优先考虑使用</p>
<p><code>/v1/xxx</code></p>
</li>
<li><p>在Header中定义版本号</p>
<p><code>X-Project-Version:v1</code></p>
</li>
</ul>
<h3 id="Token使用"><a href="#Token使用" class="headerlink" title="Token使用"></a>Token使用</h3><ul>
<li><p>使用Header携带Token，优先考虑使用</p>
<p><code>X-Auth-Token:xxxx</code></p>
</li>
<li><p>使用查询参数</p>
<p><code>/xxx?token=xxxx</code></p>
</li>
</ul>
<h3 id="多对多关联关系"><a href="#多对多关联关系" class="headerlink" title="多对多关联关系"></a>多对多关联关系</h3><ul>
<li><p>/teams/tid/users，优先考虑使用</p>
<p>更容易理解，但是有悖于Restful理解。/teams/tid/users应该是一组关系，但是返回值通常被定义为用户资源列表。如果理解为这是用户资源，那么POST和DELETE操作理论上应该是用户创建和用户删除。</p>
<p>如果/teams/tid/users使用超媒体链接表示用户关系，那么前后台业务都会增加，很难通过链接数组获取用户列表。</p>
</li>
</ul>
<ul>
<li>/memberships<ol>
<li>如果希望同时获取多对多关系本身的属性,例如team下的一些信息：教练…等。使用/memberships/shipId可以更清楚的表示出来一组关系。</li>
<li>关于缓存，如果使用/teams/3/players/失效时，可能同时需要/players/5/teams/失效，但是使用/memberships/，仅仅一个资源表示关联关系，可以减少服务端或者客户端关于缓存的操作。</li>
<li>通过/teams/tid/ players或者/players/uid/teams,如果当你需要增加一种新的关联关系，例如：过去的team成员列表, 可能需要在现有的请求体、响应体中增加历史成员列表以适应接口的变更。但是使用/memberships/{id}/表示多对多关系时，可以通过/players/5/memberships/ 和/players/5/past_memberships/来处理这些关联关系，通过增加接口数量保证原有接口的稳定性。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Restful</category>
      </categories>
      <tags>
        <tag>约定</tag>
      </tags>
  </entry>
  <entry>
    <title>ServiceLoader</title>
    <url>/2020/04/21/ServiceLoader/</url>
    <content><![CDATA[<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>SPI ，全称为 Service Provider Interface，是一种服务发现机制。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类。</p>
<p>这一机制为很多框架扩展提供了可能，比如在Dubbo、JDBC、SpringBoot中都使用到了SPI机制。</p>
<p>用法：通过SPI，我们可以动态的根据导入的jar包，发现需要的接口实现类，尤其是策略模式下。<br>无需手动指定接口的实现类，通过ServiceLoader可以自动选择实现类并创建实例对象。</p>
<a id="more"></a> 
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>定义接口 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SPIService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>定义实现类 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiImpl1</span> <span class="keyword">implements</span> <span class="title">SPIService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpiImpl1.execute()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建配置文件<br> 在src/main/resources文件夹内创建META-INF/services/xxx.SPIService 文件<br> 在文件内写入子类的全路径类名 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxx.SpiImpl1</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="源码中的懒加载"><a href="#源码中的懒加载" class="headerlink" title="源码中的懒加载"></a>源码中的懒加载</h2><p>ServiceLoader 内部使用了懒加载模式，只有当需要获取对象时，<br>会调用内部的LazyIterator类的方法去寻找和加载发现的类。<br>查找实现类和创建实现类的过程，都在LazyIterator完成。当我们调用iterator.hasNext和iterator.next方法的时候，实际上调用的都是LazyIterator的相应方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//要加载的接口</span></span><br><span class="line">            service = Objects.requireNonNull(svc, <span class="string">"Service interface cannot be null"</span>);</span><br><span class="line">            <span class="comment">//类加载器</span></span><br><span class="line">            loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">            <span class="comment">//访问控制器</span></span><br><span class="line">            acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//先清空</span></span><br><span class="line">            providers.clear();</span><br><span class="line">            <span class="comment">//实例化内部类 </span></span><br><span class="line">            LazyIterator lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对类的查询都是通过LazyIterator代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析LazyIterator的hasNextService方法，只有在第一次时，解析出pending对象获取所有的类，后续都是读取pending对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt;</span>&#123;</span><br><span class="line">    Class&lt;S&gt; service;</span><br><span class="line">    ClassLoader loader;</span><br><span class="line">    Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;</span><br><span class="line">    Iterator&lt;String&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">    String nextName = <span class="keyword">null</span>; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第二次调用的时候，已经解析完成了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//META-INF/services/ 加上接口的全限定类名，就是文件服务类的文件</span></span><br><span class="line">            <span class="comment">//META-INF/services/com.viewscenes.netsupervisor.spi.SPIService</span></span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="comment">//将文件路径转成URL对象</span></span><br><span class="line">            configs = loader.getResources(fullName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//解析URL文件对象，读取内容，最后返回</span></span><br><span class="line">            pending = parse(service, configs.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到第一个实现类的类名</span></span><br><span class="line">        nextName = pending.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDBC示例"><a href="#JDBC示例" class="headerlink" title="JDBC示例"></a>JDBC示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        loadInitialDrivers();</span><br><span class="line">        println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读loadInitialDrivers方法，它在里面查找的是Driver接口的服务类，所以它的文件路径就是：META-INF/services/java.sql.Driver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//很明显，它要加载Driver接口的服务类，Driver接口的包为:java.sql.Driver</span></span><br><span class="line">                <span class="comment">//所以它要找的就是META-INF/services/java.sql.Driver文件</span></span><br><span class="line">                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//查到之后创建对象</span></span><br><span class="line">                    <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                        driversIterator.next();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">                    <span class="comment">// Do nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，com.mysql.cj.jdbc.Driver在DriverManager注册时，也完成了一件事，就是向DriverManager注册自己。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注册</span></span><br><span class="line">            <span class="comment">//调用DriverManager类的注册方法</span></span><br><span class="line">            <span class="comment">//往registeredDrivers集合中加入实例</span></span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java SPI机制：ServiceLoader</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SLF4J</title>
    <url>/2020/04/19/Slf4j%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h1><p>[TOC]</p>
<p>SLF4J是用于日志记录系统的外观模块（facade），允许最终用户在部署时插入所需的日志记录系统。</p>
<p>SLF4J有利于维护和各个类的日志处理方式统一</p>
<p><a href="https://www.slf4j.org" target="_blank" rel="noopener">https://www.slf4j.org</a></p>
<h2 id="JCL与SLF4j"><a href="#JCL与SLF4j" class="headerlink" title="JCL与SLF4j"></a>JCL与SLF4j</h2><p>​    Jakarta Commons Logging (JCL)提供的是一个日志(Log)接口(interface)，同时兼顾轻量级和不依赖于具体的日志实现工具。 它提供给中间件/日志工具开发者一个简单的日志操作抽象，允许程序开发人员使用不同的具体日志实现工具。用户被假定已熟悉某种日志实现工具的更高级别的细节。JCL提供的接口，对其它一些日志工具，包括Log4J, Avalon LogKit, and JDK 1.4等，进行了简单的包装，此接口更接近于Log4J和LogKit的实现. </p>
<h3 id="JCL的缺点："><a href="#JCL的缺点：" class="headerlink" title="JCL的缺点："></a>JCL的缺点：</h3><p><strong>common-logging</strong>通过动态查找的机制，在程序运行时自动找出真正使用的日志库。由于它使用了ClassLoader寻找和载入底层的日志库， 导致了象OSGI这样的框架无法正常工作，因为OSGI的不同的插件使用自己的ClassLoader。 OSGI的这种机制保证了插件互相独立，然而却使Apache Common-Logging无法工作。</p>
<p><a href="http://wrschneider.blogspot.com/2005/06/commons-logging-classloader-pain_18.html" target="_blank" rel="noopener">commons-logging classloader pain </a></p>
<p><strong>slf4j</strong>在编译时静态绑定真正的Log库,因此可以再OSGI中使用。另外，SLF4J 支持参数化的log字符串，提高性能和代码简洁。</p>
<h2 id="SLF4J绑定"><a href="#SLF4J绑定" class="headerlink" title="SLF4J绑定"></a>SLF4J绑定</h2><p><a href="https://stackoverflow.com/questions/42186919/how-slf4j-jpa-jax-rs-find-their-implementation" target="_blank" rel="noopener">https://stackoverflow.com/questions/42186919/how-slf4j-jpa-jax-rs-find-their-implementation</a></p>
<p><a href="https://v4forums.wordpress.com/2008/12/27/slf4j-vs-jcl-dynamic-binding-vs-static-binding/" target="_blank" rel="noopener">https://v4forums.wordpress.com/2008/12/27/slf4j-vs-jcl-dynamic-binding-vs-static-binding/</a></p>
<h2 id="Logger是否声明为静态字段？"><a href="#Logger是否声明为静态字段？" class="headerlink" title="Logger是否声明为静态字段？"></a>Logger是否声明为静态字段？</h2><p> <strong>we no longer recommend one approach over the other.</strong></p>
<p>Here is a summary of the pros and cons of each approach.</p>
<table>
<thead>
<tr>
<th>Advantages for declaring loggers as static</th>
<th>Disadvantages for declaring loggers as static</th>
</tr>
</thead>
<tbody><tr>
<td>common and well-established idiomless CPU overhead: loggers are retrieved and assigned only once, at hosting class initializationless memory overhead: logger declaration will consume one reference per class</td>
<td>For libraries shared between applications, not possible to take advantage of repository selectors. It should be noted that if the SLF4J binding and the underlying API ships with each application (not shared between applications), then each application will still have its own logging environment.not IOC-friendly</td>
</tr>
<tr>
<td>Advantages for declaring loggers as instance variables</td>
<td>Disadvantages for declaring loggers as instance variables</td>
</tr>
<tr>
<td>Possible to take advantage of repository selectors even for libraries shared between applications. However, repository selectors only work if the underlying logging system is logback-classic. Repository selectors do not work for the SLF4J+log4j combination.IOC-friendly</td>
<td>Less common idiom than declaring loggers as static variableshigher CPU overhead: loggers are retrieved and assigned for each instance of the hosting classhigher memory overhead: logger declaration will consume one reference per instance of the hosting class</td>
</tr>
</tbody></table>
<p>静态字段：内存和CPU消耗更少，但是IOC不好。</p>
<p>非静态字段：消耗更多内存和CPU，但是IOC友好。</p>
<p>从当前角度来看，更多的选择静态字段。</p>
<h2 id="推荐声明-SLF4JLogger"><a href="#推荐声明-SLF4JLogger" class="headerlink" title="推荐声明 SLF4JLogger"></a>推荐声明 SLF4JLogger</h2><p>The following is the recommended logger declaration idiom. For reasons <a href="https://www.slf4j.org/faq.html#declared_static" target="_blank" rel="noopener">explained above</a>, it is left to the user to determine whether loggers are declared as static variables or not.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package some.package;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">      </span><br><span class="line">public class MyClass &#123;</span><br><span class="line">  final (static) Logger logger &#x3D; LoggerFactory.getLogger(MyClass.class);</span><br><span class="line">  ... etc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Unfortunately, given that the name of the hosting class is part of the logger declaration, the above logger declaration idiom is <em>not</em> resistant to cut-and-pasting between classes.</p>
<p>Alternatively, you can use <code>MethodHandles.lookup()</code> introduced in JDK 7 to pass the caller class.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package some.package;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import java.lang.invoke.MethodHandles;</span><br><span class="line">      </span><br><span class="line">public class MyClass &#123;</span><br><span class="line">  final static Logger logger &#x3D; LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span><br><span class="line">  ... etc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This pattern can be cut and pasted across classes.</p>
<h2 id="MDC"><a href="#MDC" class="headerlink" title="MDC"></a>MDC</h2><p>　MDC（Mapped Diagnostic Context，映射调试上下文）是 log4j 和 logback 提供的一种方便在多线程条件下记录日志的功能。 </p>
<p>MDC 可以看成是一个与当前线程绑定的哈希表，可以往其中添加键值对。MDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。当需要记录日志时，只需要从 MDC 中获取所需的信息即可。 </p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Around(value &#x3D; &quot;execution(* com.xx.xx.facade.impl.*.*(..))&quot;, argNames&#x3D;&quot;pjp&quot;)</span><br><span class="line">  public Object validator(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          String traceId &#x3D; TraceUtils.begin();</span><br><span class="line">          MDC.put(&quot;mdc_trace_id&quot;, traceId);</span><br><span class="line">          Object obj &#x3D; pjp.proceed(args);</span><br><span class="line">          return obj;</span><br><span class="line">      &#125; catch(Throwable e) &#123;</span><br><span class="line">          &#x2F;&#x2F;TODO 处理错误</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          TraceUtils.endTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>代码通过AOP记录了每次请求的traceId并使用变量”mdc_trace_id”记录，在日志配置文件里需要设置变量才能将”mdc_trace_id”输出到日志文件中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ALL"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">      <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - traceId:[%X&#123;mdc_trace_id&#125;] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>log</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Slf4j配置</title>
    <url>/2020/04/19/Slf4j%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Slf4j"><a href="#Slf4j" class="headerlink" title="Slf4j"></a>Slf4j</h1><p>[TOC]</p>
<h2 id="功能依赖"><a href="#功能依赖" class="headerlink" title="功能依赖"></a>功能依赖</h2><p><img src="https://tva1.sinaimg.cn/large/007S2YVMgy1gdzit7wo76j30w00homz4.jpg" alt="image"></p>
<h2 id="桥接包："><a href="#桥接包：" class="headerlink" title="桥接包："></a>桥接包：</h2><p><a href="http://www.slf4j.org/legacy.html" target="_blank" rel="noopener">http://www.slf4j.org/legacy.html</a></p>
<p>1，从Jakarta Commons Logging (JCL)迁移到slf4j： 用“jcl-over-slf4j.jar”替换掉“commons-logging.jar”即可</p>
<p>​     如果在maven中：1，明确的标记exclusion掉common-logging.jar。2，声明common-logging.jar的依赖范围为“provided”（在IED里显示不太好，注意顺序）。</p>
<p>2，很少见的特殊情况，想要把slf4j日志转移到JCL上：用slf4j-jcl.jar包</p>
<p>​     ——上述两个包不能一起用，否则死循环（这很好理解）</p>
<p>3，从log4j迁移到slf4j（居然直接针对log4j编码，太2了）：用“log4j-over-slf4j.jar”替换掉“log4j.jar”即可。</p>
<p>​     ——上述包不能与“slf4j-log4j12.jar”一起用，否则死循环（一样的道理）。</p>
<p>4，从java.util.logging（JUL）迁移到slf4j——jvm自己的类不允许随便替换，所以这里比较复杂(SLF4JBridgeHandler+jul-to-slf4j.jar)，而且有性能问题，很少用到，用的时候再研究。</p>
<p>​      ——上述包不能与“slf4j-jdk14.jar”一起用，否则死循环（一样的道理）。</p>
<h2 id="桥接流程"><a href="#桥接流程" class="headerlink" title="桥接流程"></a>桥接流程</h2><h3 id="Logback日志，桥接Log4j、JCL、JUL"><a href="#Logback日志，桥接Log4j、JCL、JUL" class="headerlink" title="Logback日志，桥接Log4j、JCL、JUL"></a>Logback日志，桥接Log4j、JCL、JUL</h3><h3 id="Log4j日志，桥接JCL、JUL"><a href="#Log4j日志，桥接JCL、JUL" class="headerlink" title="Log4j日志，桥接JCL、JUL"></a>Log4j日志，桥接JCL、JUL</h3><h3 id="JUL日志，桥接JCL、Log4j"><a href="#JUL日志，桥接JCL、Log4j" class="headerlink" title="JUL日志，桥接JCL、Log4j"></a>JUL日志，桥接JCL、Log4j</h3><p><img src="https://tvax2.sinaimg.cn/large/007S2YVMgy1gdziqa13ujj31830v70xc.jpg" alt="image"></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在maven中声明包的实现：</p>
<p>对于普通项目（并不是一个工具包）：</p>
<blockquote>
<ul>
<li>logback：</li>
</ul>
<p>​          声明对logback-classic-1.0.13.jar的依赖即可，会自动关联依赖slf4j-api-1.7.7.jar和logback-core-1.0.13.jar（显式声明这两个关联依赖也可以）</p>
<ul>
<li>log4j：</li>
</ul>
<p>​          声明对slf4j-log4j12-1.7.7.jar的依赖即可，会自动关联依赖slf4j-api-1.7.7.jar和log4j-1.2.17.jar</p>
<ul>
<li>jdk log：</li>
</ul>
<p>​          声明对slf4j-jdk14-1.7.7.jar的依赖即可，会自动关联依赖slf4j-api-1.7.7.jar</p>
</blockquote>
<p>对于工具包项目：</p>
<blockquote>
<p>仅仅依赖slf4j-api即可，让用户自己决定底层用什么实现。</p>
</blockquote>
<p>二进制兼容性：</p>
<blockquote>
<p>各个api绑定包，与下面的日志实现包，其版本必须对应。比如slf4j-api-1.7.7.jar应该对应slf4j-simple-1.7.7.jar.</p>
<p> 而上层的应用程序，与其依赖的slf4j-api是各个版本都完全兼容的。</p>
</blockquote>
<p>支持MDC（Mapped Diagnostic Context）</p>
<blockquote>
<p>同时需要底层的日志包也支持，例如logback或者log4j。</p>
</blockquote>
<h2 id="Logback-Pattern"><a href="#Logback-Pattern" class="headerlink" title="Logback Pattern"></a>Logback Pattern</h2><p><a href="https://logback.qos.ch/manual/layouts.html" target="_blank" rel="noopener">https://logback.qos.ch/manual/layouts.html</a></p>
<table>
<thead>
<tr>
<th>%m</th>
<th>输出代码中指定的消息</th>
</tr>
</thead>
<tbody><tr>
<td>%p</td>
<td>输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</td>
</tr>
<tr>
<td>%r</td>
<td>输出自应用启动到输出该log信息耗费的毫秒数</td>
</tr>
<tr>
<td>%c</td>
<td>输出所属的类目，通常就是所在类的全名</td>
</tr>
<tr>
<td>%t</td>
<td>输出产生该日志事件的线程名</td>
</tr>
<tr>
<td>%n</td>
<td>输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n”</td>
</tr>
<tr>
<td>%d</td>
<td>输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921</td>
</tr>
<tr>
<td>%l</td>
<td>输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)</td>
</tr>
</tbody></table>
<p>%c{length} /%lo{length} /logger{length} 打印logger名称，并控制长度，比如；%logger{5}   mainPackage.sub.sample.Bar  m.s.s.Bar</p>
<p>%C{length} /class{length} 打印出产生这条log的调用方的完整名字，并控制长度。这个方法效率不高，慎用。(目测要调用堆栈才能查到调用方的类名或者方法)</p>
<p>%contextName / %cn 打印出logger的上下文信息。在Configuration一节中我们曾经看到过这个的使用</p>
<p>%d{pattern} / %date{pattern} /%d{pattern, timezone} /%date{pattern, timezone} 打印出当前时间，通过pattern来控制日期格式，比如：%date{HH:mm:ss.SSS}    14:06:49.812</p>
<p>%F / %file 打印出产生这条log的java源文件，这个方法效率不高，慎用。</p>
<ol>
<li>%caller{depth}</li>
<li>%caller{depthStart..depthEnd}</li>
<li>%caller{depth, evaluator-1, … evaluator-n}</li>
<li>%caller{depthStart..depthEnd, evaluator-1, … evaluator-n}</li>
</ol>
<p>%L / %line 打印出产生这条log的源码行号</p>
<p>%m / %msg / %message 打印loggger方法传入的消息，比如.loggger.info(“hello”),指代这里的“hello”</p>
<p>%M / %method 打印出产生这条log的方法名，效率不高</p>
<p>%n 换行</p>
<p>%p / %le /%level 打印出日志等级</p>
<p>%r / %relative 打印出自动App启动至今流逝的时间（单位：毫秒）</p>
<p>%t / %thread 打印出产生这条log的线程名字</p>
<p>%X{key:-defaultVal} / mdc{key:-defaultVal} 打印出MDC中定义的上下文</p>
<ol>
<li><p>%ex{depth}</p>
</li>
<li><p>%exception{depth}</p>
</li>
<li><p>%throwable{depth}</p>
</li>
<li><p>%ex{depth, evaluator-1, …, evaluator-n}</p>
</li>
<li><p>%exception{depth, evaluator-1, …, evaluator-n}</p>
</li>
<li><p>%throwable{depth, evaluator-1, …, evaluator-n}</p>
</li>
<li><p>%xEx{depth}</p>
</li>
<li><p>%xException{depth}</p>
</li>
<li><p>%xThrowable{depth}</p>
</li>
<li><p>%xEx{depth, evaluator-1, …, evaluator-n}</p>
</li>
<li><p>%xException{depth, evaluator-1, …, evaluator-n}</p>
</li>
<li><p>%xThrowable{depth, evaluator-1, …, evaluator-n}</p>
</li>
</ol>
<p>%nopex /%nopexception 忽略异常信息</p>
<p>%marker 打印marker信息，格式：parentName [ child1, child2 ]</p>
<p>%property{key} 引用之前定义的变量（或属性）</p>
<p>%replace(p){r, t} 举例说明：%replace(%msg){‘\s’, ‘’}，会把消息中的所有空格移除</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>log</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot 日志</title>
    <url>/2020/04/19/Springboot%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="Springboot-日志"><a href="#Springboot-日志" class="headerlink" title="Springboot 日志"></a>Springboot 日志</h1><p>[TOC]</p>
<h2 id="默认日志-Logback："><a href="#默认日志-Logback：" class="headerlink" title="默认日志 Logback："></a>默认日志 <code>Logback</code>：</h2><p>默认情况下，Spring Boot会用Logback来记录日志，并用<strong>INFO</strong>级别输出到控制台。在运行应用程序和其他例子时，你应该已经看到很多INFO级别的日志了。</p>
<p><code>spring-boot-starter</code>其中包含了 <code>spring-boot-starter-logging</code>，该依赖内容就是 <code>Spring Boot</code> 默认的日志框架 <code>logback</code>。 </p>
<p>Spring Boot默认配置只会输出到控制台，并不会记录到文件中 。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>application.properties</p>
<ul>
<li><code>logging.file</code>，设置文件，可以是绝对路径，也可以是相对路径。如：<code>logging.file=my.log</code></li>
<li><code>logging.path</code>，设置目录，会在该目录下创建<code>spring.log</code>文件，并写入日志内容，如：<code>logging.path=/var/log</code></li>
<li>二者不能同时使用，如若同时使用，则只有<code>logging.file</code>生效 默认情况下，日志文件的大小达到<code>10MB</code>时会切分一次，产生新的日志文件，默认级别为：<code>ERROR、WARN、INFO</code> </li>
<li><code>logging.level</code>：日志级别控制前缀，*为包名或Logger名 </li>
<li><code>logging.level.root</code>：配置默认的日志级别</li>
<li>logging.pattern.console：定义输出到控制台的样式（不支持JDK Logger）</li>
<li>logging.pattern.file：定义输出到文件的样式（不支持JDK Logger）</li>
</ul>
<h3 id="多彩输出"><a href="#多彩输出" class="headerlink" title="多彩输出"></a>多彩输出</h3><p>如果你的终端支持ANSI，设置彩色输出会让日志更具可读性。通过在<code>application.properties</code>中设置<code>spring.output.ansi.enabled</code>参数来支持。</p>
<ul>
<li>NEVER：禁用ANSI-colored输出（默认项）</li>
<li>DETECT：会检查终端是否支持ANSI，是的话就采用彩色输出（推荐项）</li>
<li>ALWAYS：总是使用ANSI-colored格式输出，若终端不支持的时候，会有很多干扰信息，不推荐使用</li>
</ul>
<h2 id="自定义日志配置"><a href="#自定义日志配置" class="headerlink" title="自定义日志配置"></a>自定义日志配置</h2><p>根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：</p>
<ul>
<li><p>Logback：<code>logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy</code> </p>
</li>
<li><p>Log4j：<code>log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml</code> </p>
</li>
<li><p>Log4j2：<code>log4j2-spring.xml, log4j2.xml</code> </p>
</li>
<li><p>JDK (Java Util Logging)：<code>logging.properties</code></p>
</li>
<li><p>自定义日志配置文件位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging.config&#x3D;classpath:logging-config.xml</span><br></pre></td></tr></table></figure>

<p><code>Spring Boot</code>官方推荐优先使用带有<code>-spring</code>的文件名作为你的日志配置（如使用<code>logback-spring.xml</code>，而不是<code>logback.xml</code>），命名为<code>logback-spring.xml</code>的日志配置文件，<code>spring boot</code>可以为它添加一些<code>spring boot</code>特有的配置项。</p>
</li>
</ul>
<h2 id="常用logbck-spring-xml配置"><a href="#常用logbck-spring-xml配置" class="headerlink" title="常用logbck-spring.xml配置"></a>常用logbck-spring.xml配置</h2><h3 id="根节点-lt-configuration-gt-包含的属性"><a href="#根节点-lt-configuration-gt-包含的属性" class="headerlink" title="根节点&lt;configuration&gt;包含的属性"></a><strong>根节点&lt;configuration&gt;包含的属性</strong></h3><ul>
<li>scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</li>
<li>scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</li>
<li>debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</li>
</ul>
<h3 id="contextName"><a href="#contextName" class="headerlink" title="contextName"></a>contextName</h3><p>每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改,可以通过%contextName来打印日志上下文名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;contextName&gt;logback&lt;&#x2F;contextName&gt;</span><br></pre></td></tr></table></figure>

<h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>用来定义变量值的标签， 有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;log.path&quot; value&#x3D;&quot;&#x2F;Users&#x2F;tengjun&#x2F;Documents&#x2F;log&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>



<h3 id="appender"><a href="#appender" class="headerlink" title="appender"></a>appender</h3><p>appender用来格式化日志输出节点，有俩个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。</p>
<p>#####控制台输出ConsoleAppender：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--输出到控制台--&gt;</span><br><span class="line">&lt;appender name&#x3D;&quot;console&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">    &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">        &lt;level&gt;ERROR&lt;&#x2F;level&gt;</span><br><span class="line">    &lt;&#x2F;filter&gt;</span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">        &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;&#x2F;pattern&gt;</span><br><span class="line">    &lt;&#x2F;encoder&gt;</span><br><span class="line">&lt;&#x2F;appender&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;encoder&gt;</code>表示对日志进行编码：</p>
<ul>
<li><code>%d{HH: mm:ss.SSS}</code>——日志输出时间</li>
<li><code>%thread</code>——输出日志的进程名字，这在Web应用以及异步任务处理中很有用</li>
<li><code>%-5level</code>——日志级别，并且使用5个字符靠左对齐</li>
<li><code>%logger{36}</code>——日志输出者的名字</li>
<li><code>%msg</code>——日志消息</li>
<li><code>%n</code>——平台的换行符</li>
</ul>
<p>ThresholdFilter为系统定义的拦截器，例如我们用ThresholdFilter来过滤掉ERROR级别以下的日志不输出到文件中。如果不用记得注释掉，不然你控制台会发现没日志~</p>
<h4 id="RollingFileAppender"><a href="#RollingFileAppender" class="headerlink" title="RollingFileAppender"></a>RollingFileAppender</h4><p>另一种常见的日志输出到文件，随着应用的运行时间越来越长，日志也会增长的越来越多，将他们输出到同一个文件并非一个好办法。<code>RollingFileAppender</code>用于切分文件日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--输出到文件--&gt;</span><br><span class="line">&lt;appender name&#x3D;&quot;file&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">		&lt;fileNamePattern&gt;$&#123;log.path&#125;&#x2F;logback.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;fileNamePattern&gt;</span><br><span class="line">        &lt;maxHistory&gt;30&lt;&#x2F;maxHistory&gt;</span><br><span class="line">		&lt;totalSizeCap&gt;1GB&lt;&#x2F;totalSizeCap&gt;</span><br><span class="line">    &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">        &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;&#x2F;pattern&gt;</span><br><span class="line">    &lt;&#x2F;encoder&gt;</span><br><span class="line">&lt;&#x2F;appender&gt;</span><br></pre></td></tr></table></figure>

<p>其中重要的是<code>rollingPolicy</code>的定义，上例中<code>&lt;fileNamePattern&gt;${log.path}/logback.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;</code>定义了日志的切分方式——把每一天的日志归档到一个文件中，<code>&lt;maxHistory&gt;30&lt;/maxHistory&gt;</code>表示只保留最近30天的日志，以防止日志填满整个磁盘空间。同理，可以使用<code>%d{yyyy-MM-dd_HH-mm}</code>来定义精确到分的日志切分方式。<code>&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;</code>用来指定日志文件的上限大小，例如设置为1GB的话，那么到了这个值，就会删除旧的日志。</p>
<p>补:如果你想把日志直接放到当前项目下，把<code>${log.path}/</code>去掉即可。</p>
<p>logback 每天生成和大小生成冲突的问题可以看这个解答：<a href="http://blog.csdn.net/wujianmin577/article/details/68922545" target="_blank" rel="noopener">传送门</a> </p>
<h2 id="多环境日志输出"><a href="#多环境日志输出" class="headerlink" title="多环境日志输出"></a>多环境日志输出</h2><p>据不同环境（prod:生产环境，test:测试环境，dev:开发环境）来定义不同的日志输出，在 logback-spring.xml中使用 springProfile 节点来定义，方法如下：</p>
<blockquote>
<p>文件名称不是logback.xml，想使用spring扩展profile支持，要以logback-spring.xml命名</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 测试环境+开发环境. 多个使用逗号隔开. --&gt;</span><br><span class="line">&lt;springProfile name&#x3D;&quot;test,dev&quot;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;com.dudu.controller&quot; level&#x3D;&quot;info&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;springProfile&gt;</span><br><span class="line">&lt;!-- 生产环境. --&gt;</span><br><span class="line">&lt;springProfile name&#x3D;&quot;prod&quot;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;com.dudu.controller&quot; level&#x3D;&quot;ERROR&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;springProfile&gt;</span><br></pre></td></tr></table></figure>

<p>可以启动服务的时候指定 profile （如不指定使用默认），如指定prod 的方式为：</p>
<p><code>java -jar xxx.jar –spring.profiles.active=prod</code></p>
<h2 id="从logback中获取配置文件中的信息"><a href="#从logback中获取配置文件中的信息" class="headerlink" title="从logback中获取配置文件中的信息"></a>从logback中获取配置文件中的信息</h2><p> 配置文件要以logback-spring.xml命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;fluentHost&quot; source&#x3D;&quot;myapp.fluentd.host&quot;</span><br><span class="line">        defaultValue&#x3D;&quot;localhost&quot;&#x2F;&gt;</span><br><span class="line">&lt;appender name&#x3D;&quot;FLUENT&quot; class&#x3D;&quot;ch.qos.logback.more.appenders.DataFluentAppender&quot;&gt;</span><br><span class="line">    &lt;remoteHost&gt;$&#123;fluentHost&#125;&lt;&#x2F;remoteHost&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;&#x2F;appender&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>log</tag>
        <tag>日志</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat日志</title>
    <url>/2020/04/19/Tomcat%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Tomcat日志"><a href="#Tomcat日志" class="headerlink" title="Tomcat日志"></a>Tomcat日志</h1><p>[TOC]</p>
<p>Tomcat 日志信息分为两类：</p>
<ul>
<li>访问日志信息，记录访问的时间,IP,访问的资料等相关信息。</li>
<li>运行中的日志，主要记录运行的一些信息，尤其是一些异常错误日志信息。</li>
</ul>
<h2 id="访问日志："><a href="#访问日志：" class="headerlink" title="访问日志："></a>访问日志：</h2><p>Tomcat访问日志的配置在TOMCAT_HOME/conf/server.xml中（注：注释以下内容即可关闭访问日志）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot;</span><br><span class="line">               prefix&#x3D;&quot;localhost_access_log.&quot; suffix&#x3D;&quot;.txt&quot;</span><br><span class="line">               pattern&#x3D;&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; &#x2F;&gt;123</span><br></pre></td></tr></table></figure>

<p>参数详解：</p>
<p>className：官方说明必须按照默认配置不可更改。<br>directory：日志文件位置。<br>prefix：日志文件前缀。<br>suffix：日志文件后缀。<br>pattern：日志模式参数，设置参数很丰富，参数说明见下表。<br>resolveHosts：如果这个值是true的话，tomcat会将这个服务器IP地址通过DNS转换为主机名，如果是false，就直接写服务器IP地址。</p>
<p>pattern 参数：<br>%a - 远端IP地址<br>%A - 本地IP地址<br>%b - 发送的字节数，不包括HTTP头，如果为0，使用”－”<br>%B - 发送的字节数，不包括HTTP头<br>%h - 远端主机名(如果resolveHost=false，远端的IP地址）<br>%H - 请求协议<br>%l - 从identd返回的远端逻辑用户名（总是返回 ‘-‘）<br>%m - 请求的方法（GET，POST，等）<br>%p - 收到请求的本地端口号<br>%q - 查询字符串(如果存在，以 ‘?’开始)<br>%r - 请求的第一行，包含了请求的方法和URI<br>%s - 响应的状态码<br>%S - 用户的session ID<br>%t - 日志和时间，使用通常的Log格式<br>%u - 认证以后的远端用户（如果存在的话，否则为’-‘）<br>%U - 请求的URI路径<br>%v - 本地服务器的名称<br>%D - 处理请求的时间，以毫秒为单位<br>%T - 处理请求的时间，以秒为单位</p>
<h2 id="运行日志："><a href="#运行日志：" class="headerlink" title="运行日志："></a>运行日志：</h2><ul>
<li><p>运行日志分为5类：catalina 、localhost 、manager 、admin 、host-manager</p>
</li>
<li><p>日志的级别分为7种：SEVERE (highest value) &gt; WARNING &gt; INFO &gt; CONFIG &gt; FINE &gt; FINER &gt; FINEST (lowest value)<br>除此之外，还可以使用OFF关闭相关日志，使用ALL输出所有级别的日志</p>
</li>
<li><p>修改 TOMCAT_HOME/conf/logging.properties 中的内容，设定某类日志的级别</p>
<ul>
<li><p>设置 catalina 日志的级别为： FINE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1catalina.org.apache.juli.FileHandler.level &#x3D; FINE1</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用 catalina 日志的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1catalina.org.apache.juli.FileHandler.level &#x3D; OFF1</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出 catalina 所有的日志消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1catalina.org.apache.juli.FileHandler.level &#x3D; ALL</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/loyachen/article/details/47302143" target="_blank" rel="noopener">https://blog.csdn.net/loyachen/article/details/47302143</a></p>
<h1 id="Linux下Tomcat日志定期清理-其他日志方法相同"><a href="#Linux下Tomcat日志定期清理-其他日志方法相同" class="headerlink" title="Linux下Tomcat日志定期清理(其他日志方法相同)"></a>Linux下Tomcat日志定期清理(其他日志方法相同)</h1><p><a href="https://blog.csdn.net/oSayMissyou0/article/details/70209920" target="_blank" rel="noopener">https://blog.csdn.net/oSayMissyou0/article/details/70209920</a></p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>log</tag>
        <tag>日志</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim命令</title>
    <url>/2020/04/19/Vim%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="Vim命令合集"><a href="#Vim命令合集" class="headerlink" title="Vim命令合集"></a><a href="http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html" target="_blank" rel="noopener">Vim命令合集</a></h2> <a id="more"></a> 

<h1 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h1><p>以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。</p>
<h1 id="启动vim"><a href="#启动vim" class="headerlink" title="启动vim"></a>启动vim</h1><p>在命令行窗口中输入以下命令即可</p>
<p>vim 直接启动vim</p>
<p>vim filename 打开vim并创建名为filename的文件</p>
<h1 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h1><p>打开单个文件</p>
<p>vim file</p>
<p>同时打开多个文件</p>
<p>vim file1 file2 file3 …</p>
<p>在vim窗口中打开一个新文件</p>
<p>:open file</p>
<p>在新窗口中打开文件</p>
<p>:split file</p>
<p>切换到下一个文件</p>
<p>:bn</p>
<p>切换到上一个文件</p>
<p>:bp</p>
<p>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。</p>
<p>:args</p>
<p>打开远程文件，比如ftp或者share folder</p>
<p>:e <a href="ftp://192.168.10.76/abc.txt">ftp://192.168.10.76/abc.txt</a></p>
<p>:e \qadrive\test\1.txt</p>
<h1 id="vim的模式"><a href="#vim的模式" class="headerlink" title="vim的模式"></a>vim的模式</h1><p>正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空<br>插入模式（按i键进入） 左下角显示–INSERT–<br>可视模式（不知道如何进入） 左下角显示–VISUAL–</p>
<h1 id="导航命令"><a href="#导航命令" class="headerlink" title="导航命令"></a>导航命令</h1><p>% 括号匹配</p>
<h1 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h1><p>i 在当前位置生前插入</p>
<p>I 在当前行首插入</p>
<p>a 在当前位置后插入</p>
<p>A 在当前行尾插入</p>
<p>o 在当前行之后插入一行</p>
<p>O 在当前行之前插入一行</p>
<h1 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h1><p>/text　　查找text，按n健查找下一个，按N健查找前一个。</p>
<p>?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。</p>
<p>vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$</p>
<p>:set ignorecase　　忽略大小写的查找</p>
<p>:set noignorecase　　不忽略大小写的查找</p>
<p>查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。</p>
<p>:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。</p>
<p>:set nohlsearch　　关闭高亮搜索显示</p>
<p>:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。</p>
<p>:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。</p>
<p>:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</p>
<h1 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h1><p>ra 将当前字符替换为a，当期字符即光标所在字符。</p>
<p>s/old/new/ 用old替换new，替换当前行的第一个匹配</p>
<p>s/old/new/g 用old替换new，替换当前行的所有匹配</p>
<p>%s/old/new/ 用old替换new，替换所有行的第一个匹配</p>
<p>%s/old/new/g 用old替换new，替换整个文件的所有匹配</p>
<p>:10,20 s/^/    /g 在第10行知第20行每行前面加四个空格，用于缩进。</p>
<p>ddp 交换光标所在行和其下紧邻的一行。</p>
<h1 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h1><p>h 左移一个字符<br>l 右移一个字符，这个命令很少用，一般用w代替。<br>k 上移一个字符<br>j 下移一个字符<br>以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<Esc>，这里的Esc是必须的，否则命令不生效。</p>
<p>w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。</p>
<p>b 向后移动一个单词 2b 向后移动2个单词</p>
<p>e，同w，只不过是光标停在单词尾部</p>
<p>ge，同b，光标停在单词尾部。</p>
<p>^ 移动到本行第一个非空白字符上。</p>
<p>0（数字0）移动到本行第一个字符上，</p>
<p><HOME> 移动到本行第一个字符。同0健。</p>
<p>$ 移动到行尾 3$ 移动到下面3行的行尾</p>
<p>gg 移动到文件头。 = [[</p>
<p>G（shift + g） 移动到文件尾。 = ]]</p>
<p>f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</p>
<p>F 同f，反向查找。</p>
<p>跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。</p>
<p>Ctrl + e 向下滚动一行</p>
<p>Ctrl + y 向上滚动一行</p>
<p>Ctrl + d 向下滚动半屏</p>
<p>Ctrl + u 向上滚动半屏</p>
<p>Ctrl + f 向下滚动一屏</p>
<p>Ctrl + b 向上滚动一屏</p>
<h1 id="撤销和重做"><a href="#撤销和重做" class="headerlink" title="撤销和重做"></a>撤销和重做</h1><p>u 撤销（Undo）<br>U 撤销对整行的操作<br>Ctrl + r 重做（Redo），即撤销的撤销。</p>
<h1 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h1><p>x 删除当前字符</p>
<p>3x 删除当前光标开始向后三个字符</p>
<p>X 删除当前字符的前一个字符。X=dh</p>
<p>dl 删除当前字符， dl=x</p>
<p>dh 删除前一个字符</p>
<p>dd 删除当前行</p>
<p>dj 删除上一行</p>
<p>dk 删除下一行</p>
<p>10d 删除当前行开始的10行。</p>
<p>D 删除当前字符至行尾。D=d$</p>
<p>d$ 删除当前字符之后的所有字符（本行）</p>
<p>kdgg 删除当前行之前所有行（不包括当前行）</p>
<p>jdG（jd shift + g）   删除当前行之后所有行（不包括当前行）</p>
<p>:1,10d 删除1-10行</p>
<p>:11,$d 删除11行及以后所有的行</p>
<p>:1,$d 删除所有行</p>
<p>J(shift + j)　　删除两行之间的空行，实际上是合并两行。</p>
<h1 id="拷贝和粘贴"><a href="#拷贝和粘贴" class="headerlink" title="拷贝和粘贴"></a>拷贝和粘贴</h1><p>yy 拷贝当前行</p>
<p>nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</p>
<p>p  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</p>
<p>shift+p 在当前行前粘贴</p>
<p>:1,10 co 20 将1-10行插入到第20行之后。</p>
<p>:1,$ co $ 将整个文件复制一份并添加到文件尾部。</p>
<p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</p>
<p>ddp交换当前行和其下一行</p>
<p>xp交换当前字符和其后一个字符</p>
<h1 id="剪切命令"><a href="#剪切命令" class="headerlink" title="剪切命令"></a>剪切命令</h1><p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切</p>
<p>ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</p>
<p>:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</p>
<p>:1, 10 m 20 将第1-10行移动到第20行之后。</p>
<h1 id="退出命令"><a href="#退出命令" class="headerlink" title="退出命令"></a>退出命令</h1><p>:wq 保存并退出</p>
<p>ZZ 保存并退出</p>
<p>:q! 强制退出并忽略所有更改</p>
<p>:e! 放弃所有修改，并打开原来文件。</p>
<h1 id="窗口命令"><a href="#窗口命令" class="headerlink" title="窗口命令"></a>窗口命令</h1><p>:split或new 打开一个新窗口，光标停在顶层的窗口上</p>
<p>:split file或:new file 用新窗口打开文件</p>
<p>split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。</p>
<p>Ctrl+ww 移动到下一个窗口</p>
<p>Ctrl+wj 移动到下方的窗口</p>
<p>Ctrl+wk 移动到上方的窗口</p>
<p>关闭窗口</p>
<p>:close 最后一个窗口不能使用此命令，可以防止意外退出vim。</p>
<p>:q 如果是最后一个被关闭的窗口，那么将退出vim。</p>
<p>ZZ 保存并退出。</p>
<p>关闭所有窗口，只保留当前窗口</p>
<p>:only</p>
<p>录制宏</p>
<p>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</p>
<h1 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h1><p>:!command</p>
<p>:!ls 列出当前目录下文件</p>
<p>:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。</p>
<p>:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。</p>
<p>:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</p>
<h1 id="注释命令"><a href="#注释命令" class="headerlink" title="注释命令"></a>注释命令</h1><p>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#</p>
<p>3,5 s/^/#/g 注释第3-5行</p>
<p>3,5 s/^#//g 解除3-5行的注释</p>
<p>1,$ s/^/#/g 注释整个文档。</p>
<p>:%s/^/#/g 注释整个文档，此法更快。</p>
<h1 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h1><p>:help or F1 显示整个帮助<br>:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。<br>:help ‘number’ Vim选项的帮助用单引号括起<br>:help <Esc> 特殊键的帮助用&lt;&gt;扩起<br>:help -t Vim启动参数的帮助用-<br>：help i_<Esc> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式<br>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</p>
<h1 id="其他非编辑命令"><a href="#其他非编辑命令" class="headerlink" title="其他非编辑命令"></a>其他非编辑命令</h1><p>. 重复前一次命令</p>
<p>:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看</p>
<p>:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。</p>
<p>:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。</p>
<p>Vim教程<br>在Unix系统上<br>$ vimtutor<br>在Windows系统上<br>:help tutor<br>:syntax 列出已经定义的语法项<br>:syntax clear 清除已定义的语法规则<br>:syntax case match 大小写敏感，int和Int将视为不同的语法元素<br>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Yarn压测系统</title>
    <url>/2020/04/20/Yarn%E5%8E%8B%E6%B5%8B%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="Yarn压测系统"><a href="#Yarn压测系统" class="headerlink" title="Yarn压测系统"></a>Yarn压测系统</h1><p>背景： 为了验证在Hadoop集群扩容后（5k-10k-15k），保证性能的稳定性，设计该压测系统。 </p>
<p>验证的主要方向是NM的心跳机制对Container调度速率的影响；集群扩容后，放大现网的实际任务规模，验证调度速率。</p>
<h2 id="设计模拟集群"><a href="#设计模拟集群" class="headerlink" title="设计模拟集群"></a>设计模拟集群</h2><h2 id="性能采集与可视化"><a href="#性能采集与可视化" class="headerlink" title="性能采集与可视化"></a>性能采集与可视化</h2><p>采集：基于Yarn JMX Restful接口采集数据，每隔10s采集一次，存储到InfluxDB。 </p>
<p>可视化：基于Grafana定制图表，主要分为4块Dashboard</p>
<ol>
<li>RM性能指标（包括调度速率、APP提交速率、RM内存和GC、集群队列的资源、Apps、Container数量）</li>
<li>调度器指标：包括调度速率、调度步骤长度、每次调度跳过的节点数等</li>
<li>EventMetric： RM的AsyncDispatcher处理的事件数量</li>
<li>队列状态表格：从root队列开始，列出所有子队列的资源状态和AppsPending数量，直观判断是否资源不足引起的调度阻塞，支持递归对子队列钻取</li>
</ol>
<h2 id="设计负载工具"><a href="#设计负载工具" class="headerlink" title="设计负载工具"></a>设计负载工具</h2><p>负载工具目前共有4种：</p>
<ol>
<li>基于概率统计的负载工具：支持从现网的jhist分析作业的时间长度、个数的随机范围，并生成一系列的模拟任务提交到Yarn集群</li>
<li>基于现网负载回放：将现网的jhist分析后，获得作业的执行时间和作业长度、作业的task的平均时间，提交模拟任务</li>
<li>基于现网负载回放（MR版本）：同上面一样，获得task信息后，创建向Yarn提交MR模型版本的模拟作业</li>
<li>指定container速率压测的负载工具：为了达到指定的ContainerAllocationRateAvgTime，不断的向集群提交作业，并且具有启发式的修改作业提交的规模和时间长度</li>
</ol>
<h3 id="基于现网负载回放"><a href="#基于现网负载回放" class="headerlink" title="基于现网负载回放"></a>基于现网负载回放</h3><p>优化步骤：</p>
<ol>
<li>NM本地预存模拟作业的jar包，消除HDFS读取步骤</li>
<li>对现网作业分析后，支持每个模拟Container执行该现网作业Container的平均时间，或者将Container的运行时间分成2组，同时执行长作业Container和短作业Container</li>
<li>jhist中TaskAttempt的时间长度是资源的实际使用时间，而Task的时间长度包含了更多其他的时间</li>
<li>自定义SleepContainerExecutor，通过NM执行sleep线程来模拟作业对资源的占用</li>
<li>模拟作业的AM注销时，从NMClient中直接移除关闭的Container，而不是等待与RM通信关闭Container</li>
</ol>
<h3 id="指定container速率压测的负载工具"><a href="#指定container速率压测的负载工具" class="headerlink" title="指定container速率压测的负载工具"></a>指定container速率压测的负载工具</h3><p>优化步骤： </p>
<ol>
<li>读取JMX指标时，创建JVM缓存</li>
<li>每个客户端创建RateLimiter限制提交速度</li>
<li>在客户端刚启动时，delay一段时间，预提交一些作业，防止调度速率太低引起的大量作业提交</li>
<li>在调度速率过低时，如果有空闲队列，则调大作业的Container数量，如果没有空闲队列，则调小Container的资源使用量和运行时间</li>
</ol>
]]></content>
      <categories>
        <category>Yarn</category>
      </categories>
  </entry>
  <entry>
    <title>Flume</title>
    <url>/2020/04/19/flume/</url>
    <content><![CDATA[<h1 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h1><p>[TOC]</p>
<h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>flume是一个实时数据收集工具，hadoop的生态圈之一，主要用来在分布式环境下各服务器节点做数据收集，然后汇总到统一的数据存储平台，flume支持多种部署架构模式，单点agent部署，分层架构模式部署，如通过一个负载均衡agent将收集的数据分发到各个子agent，然后在汇总到同一个agent上，数据传输到统一的数据存储平台</p>
<p><img src="https://tvax2.sinaimg.cn/large/007S2YVMgy1gdzj3sal7hj30co05bt8u.jpg" alt="image"></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>Flume的管道是基于事务，保证了数据在传送和接收时的一致性.</li>
<li>Flume是可靠的，容错性高的，可升级的，易管理的,并且可定制的。</li>
<li>扇入扇出，一个channel支持多个source和sink，可以实时将数据流向分析工具</li>
<li>多种input和output类型支持</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>Flume的配置很繁琐，source，channel，sink的关系在配置文件里面交织在一起，不便于管理</p>
<p>弱的分区和拦截器功能</p>
<p>Java开发，受限JVM的性能。</p>
<h2 id="类似框架"><a href="#类似框架" class="headerlink" title="类似框架"></a>类似框架</h2><p>Facebook的Scribe，还有Apache新出的另一个明星项目chukwa，还有淘宝Time Tunnel</p>
<h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a><a href="https://www.elastic.co/products/logstash" target="_blank" rel="noopener">Logstash</a></h3><p><img src="https://tvax2.sinaimg.cn/large/007S2YVMgy1gdzj529p7fj30j30cnq3u.jpg" alt="img"></p>
<p><strong>主要特征：</strong></p>
<ul>
<li>从各种来源中提取数据：日志，指标，Web应用程序，数据存储，AWS，而不会失去并发性。</li>
<li>实时数据解析。</li>
<li>从非结构化数据创建结构。</li>
<li>用于数据安全的流水线加密。</li>
<li>logstash基于JVM，支持跨平台；</li>
</ul>
<p><strong>成本：</strong>开源</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>多插件input和output</li>
<li>Logstash可以和ELK其他组件配合，开发、应用都会简单很多，技术成熟，使用场景广泛</li>
<li>采集过程中，提供Filter负责对采集的日志进行分析和重写</li>
<li>SNMP支持</li>
<li>output支持zabbix</li>
</ol>
<p>缺点：</p>
<p>如果做日志过滤和分析，需要学习grok正则，Grok内置了120多种的正则表达式库，地址:<a href="https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns" target="_blank" rel="noopener">https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns</a>。</p>
<h3 id="Fluentd"><a href="#Fluentd" class="headerlink" title="Fluentd"></a><a href="http://www.fluentd.org/" target="_blank" rel="noopener">Fluentd</a></h3><p>Fluentd的旗舰功能是一个广泛的插件库，它在简洁的开发环境中提供与日志和数据管理相关的任何扩展支持和功能。</p>
<p><strong>主要特征：</strong></p>
<ul>
<li>统一日志记录层，可以将数据从多个来源中分离出来。</li>
<li>给非结构化日志提供结构。</li>
<li>灵活，但很简单。需要几分钟才能完成。</li>
<li>与大多数现代数据源兼容。</li>
<li>支持SNMP</li>
<li>input，和output支持zabbix</li>
</ul>
<p><strong>成本：</strong></p>
<ul>
<li>免费：开源</li>
</ul>
<p><strong>基本：</strong></p>
<p>Fluentd使用C/Ruby开发，使用JSON文件来统一日志数据。</p>
<p>Fluentd的部署和Flume非常相似：</p>
<p><img src="https://tva4.sinaimg.cn/large/007S2YVMgy1gdzj5jmvqaj30hs0kh7gx.jpg" alt="img"></p>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><p>采用JSON统一数据/日志格式是它的另一个特点。相对去Flumed，配置也相对简单一些</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>ruby开发，如果自定义插件需要学习成本</p>
<h3 id="Scribe"><a href="#Scribe" class="headerlink" title="Scribe"></a>Scribe</h3><p>**Facebook已停止维护。</p>
<h3 id="chukwa"><a href="#chukwa" class="headerlink" title="chukwa"></a>chukwa</h3><p>版本低，活跃度低</p>
<h3 id="TimeTunnel"><a href="#TimeTunnel" class="headerlink" title="TimeTunnel"></a>TimeTunnel</h3><p>文档已死</p>
]]></content>
      <categories>
        <category>日志采集</category>
      </categories>
      <tags>
        <tag>日志采集</tag>
        <tag>Flume</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中的并发</title>
    <url>/2020/04/19/java-concurrency/</url>
    <content><![CDATA[<h2 id="如何创建一个线程"><a href="#如何创建一个线程" class="headerlink" title="如何创建一个线程"></a>如何创建一个线程</h2><p>按 Java 语言规范中的说法，创建线程只有一种方式，就是创建一个 Thread 对象。而从 HotSpot 虚拟机的角度看，创建一个虚拟机线程<br>有两种方式，一种是创建 Thread 对象，另一种是创建 一个本地线程，加入到虚拟机线程中。</p>
<p>如果从 Java 语法的角度。有两种方法。</p>
<p>第一是继承 Thread 类，实现 run 方法，并创建子类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startThreadUseSubClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"start thread using Subclass of Thread"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">	thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种是传递给 Thread 构造函数一个 Runnable 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startThreadUseRunnalbe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"start thread using runnable"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然， Runnalbe 对象，也不是只有这一种形式，例如如果我们想要线程执行时返回一个值，就需要用到另一种 Runnalbe 对象，它<br>对原来的 Runnalbe 对象进行了包装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startFutureTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> Thread(task).start();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Integer result = task.get();</span><br><span class="line">		System.out.println(<span class="string">"future result "</span> + result);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结束线程"><a href="#结束线程" class="headerlink" title="结束线程"></a>结束线程</h2><h3 id="wait-与-sleep"><a href="#wait-与-sleep" class="headerlink" title="wait 与 sleep"></a>wait 与 sleep</h3><p>sleep 会使得当前线程休眠一段时间，但并不会释放已经得到的锁。</p>
<p>wait 会阻塞住，并释放已经得到的锁。一直到有人调用 notify 或者 notifyAll，它会重新尝试得到锁，然后再唤醒。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>复用</li>
</ul>
<p>线程池中有一系列线程，这些线程在执行完任务后，并不会被销毁，而会从任务队列中取出任务，执行这些任务。这样，就避免为每个任务<br>都创建线程，销毁线程。 在有大量短命线程的场景下，如果创建线程和销毁线程的时间比线程执行任务的时间还长，显然是不划算的，这时候，使用线程池就会有明显<br>的好处。</p>
<ul>
<li>流控</li>
</ul>
<p>同时，可以设置线程数目，这样，线程不会增大到影响系统整体性能的程度。当任务太多时，可以在队列中排队，<br>如果有空闲线程，他们会从队列中取出任务执行。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>线程数目</li>
</ul>
<p>那么，线程的数目要设置成多少呢？这需要根据任务类型的不同来设置，假如是大量计算型的任务，他们不会阻塞，那么可以将线程数目设置<br>为处理器数目。而如果任务中涉及大量IO，有些线程会阻塞住，这样就要根据阻塞线程数目与运行线程数目的比例，以及处理器数目来设置<br>线程总数目。例如阻塞线程数目与运行线程数目之比为n, 处理器数目为p，那么可以设置 n * (p + 1) 个线程，保证有 n 个线程处于运行<br>状态。</p>
<ul>
<li>Executors</li>
</ul>
<p>JDK 的 java.util.concurrent.Executors 类提供了几个静态的方法，用于创建不同类型的线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">ArrayList&lt;Future&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">	Future&lt;Integer&gt; r = service.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">	&#125;);</span><br><span class="line">	results.add(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newFixedThreadPool</code> 可以创建固定数目的线程，一旦创建不会自动销毁线程，即便长期没有任务。除非显式关闭线程池。如果任务队列中有任务，就取出任务执行。</p>
<p>另外，还可以使用 <code>newCachedThreadPool</code> 方法创建一个不设定固定线程数目的线程池，它有一个特性，线程完成任务后，如果一分钟之内又有新任务，就会复用这个线程执行新任务。如果超过一分钟还没有任务执行，就会自动销毁。</p>
<p>另外，还提供了 <code>newSingleThreadExecutor</code> 创建有一个工作线程的线程池。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>JDK 中的线程池通过 HashSet 存储工作者线程，通过 BlockingQueue 来存储待处理任务。</p>
<p>通过核心工作者数目(corePoolSize) 和 最大工作者数目(maximumPoolSize) 来确定如何处理任务。如果当前工作者线程数目<br>小于核心工作者数目，则创建一个工作者线程执行这个任务。否则，将这个任务放入待处理队列。如果入队失败，再看看当前工作<br>者数目是不是小于最大工作者数目，如果小于，则创建工作者线程执行这个任务。否则，拒绝执行这个任务。</p>
<p>另外，如果待处理队列中没有任务要处理，并且工作者线程数目超过了核心工作者数目，那么，需要减少工作者线程数目。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>优先于log4j进行logback的原因</title>
    <url>/2020/04/19/logback%E4%B8%8Elog4j/</url>
    <content><![CDATA[<h2 id="优先于log4j进行logback的原因"><a href="#优先于log4j进行logback的原因" class="headerlink" title="优先于log4j进行logback的原因"></a>优先于log4j进行logback的原因</h2><p>Logback对log4j进行了大量改进，无论大小。 它们太多了，无法详尽地列举。 然而，这里是从log4j切换到logback的原因的非详尽列表。 请记住，<strong>logback在概念上与log4j非常相似</strong>，因为两个项目都是由同一个开发人员创建的。 如果您已熟悉log4j，您将很快感到宾至如归。 如果你喜欢log4j，你可能会喜欢logback。</p>
<h3 id="更快的实施"><a href="#更快的实施" class="headerlink" title="更快的实施"></a>更快的实施</h3><p>基于我们之前关于log4j的工作，已经重写了logback内部，以便在某些关键执行路径上执行大约十倍的速度。 不仅logback组件更快，而且内存占用更少。</p>
<h3 id="大量的测试"><a href="#大量的测试" class="headerlink" title="大量的测试"></a>大量的测试</h3><p>Logback包含了在几年和无数小时工作中开发的大量测试。 虽然log4j也经过测试，但logback将测试带到了完全不同的水平。 在我们看来，这是优先于log4j进行logback的最重要原因。 您希望您的日志框架即使在不利条件下也能够坚如磐石且可靠。</p>
<h3 id="logback-classic本身就说SLF4J"><a href="#logback-classic本身就说SLF4J" class="headerlink" title="logback-classic本身就说SLF4J"></a>logback-classic本身就说SLF4J</h3><p>由于logback-classic中的<code>Logger</code>类本身实现了SLF4J API，因此在调用带有logback-classic作为底层实现的SLF4J记录器时，会产生零开销。 此外，由于logback-classic强烈鼓励使用SLF4J作为其客户端API，如果需要切换到log4j或jul，可以通过将一个jar文件替换为另一个来实现。 您无需通过SLF4J API触摸代码记录。 这可以大大减少切换日志框架所涉及的工作。</p>
<h3 id="广泛的文档"><a href="#广泛的文档" class="headerlink" title="广泛的文档"></a>广泛的文档</h3><p>Logback随附详细且不断更新的文档。</p>
<h3 id="XML或Groovy中的配置文件"><a href="#XML或Groovy中的配置文件" class="headerlink" title="XML或Groovy中的配置文件"></a>XML或Groovy中的配置文件</h3><p>配置logback的传统方法是通过XML文件。 文档中的大多数示例都使用此XML语法。 但是，从logback版本0.9.22开始，也支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://logback.qos.ch/manual/groovy.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhhBWBsoeVYtx0g7jfK3fKP6d6GtYw" target="_blank" rel="noopener">用Groovy编写的配置文件</a> 。 与XML相比，Groovy风格的配置更直观，更一致，并且语法更短。</p>
<p>还有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=http://logback.qos.ch/translator/asGroovy.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhidtWK-Nyj80UQRSXcZmCWOCnUWNQ" target="_blank" rel="noopener">工具可以自动将logback.xml文件迁移到logback.groovy</a> 。</p>
<h3 id="自动重新加载配置文件"><a href="#自动重新加载配置文件" class="headerlink" title="自动重新加载配置文件"></a>自动重新加载配置文件</h3><p>Logback-classic可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://logback.qos.ch/manual/configuration.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhgRA0DKswZ_dsz-GTjGf9lqf_6q1g#autoScan" target="_blank" rel="noopener">在修改后自动重新加载其配置文件</a> 。 扫描过程快速，无争用，并且动态扩展到数百个线程上每秒数百万次调用。 它在应用程序服务器中也能很好地运行，更常见的是在JEE环境中，因为它不涉及创建单独的扫描线程。</p>
<h3 id="从I-O故障中顺利恢复"><a href="#从I-O故障中顺利恢复" class="headerlink" title="从I / O故障中顺利恢复"></a>从I / O故障中顺利恢复</h3><p>Logback的<code>FileAppender</code>及其所有子类（包括<code>RollingFileAppender</code> ）可以从I / O故障中正常恢复。 因此，如果文件服务器暂时失败，则不再需要重新启动应用程序以使日志记录再次运行。 一旦文件服务器恢复，相关的logback appender将从之前的错误状态透明地快速恢复。</p>
<h3 id="自动删除旧的日志存档"><a href="#自动删除旧的日志存档" class="headerlink" title="自动删除旧的日志存档"></a>自动删除旧的日志存档</h3><p>通过设置<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://logback.qos.ch/manual/appenders.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhjeKCV5-S5P_a0hUMWGkus6yEudeA#TimeBasedRollingPolicy" target="_blank" rel="noopener">TimeBasedRollingPolicy</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://logback.qos.ch/manual/appenders.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhjeKCV5-S5P_a0hUMWGkus6yEudeA#SizeAndTimeBasedFNATP" target="_blank" rel="noopener">SizeAndTimeBasedFNATP</a>的maxHistory属性，可以控制最大归档文件数。 如果您的滚动策略要求每月滚动并且您希望保留一年的日志，只需将maxHistory属性设置为12.将自动删除超过12个月的存档日志文件。</p>
<h3 id="自动压缩存档的日志文件"><a href="#自动压缩存档的日志文件" class="headerlink" title="自动压缩存档的日志文件"></a>自动压缩存档的日志文件</h3><p><a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://logback.qos.ch/manual/appenders.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhjeKCV5-S5P_a0hUMWGkus6yEudeA#RollingFileAppender" target="_blank" rel="noopener">RollingFileAppender</a>可以在翻转期间自动压缩归档日志文件。 压缩始终以异步方式发生，因此即使对于大型日志文件，也不会在压缩期间阻止应用程序。</p>
<h3 id="谨慎的模式"><a href="#谨慎的模式" class="headerlink" title="谨慎的模式"></a>谨慎的模式</h3><p>在<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://logback.qos.ch/manual/appenders.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhjeKCV5-S5P_a0hUMWGkus6yEudeA#prudent" target="_blank" rel="noopener">谨慎模式下</a> ，在多个JVM上运行的多个<code>FileAppender</code>实例可以安全地写入同一个日志文件。 由于某些限制，谨慎模式扩展到<code>RollingFileAppender</code> 。</p>
<h3 id="莉莉丝"><a href="#莉莉丝" class="headerlink" title="莉莉丝"></a>莉莉丝</h3><p><a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=http://lilith.huxhorn.de/&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhjVyV4il5u8LBsQiPvWATidvYsK4w" target="_blank" rel="noopener">Lilith</a>是一个用于logback的日志记录和访问事件查看器。 它与log4j的电锯相当，只不过Lilith设计用于处理大量的测井数据而不会退缩。</p>
<h3 id="条件处理配置文件"><a href="#条件处理配置文件" class="headerlink" title="条件处理配置文件"></a>条件处理配置文件</h3><p>开发人员经常需要在针对不同环境（如开发，测试和生产）的多个logback配置文件之间进行操作。 这些配置文件有很多共同之处，仅在少数几个地方有所不同。 为了避免重复，logback支持在<code>&lt;if&gt;</code> ， <code>&lt;then&gt;</code>和<code>&lt;else&gt;</code>元素的帮助<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://logback.qos.ch/manual/configuration.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhgRA0DKswZ_dsz-GTjGf9lqf_6q1g#conditional" target="_blank" rel="noopener">下对配置文件</a>进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://logback.qos.ch/manual/configuration.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhgRA0DKswZ_dsz-GTjGf9lqf_6q1g#conditional" target="_blank" rel="noopener">条件处理，</a>以便单个配置文件可以充分地针对多个环境。</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Logback提供了大量的<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://logback.qos.ch/manual/filters.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhjXLXyblQW4EUGOh2SEJYGGva8UpQ" target="_blank" rel="noopener">过滤功能</a> ，远远超出了log4j所提供的功能。 例如，假设您在生产服务器上部署了业务关键型应用程序。 在处理大量事务的情况下，将日志记录级别设置为WARN，以便仅记录警告和错误。 现在想象一下，您遇到了一个可以在生产系统上重现的错误，但由于这两个环境（生产/测试）之间存在未指定的差异，因此在测试平台上仍然难以捉摸。</p>
<p>使用log4j，您唯一的选择是将生产系统上的日志记录级别降低到DEBUG以尝试识别问题。 不幸的是，这将产生大量的记录数据，使分析变得困难。 更重要的是，广泛的日志记录会影响应用程序在生产系统上的性能。</p>
<p>使用logback，您可以选择将所有用户的日志记录保持在WARN级别，除了负责识别问题的一个用户Alice。 当Alice登录时，她将以DEBUG级别登录，而其他用户可以继续登录WARN级别。 这个专长可以通过在配置文件中添加4行XML来实现。 在本手册的<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://logback.qos.ch/manual/filters.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhjXLXyblQW4EUGOh2SEJYGGva8UpQ#TurboFilter" target="_blank" rel="noopener">相关部分</a>中搜索<code>MDCFilter</code> 。</p>
<h3 id="SiftingAppender"><a href="#SiftingAppender" class="headerlink" title="SiftingAppender"></a>SiftingAppender</h3><p><a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://logback.qos.ch/manual/appenders.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhjeKCV5-S5P_a0hUMWGkus6yEudeA#SiftingAppender" target="_blank" rel="noopener">SiftingAppender</a>是一个非常多才多艺的appender。 它可用于根据<strong>任何</strong>给定的运行时属性分离（或筛选）日志记录。 例如， <code>SiftingAppender</code>可以根据用户会话分离日志记录事件，以便每个用户生成的日志进入不同的日志文件，每个用户一个日志文件。</p>
<h3 id="堆栈跟踪包装数据"><a href="#堆栈跟踪包装数据" class="headerlink" title="堆栈跟踪包装数据"></a>堆栈跟踪包装数据</h3><p>当logback打印异常时，堆栈跟踪将包含打包数据。 以下是<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://logback.qos.ch/demo.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhgu7r6nIUu77LTwIf20ZZjzjfiFWA" target="_blank" rel="noopener">logback-demo</a> Web应用程序生成的示例堆栈跟踪。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14:28:48.835 [btpool0-7] INFO  c.q.l.demo.prime.PrimeAction - 99 is not a valid value</span><br><span class="line">java.lang.Exception: 99 is invalid</span><br><span class="line">  at ch.qos.logback.demo.prime.PrimeAction.execute(PrimeAction.java:28) [classes&#x2F;:na]</span><br><span class="line">  at org.apache.struts.action.RequestProcessor.processActionPerform(RequestProcessor.java:431) [struts-1.2.9.jar:1.2.9]</span><br><span class="line">  at org.apache.struts.action.RequestProcessor.process(RequestProcessor.java:236) [struts-1.2.9.jar:1.2.9]</span><br><span class="line">  at org.apache.struts.action.ActionServlet.doPost(ActionServlet.java:432) [struts-1.2.9.jar:1.2.9]</span><br><span class="line">  at javax.servlet.http.HttpServlet.service(HttpServlet.java:820) [servlet-api-2.5-6.1.12.jar:6.1.12]</span><br><span class="line">  at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:502) [jetty-6.1.12.jar:6.1.12]</span><br><span class="line">  at ch.qos.logback.demo.UserServletFilter.doFilter(UserServletFilter.java:44) [classes&#x2F;:na]</span><br><span class="line">  at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1115) [jetty-6.1.12.jar:6.1.12]</span><br><span class="line">  at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:361) [jetty-6.1.12.jar:6.1.12]</span><br><span class="line">  at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:417) [jetty-6.1.12.jar:6.1.12]</span><br><span class="line">  at org.mortbay.jetty.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:230) [jetty-6.1.12.jar:6.1.12]</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，应用程序正在使用Struts 1.2.9版，并在jetty版本6.1.12下部署。 因此，堆栈跟踪将快速告知读者介入异常的类以及它们所属的包和包版本。 当您的客户向您发送堆栈跟踪时，作为开发人员，您将不再需要让他们向您发送有关他们正在使用的软件包版本的信息。 该信息将成为堆栈跟踪的一部分。 有关详细信息，请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://logback.qos.ch/manual/layouts.html&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhjkuT4YZQccDzgjVm9Kjb6H7iZ0Gg#xThrowable" target="_blank" rel="noopener">“％xThrowable”转换字</a> 。</p>
<p>对于某些用户错误地认为它是<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=http://www.jetbrains.net/devnet/message/5259058&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhjwlFSVrE_jL1Ln-DJY7gYOFyHG3A" target="_blank" rel="noopener">IDE的</a>一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=http://www.jetbrains.net/devnet/message/5259058&xid=17259,1500004,15700021,15700124,15700149,15700168,15700186,15700190,15700201,15700208&usg=ALkJrhjwlFSVrE_jL1Ln-DJY7gYOFyHG3A" target="_blank" rel="noopener">功能，</a>这个功能非常有用。</p>
<h3 id="Logback-access，即带有大脑的HTTP访问日志记录，是logback的一个组成部分"><a href="#Logback-access，即带有大脑的HTTP访问日志记录，是logback的一个组成部分" class="headerlink" title="Logback-access，即带有大脑的HTTP访问日志记录，是logback的一个组成部分"></a>Logback-access，即带有大脑的HTTP访问日志记录，是logback的一个组成部分</h3><p>最后但并非最不重要的是，logback-access模块是logback发行版的一部分，它与Servlet容器（如Jetty或Tomcat）集成，以提供丰富而强大的HTTP访问日志功能。 由于logback-access是初始设计的一部分，因此您喜欢的所有logback-classic功能也可用于logback-access。</p>
<h3 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h3><p>我们列出了一些优先考虑log4j的logback的原因。 鉴于logback建立在我们之前关于log4j的工作上，简单地说，logback只是一个更好的log4j。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>log</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法代码总结</title>
    <url>/2020/04/19/java-sort/</url>
    <content><![CDATA[<h2 id="排序算法代码总结"><a href="#排序算法代码总结" class="headerlink" title="排序算法代码总结"></a>排序算法代码总结</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 原理：</span></span><br><span class="line"><span class="comment"> * 每一轮循环中依次比较相邻位置上元素的大小，使得较大的元素后移，</span></span><br><span class="line"><span class="comment"> * 且确保第i轮循环完之后能把第i大的元素移动到排序后的位置上</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 改进：</span></span><br><span class="line"><span class="comment"> * 每一轮循环开始前设置标志位，如果本轮循环没有交换任何元素，</span></span><br><span class="line"><span class="comment"> * 则说明所有元素已经有序，可以提前结束排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Roamer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;<span class="comment">//每一轮冒泡之前重置标志位</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(a, j, j+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 原理：</span></span><br><span class="line"><span class="comment"> * 从数组的首元素开始，将第i个元素之后的所有元素通过相互比较找到最小值的索引，</span></span><br><span class="line"><span class="comment"> * 如果当前元素比这个最小元素大，则交换之，使得第i个位置的元素值为第i小，</span></span><br><span class="line"><span class="comment"> * 相当于每一轮循环是在所有未排序的元素之中选择出最小的元素。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Roamer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//找到第i个元素之后的最小元素的下标minIdx</span></span><br><span class="line">		<span class="keyword">int</span> minIdx = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; a.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[minIdx])</span><br><span class="line">                minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前元素比其后的最小元素还小，则交换之</span></span><br><span class="line">		<span class="keyword">if</span>(a[i] &gt; a[minIdx])</span><br><span class="line">            swap(a, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 原理：</span></span><br><span class="line"><span class="comment"> * 确保数组前i-1个元素已经排好序，在第i轮循环时，将第i个元素从后往前依次和</span></span><br><span class="line"><span class="comment"> * 其前面的元素比较和交换，最后插入到前i-1个有序的子数组中的合适位置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Roamer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从数组第二个元素开始进行前插for(int i = 1; i &lt; a.length; ++i) &#123;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; a[j-<span class="number">1</span>] &gt; a[j]; --j)</span><br><span class="line">                swap(a, j-<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 原理：</span></span><br><span class="line"><span class="comment"> * 将数组的首元素作为比较的基准，用两个指针从数组的两端往中间扫描，</span></span><br><span class="line"><span class="comment"> * 当左指针对应的元素大于基准值且右指针对应的元素小于基准值，则交换两者对应的元素值，</span></span><br><span class="line"><span class="comment"> * 使得每一轮遍历之后数组分成比基准值更大和更小的两部分，</span></span><br><span class="line"><span class="comment"> * 再把基准元素从数组首位交换到数组的中间，从而其左边的元素都不大于它，</span></span><br><span class="line"><span class="comment"> * 且其右边的元素都不小于它，然后将左右两个子数组递归调用快排函数，最终使数组有序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Roamer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;  </span><br><span class="line">        <span class="keyword">int</span> pivot = partition(a, low, high);</span><br><span class="line">        quickSort(a, low, pivot - <span class="number">1</span>);  </span><br><span class="line">        quickSort(a, pivot + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一：两个指针互相交换不合格元素（交换之后就都合格了），最后将基准元素移动到中间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将数组首元素作为每一轮比较的基准int pivot = low;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="comment">//从右往左扫描，直到遇到比基准元素小的元素</span></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt;= a[pivot])</span><br><span class="line">            --high;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左往右扫描，直到遇到比基准元素大的元素</span></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= a[pivot])</span><br><span class="line">            ++low;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将左子数组中不合格的元素与右子数组中不合格的元素交换</span></span><br><span class="line">        swap(a, low, high); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数组首元素交换到中间位置</span></span><br><span class="line">    swap(a, pivot, low);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回数组的中轴位置</span></span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一的改进版：//由于基准元素已经保存了，所以其位置可以被覆盖掉，且两个指针是交替扫描的，</span></span><br><span class="line"><span class="comment">//所以右边（左边）的不合格元素可以直接覆盖左边（右边）的不合格元素，</span></span><br><span class="line"><span class="comment">//由于high指针先扫描，然后两个指针的元素交替覆盖对方，所以循环结束后，</span></span><br><span class="line"><span class="comment">//low对应的位置还没有被覆盖，且它就是两个子数组的分界，将基准元素放到此位置即可</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition1</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将数组首元素作为每一轮比较的基准</span></span><br><span class="line"><span class="keyword">int</span> pivotValue = a[low];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="comment">//从右往左扫描，直到遇到比基准元素小的元素</span></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt;= pivotValue)</span><br><span class="line">            --high;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将右子数组中不合格的元素放到左边不合格元素的位置（原元素已经移走）</span></span><br><span class="line">        a[low] = a[high];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左往右扫描，直到遇到比基准元素大的元素</span></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= pivotValue)</span><br><span class="line">            ++low;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将左子数组中不合格的元素放到左边不合格元素的位置（原元素已经移走） </span></span><br><span class="line">        a[high] = a[low];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将基准元素放到中间位置</span></span><br><span class="line">    a[low] = pivotValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回数组的中轴位置return low;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二：保持两个指针中总有一个指向基准元素，所以每次交换都是不合格元素与基准元素做交换，</span></span><br><span class="line"><span class="comment">//当两个指针在数组中间相遇时，low一定指向着基准元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将数组首元素作为每一轮比较的基准int pivotValue = a[low];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="comment">//从右往左扫描，直到遇到比基准元素小的元素</span></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt;= pivotValue)</span><br><span class="line">            --high;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将右子数组中不合格的元素与基准元素交换</span></span><br><span class="line">        swap(a, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左往右扫描，直到遇到比基准元素大的元素</span></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= pivotValue)</span><br><span class="line">            ++low;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将左子数组中不合格的元素与基准元素交换</span></span><br><span class="line">        swap(a, low, high); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回数组的中轴位置，low必定指向了基准元素pivotValue</span></span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序（递归版）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 原理：</span></span><br><span class="line"><span class="comment"> * 将数组均分成两个子数组，先将两个子数组分别进行排序，然后合并得到全体元素都有序的数组，</span></span><br><span class="line"><span class="comment"> * 为使上述的两个子数组分别有序，需要先对其各自的两个子数组进行排序再合并，因此需要递归地</span></span><br><span class="line"><span class="comment"> * 对每个子数组的两个子数组进行归并排序，直到子数组只有2个元素，此时只需要直接进行合并</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Roamer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];<span class="comment">//辅助数组</span></span><br><span class="line">    Merge(a, b, <span class="number">0</span>, a.length-<span class="number">1</span>, (a.length-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对数组a的两个子数组进行归并排序private void Merge(int[] a, int[] b, int low, int high, int pivot) &#123;</span></span><br><span class="line">    <span class="comment">//先递归地划分子数组（子数组最小长度为2），并对子数组进行归并排序if(low &lt; high) &#123;</span></span><br><span class="line">        Merge(a, b, low, pivot, (low+pivot)/<span class="number">2</span>);</span><br><span class="line">        Merge(a, b, pivot+<span class="number">1</span>, high, (high+pivot+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将已经排好序的两个子数组元素依次进行比较再合并int i = low;</span></span><br><span class="line">    <span class="keyword">int</span> j = pivot+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = low;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= pivot &amp;&amp; j &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[j])</span><br><span class="line">            b[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出子数组中可能的剩余元素（每次只可能有一个while执行）while(i &lt;= pivot)  b[k++] = a[i++];</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high)  b[k++] = a[j++];  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将本次排好序的部分元素拷贝回原数组a</span></span><br><span class="line">    System.arraycopy(b, low, a, low, high-low+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序（迭代版）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 原理：</span></span><br><span class="line"><span class="comment"> * 先将整个数组依次划分成若干个长度为2的子数组，对每个子数组中的两个元素进行合并，</span></span><br><span class="line"><span class="comment"> * 再将整个数组依次划分成若干个长度为4的子数组，对每个子数组中的两个子数组进行合并，</span></span><br><span class="line"><span class="comment"> * 如此循环，直到只能将数组划分成两个子数组，这两个子数组已经分别有序，直接合并即可</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Roamer</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//利用分治策略，对数组a的各级子数组进行迭代归并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort2</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];<span class="comment">//辅助数组</span></span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">2</span>;<span class="comment">//每一轮合并中数组的长度</span></span><br><span class="line">	<span class="keyword">while</span>(len &lt;= a.length) &#123;</span><br><span class="line">        <span class="comment">//将前若干组中两个等长的子数组合并</span></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i + len &lt;= a.length) &#123;</span><br><span class="line">            Merge2(a, b, i, i+len-<span class="number">1</span>, i+(len-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">            i += len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若原数组长度不是2的幂，则数组可能不能被均分//从而最后一组的两个子数组长度会不同，单独合并之</span></span><br><span class="line">		<span class="keyword">if</span>(i != a.length)</span><br><span class="line">            Merge2(a, b, i, a.length-<span class="number">1</span>, (i+a.length)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下一轮合并中数组的长度翻倍</span></span><br><span class="line">        len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将本轮分组有序的元素拷贝回原数组a</span></span><br><span class="line">        System.arraycopy(b, <span class="number">0</span>, a, <span class="number">0</span>, a.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若原数组长度不是2的幂，需要最后合并一次！</span></span><br><span class="line">	<span class="keyword">if</span>(len != a.length) &#123;</span><br><span class="line">        Merge2(a, b, <span class="number">0</span>, a.length-<span class="number">1</span>, (len-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        System.arraycopy(b, <span class="number">0</span>, a, <span class="number">0</span>, a.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Merge2</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将已经排好序的两个子数组元素依次进行比较再合并int i = low;</span></span><br><span class="line">    <span class="keyword">int</span> j = pivot+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = low;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= pivot &amp;&amp; j &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[j])</span><br><span class="line">            b[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出子数组中可能的剩余元素（每次只可能有一个while执行）</span></span><br><span class="line"><span class="keyword">while</span>(i &lt;= pivot)  b[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high)  b[k++] = a[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 原理：</span></span><br><span class="line"><span class="comment"> * 先将无序数组构成一个二叉堆（完全二叉树），使得每个节点都小于其子节点（兄弟节点之间可以无序），</span></span><br><span class="line"><span class="comment"> * 每次取出根节点后，重新调整堆使其仍满足上述特性，每次取出的根节点就构成了一个有序数组。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 建堆</span></span><br><span class="line"><span class="comment"> * 用数组来存放整个二叉堆，且数组的首元素中存储着整个二叉堆的节点总个数，</span></span><br><span class="line"><span class="comment"> * 建堆时总是在二叉堆的叶子节点处插入新节点，然后“上浮”该节点，最终在数组中得到一个二叉堆。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 调整堆</span></span><br><span class="line"><span class="comment"> * 每次在叶子节点处插入新节点即在数组末位插入新元素需要调整堆，比较新节点和其父节点的大小，</span></span><br><span class="line"><span class="comment"> * 通过不断交换使其“上浮”，并最终位于二叉树的合适位置；</span></span><br><span class="line"><span class="comment"> * 每次取出二叉堆的根节点即取出数组的第二个元素后需要调整堆，将二叉树的最后一个叶子节点作为新的根节点，</span></span><br><span class="line"><span class="comment"> * 然后依次比较其和子节点的大小，通过不断交换使其“下沉”，并最终位于二叉树的合适位置；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Roamer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length + <span class="number">1</span>];<span class="comment">//二叉堆数组</span></span><br><span class="line">	<span class="comment">//建堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; ++i)</span><br><span class="line">        insert(b, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到有序数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; ++i)</span><br><span class="line">        a[i] = getRoot(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//往二叉堆插入新节点，并调整堆</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] heap, <span class="keyword">int</span> ele)</span> </span>&#123;</span><br><span class="line">    heap[<span class="number">0</span>] += <span class="number">1</span>;<span class="comment">//节点总数加1</span></span><br><span class="line">    heap[heap[<span class="number">0</span>]] = ele;</span><br><span class="line"></span><br><span class="line">    goUp(heap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出二叉堆的根节点，并调整堆private int getRoot(int[] heap) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (heap[<span class="number">0</span>] &lt; <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"二叉堆已经为空，不能再取出元素！"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root = heap[<span class="number">1</span>];<span class="comment">//取出根节点元素</span></span><br><span class="line">    heap[<span class="number">1</span>] = heap[heap[<span class="number">0</span>]];<span class="comment">//将二叉堆的最后一个叶子节点作为新的根节点</span></span><br><span class="line">    heap[<span class="number">0</span>] -= <span class="number">1</span>;<span class="comment">//节点总数减1</span></span><br><span class="line"></span><br><span class="line">    goDown(heap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根节点"下沉"</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">goDown</span><span class="params">(<span class="keyword">int</span>[] heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">1</span>;<span class="comment">//需要下沉的根节点的索引</span></span><br><span class="line">	<span class="keyword">int</span> left, right, minIdx;<span class="comment">//minIdx表示左右子节点中较小的那个</span></span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//是否有元素交换的标志位</span></span><br><span class="line">	<span class="comment">//如果上一轮循环有元素交换则继续交换</span></span><br><span class="line">	<span class="keyword">while</span>(flag) &#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        left = (idx &lt;&lt; <span class="number">1</span>);<span class="comment">//左子节点</span></span><br><span class="line">        right = left + <span class="number">1</span>;<span class="comment">//右子节点if (left &gt; heap[0])//无子节点break; </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; heap[<span class="number">0</span>])<span class="comment">//只有左子节点</span></span><br><span class="line">            minIdx = left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            minIdx = (heap[left] &lt; heap[right]) ? left : right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (heap[idx] &gt; heap[minIdx]) &#123;</span><br><span class="line">            swap(heap, idx, minIdx);</span><br><span class="line">            idx = minIdx;</span><br><span class="line">            flag = <span class="keyword">true</span>;<span class="comment">//本次循环有元素交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//末位叶子节点“上浮”private void goUp(int[] heap) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx = heap[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> parent = (idx &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(parent &gt; <span class="number">0</span> &amp;&amp; heap[idx] &lt; heap[parent]) &#123;</span><br><span class="line">        swap(heap, idx, parent);</span><br><span class="line">        idx  = parent;</span><br><span class="line">        parent = (idx &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序（缩小增量排序）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 原理：</span></span><br><span class="line"><span class="comment"> * 先设置一个较大的步长（增量），将数组分为若干个子序列，对每个子序列分别进行排序，</span></span><br><span class="line"><span class="comment"> * 再减少步长，再次将数组分为若干个更长的子序列，对每个子序列分别进行排序，</span></span><br><span class="line"><span class="comment"> * 如此循环，直到步长为1，即整个数组中只有一个子序列，此时整个数组已经有序</span></span><br><span class="line"><span class="comment"> * 其中，子序列的排序可以采用任何其他排序算法，每一轮排序之后，数组将变得更加有序一些</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Roamer</span></span><br><span class="line"><span class="comment"> */</span><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到初始步长int step = 1;</span></span><br><span class="line">    <span class="keyword">while</span>(step &lt; a.length) </span><br><span class="line">        step = <span class="number">3</span>*step + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(step &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//缩小步长</span></span><br><span class="line">        step = step / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; ++i) &#123;</span><br><span class="line">            <span class="comment">// 得到子序列数组int nsub = (a.length - i - 1) / step + 1;</span></span><br><span class="line">            <span class="keyword">int</span>[] sub = <span class="keyword">new</span> <span class="keyword">int</span>[nsub];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nsub; ++j)</span><br><span class="line">                sub[j] = a[i + j * step];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对子序列数组进行冒泡排序</span></span><br><span class="line">            bubbleSort(sub);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将排序后的元素保存到原数组的对应位置for (int j = 0; j &lt; nsub; j++)</span></span><br><span class="line">                a[i + j * step] = sub[j];</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 原理：</span></span><br><span class="line"><span class="comment"> * 基数排数基于桶排序的思想。如果需要排序的元素是正整数，则可以通过依次比较他们每个数位上</span></span><br><span class="line"><span class="comment"> * 数字的大小进行排序，由于十进制只有10个数码，所以只需要10个“桶”就够了。</span></span><br><span class="line"><span class="comment"> * 基数排序的方式可以采用LSD（Least sgnificant digital）或MSD（Most sgnificant digital），</span></span><br><span class="line"><span class="comment"> * 如果是采用LSD算法，则从个位开始，将所有整数根据个位数字分别放到对应的10个桶中，</span></span><br><span class="line"><span class="comment"> * 再按顺序从各个桶中将所有整数取出依次填回原数组，然后将所有整数根据十位数字重新放到新的10个桶中，</span></span><br><span class="line"><span class="comment"> * 以此类推，直到所有元素的所有数位都遍历完，由于基数排序是稳定的，所以数组中的所有元素最终都有序了</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Roamer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//用于遍历数组的下标指针</span></span><br><span class="line">	<span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//表示当前用于比较的数位，从个位开始</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">1</span>;<span class="comment">//表示数位m对应的权重，即1,10,100,1000...</span></span><br><span class="line">	<span class="comment">//数组的第一维为每个数位上可能出现的数字（0~9），即桶的个数，</span></span><br><span class="line">	<span class="comment">//第二维是包含当前数位的元素可能的总个数，即每个桶中可以放入的整数个数，</span></span><br><span class="line">	<span class="comment">//数组的元素值记录了数位是lsd的整数</span></span><br><span class="line">	<span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][a.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//用于记录每个桶中整数的总个数 </span></span><br><span class="line">	<span class="keyword">while</span>(m &lt;= len) &#123;</span><br><span class="line">        <span class="comment">//入桶，即将数组中的所有整数按照数位m放到对应的桶中</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; ++i) &#123;     </span><br><span class="line">            <span class="keyword">int</span> lsd = (a[i] / n) % <span class="number">10</span>;<span class="comment">//通过取整取余得到数位m上的数字lsd</span></span><br><span class="line">            bucket[lsd][order[lsd]] = a[i];<span class="comment">//记录新出现的数位是lsd的整数</span></span><br><span class="line">            order[lsd]++;<span class="comment">//数位是lsd的整数的个数加1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//出桶，即从10个桶中依次取出整数，填回数组中（即记录当前已排好的相对顺序）</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//如果当前桶不为空</span></span><br><span class="line">			<span class="keyword">if</span>(order[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//依次取出当前桶中的记录的整数（bucket数组第二维中元素必定是连续的）</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; order[i]; j++)</span><br><span class="line">                    a[k++] = bucket[i][j];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//清空对桶中整数个数的记录 </span></span><br><span class="line">                order[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成当前数位上的排序，准备下一轮排序</span></span><br><span class="line">        k = <span class="number">0</span>;<span class="comment">//将数组a的下标重置为0</span></span><br><span class="line">        m++;<span class="comment">//数位往高位增加</span></span><br><span class="line">        n *= <span class="number">10</span>;<span class="comment">//数位对应的权重增加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>如何同步数据</title>
    <url>/2020/04/19/%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="如何同步数据"><a href="#如何同步数据" class="headerlink" title="如何同步数据?"></a>如何同步数据?</h2><p>​    同步两个系统之间的数据一直是开发中的痛点。不论是从数据库到数据库还是从其他子系统到数据库、数据库到其他子系统。考虑到同步的一致性、实时性、原子性经常很难得到保证，所以经常采取很多极端的方法，例如反复定时同步、每次同步先清空目标库中历史数据、或每次同步将目标库的历史数据回写到被同步的系统中等。一旦调节不好，那么整个同步将产生大量的脏数据，甚至导致两个系统都不可用。</p>
<h3 id="1-一次同步，从此禁止访问原数据系统"><a href="#1-一次同步，从此禁止访问原数据系统" class="headerlink" title="1. 一次同步，从此禁止访问原数据系统"></a>1. 一次同步，从此禁止访问原数据系统</h3><p>​    一次同步，从此禁止访问原数据系统。很好理解，通过禁止访问原数据系统，这样再也不会产生需要同步的需求，系统间数据实时性得到保证。当然某种程度上少量使用原数据系统，产生很少的同步需求也是可以的，这样通过手动同步数据的妥协某种程度上也是可以接受的。</p>
<p>​    实际上，数据实时性总是导致一系列问题的根本。没有数据实时性，我们可以对原数据系统与新系统间数据的一致性、原子性更好的把控，例如一旦同步失败，我们可以实现清空同步数据并再次同步，直到成功为止。</p>
<p>​    注意：尽量不去访问原数据系统，尽量减少重命名问题（原数据系统一旦重命名某条数据，新数据系统可能要删除一条记录，然后重新添加新数据）。增强原数据系统与新系统间的数据一致性的比对。</p>
<h3 id="2-定时同步"><a href="#2-定时同步" class="headerlink" title="2. 定时同步"></a>2. 定时同步</h3><p>​    从定时同步开始对数据同步的实时性提出越来越高的要求。</p>
<p>​    实时性越高的数据，读写越容易冲突，定时同步也越容易出错。这里涉及到的情况可以参考分布式数据库的概念，不同机器间的数据库同步、事务很难得到保证，因此出现了分布式事务。但是分布式事务的缺点很明显：性能不理想，一旦网路故障或并发量很高则很难满足情况。类似的定时同步也有同样的问题，一方面，定时同步的间隔和用户读写操作的频率如果不能很好分配，则很大程度上导致同步失败；另一方面，面对同步失败的情况，很难在有效的时间内重新实现同步成功。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title>学习方法</title>
    <url>/2020/04/19/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="如何学习？"><a href="#如何学习？" class="headerlink" title="如何学习？"></a>如何学习？</h1><p>不知道对与不对，先写下我最近的学习方法。</p>
<ol>
<li>以Github为中心学习，Github博客，自己开源的项目，阅读Star项目</li>
<li>坚持而已</li>
</ol>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库约定</title>
    <url>/2020/04/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BA%A6%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="数据库约定"><a href="#数据库约定" class="headerlink" title="数据库约定"></a>数据库约定</h1><ol>
<li>数据库编码、表编码、字段编码一律用<code>utf-8</code>  </li>
<li>数据库名称、表名称、字段名称、视图名称一律用小写字母  </li>
<li>对于true或false的字段，使用<code>bit(1)</code>类型  </li>
<li>对于其他字典类型字段，使用<code>varchar</code>类型  </li>
<li>所有表之间使用弱关联关系，不使用强关联关系。级联删除必须由业务代码去实现  </li>
<li>开发中，复杂查询尽量使用视图，不要构建复杂的SQL语句  </li>
<li>所有表必须有ID字段，定义为主键，不能为空  </li>
<li>常用字段名称约定：<ul>
<li>id</li>
<li>name</li>
<li>state</li>
<li>create_time</li>
<li>update_time</li>
<li>delete_time</li>
<li>expire_time</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>约定</tag>
      </tags>
  </entry>
  <entry>
    <title>日志记录规范</title>
    <url>/2020/04/19/%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="日志格式和规范"><a href="#日志格式和规范" class="headerlink" title="日志格式和规范"></a>日志格式和规范</h1><p>[TOC]</p>
<h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>一个项目各个log级别的定义应该是清楚明确的，是每个开发人员所遵循的； 即使是TRACE或者DEBUG级别的日志，也应该有一定的规范，要保证除了开发人员自己以外，包括测试人员和运维人员都可以方便地通过日志定位问题； 对于日志级别的分类，有以下参考：</p>
<blockquote>
<ol>
<li>FATAL — 表示需要立即被处理的系统级错误。当该错误发生时，表示服务已经出现了某种程度的不可用，系统管理员需要立即介入。这属于最严重的日志级别，因此该日志级 别必须慎用，如果这种级别的日志经常出现，则该日志也失去了意义。通常情况下，一个进程的生命周期中应该只记录一次FATAL级别的日志，即该进程遇到无 法恢复的错误而退出时。当然，如果某个系统的子系统遇到了不可恢复的错误，那该子系统的调用方也可以记入FATAL级别日志，以便通过日志报警提醒系统管 理员修复；</li>
<li>ERROR — 该级别的错误也需要马上被处理，但是紧急程度要低于FATAL级别。当ERROR错误发生时，已经影响了用户的正常访问。从该意义上来说，实际上 ERROR错误和FATAL错误对用户的影响是相当的。FATAL相当于服务已经挂了，而ERROR相当于好死不如赖活着，然而活着却无法提供正常的服 务，只能不断地打印ERROR日志。特别需要注意的是，ERROR和FATAL都属于服务器自己的异常，是需要马上得到人工介入并处理的。而对于用户自己 操作不当，如请求参数错误等等，是绝对不应该记为ERROR日志的；</li>
<li>WARN — 该日志表示系统可能出现问题，也可能没有，这种情况如网络的波动等。对于那些目前还不是错误，然而不及时处理也会变为错误的情况，也可以记为WARN日 志，例如一个存储系统的磁盘使用量超过阀值，或者系统中某个用户的存储配额快用完等等。对于WARN级别的日志，虽然不需要系统管理员马上处理，也是需要 即使查看并处理的。因此此种级别的日志也不应太多，能不打WARN级别的日志，就尽量不要打；</li>
<li>INFO — 该种日志记录系统的正常运行状态，例如某个子系统的初始化，某个请求的成功执行等等。通过查看INFO级别的日志，可以很快地对系统中出现的 WARN,ERROR,FATAL错误进行定位。INFO日志不宜过多，通常情况下，INFO级别的日志应该不大于TRACE日志的10%；</li>
<li>DEBUG or TRACE — 这两种日志具体的规范应该由项目组自己定义，该级别日志的主要作用是对系统每一步的运行状态进行精确的记录。通过该种日志，可以查看某一个操作每一步的执 行过程，可以准确定位是何种操作，何种参数，何种顺序导致了某种错误的发生。可以保证在不重现错误的情况下，也可以通过DEBUG（或TRACE）级别的 日志对问题进行诊断。需要注意的是，DEBUG日志也需要规范日志格式，应该保证除了记录日志的开发人员自己外，其他的如运维，测试人员等也可以通过 DEBUG（或TRACE）日志来定位问题；</li>
</ol>
</blockquote>
<h2 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h2><p>日志从功能来说，可分为诊断日志、统计日志、审计日志。</p>
<p>诊断日志， 典型的有：</p>
<p>请求入口和出口 外部服务调用和返回 资源消耗操作: 打开文件等 容错行为： 譬如云硬盘的副本修复操作 程序异常： 譬如数据库无法连接 后台操作：清理程序 启动、关闭、配置加载 抛出异常时，不记录日志</p>
<p>统计日志：</p>
<p>用户访问统计 计费日志（如记录用户使用的网络资源或磁盘占用，格式较为严格，便于统计）</p>
<p>审计日志：</p>
<p>管理操作 将不同需求的日志记入到不同的日志文件中，可以方便相关问题（管理平台操作审计，用户操作计费等）的处理。针对每一种需求，需要对日志的格式，日志记录的内容等进行特别的记录。</p>
<h2 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h2><p>需要在日志中记录的内容有：</p>
<blockquote>
<p>在系统启动或初始化时记录重要的系统初始化参数 </p>
<p>记录系统运行过程中的所有的错误 </p>
<p>记录系统运行过程中的所有的警告 </p>
<p>在持久化数据修改时记录修改前和修改后的值 </p>
<p>记录系统各主要模块之间的请求和响应 重要的状态变化（如用户咨询状态改变等） </p>
<p>系统中一些长期执行的任务的执行进度</p>
</blockquote>
<p>测试日志应该包含以下内容：</p>
<blockquote>
<p>测试执行的环境 </p>
<p>测试执行前的初始状态 </p>
<p>测试的详细步骤 </p>
<p>测试和系统的交互信息 </p>
<p>测试期望的返回结果 测试实际的返回结果</p>
</blockquote>
<h2 id="最佳日志实践"><a href="#最佳日志实践" class="headerlink" title="最佳日志实践"></a>最佳日志实践</h2><p><a href="http://blog.jobbole.com/56574/" target="_blank" rel="noopener">http://blog.jobbole.com/56574/</a></p>
<p><a href="http://tech.lede.com/2017/06/30/rd/server/loggingHabit/" target="_blank" rel="noopener">http://tech.lede.com/2017/06/30/rd/server/loggingHabit/</a></p>
<p><a href="https://www.jianshu.com/p/8551fe9c6354" target="_blank" rel="noopener">https://www.jianshu.com/p/8551fe9c6354</a></p>
<h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><p>一般必备的日志参数：时间、RequestID、日志等级、日志内容。</p>
<table>
<thead>
<tr>
<th>日志类型</th>
<th>格式</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>登录、退出</td>
<td><code>请求时间</code>、<code>用户IP</code>、<code>用户名</code>、<code>渠道信息</code>、<code>用户浏览器信息</code>、<code>登出结果</code>、<code>请求花费时间</code>、<code>tokenid</code>、<code>sessionid</code></td>
<td></td>
</tr>
<tr>
<td>业务操作日志</td>
<td>请求时间、接口URL、接口方法、调用结果、执行时间</td>
<td></td>
</tr>
<tr>
<td>HTTP请求</td>
<td><code>访问时间</code>、<code>用户IP</code>、<code>访问的URL</code>、<code>用户浏览器信息</code>、<code>HTTP状态码</code>、<code>请求处理时间</code></td>
<td></td>
</tr>
<tr>
<td>vsphere虚拟机性能</td>
<td>时间、resource_type、dev_type、dev_name、dev_id、datacenter、host、cluster、endpoint、mertic_name、metric_value、metric_unit</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>log</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>日志采集选型分析</title>
    <url>/2020/04/19/%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E4%B8%8E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="日志采集选型分析"><a href="#日志采集选型分析" class="headerlink" title="日志采集选型分析"></a>日志采集选型分析</h1><p>[TOC]</p>
<h3 id="日志的数据源有哪些？"><a href="#日志的数据源有哪些？" class="headerlink" title="日志的数据源有哪些？"></a>日志的数据源有哪些？</h3><table>
<thead>
<tr>
<th>数据源</th>
<th>数据源的数据类型<br>【采集方式】</th>
<th>业务类型</th>
</tr>
</thead>
<tbody><tr>
<td>java web log、tomcat、nginx、apache log</td>
<td>txt</td>
<td>软件服务器日志文件、SQL日志</td>
</tr>
<tr>
<td>http 接口</td>
<td>http</td>
<td>采集机数据服务或其他业务系统的数据服务</td>
</tr>
<tr>
<td>网络设备</td>
<td>snmp</td>
<td>管理网络设备</td>
</tr>
<tr>
<td>hdfs、hbasae</td>
<td>hdfs、hbasae</td>
<td>已经被存储的历史业务数据</td>
</tr>
<tr>
<td>脚本命令</td>
<td>shell、python的命令结果</td>
<td>待定</td>
</tr>
<tr>
<td>物理机或虚拟机</td>
<td>运行时物理机性能</td>
<td>服务所在主机</td>
</tr>
<tr>
<td>kafka，rabbitmq</td>
<td>消息队列缓存</td>
<td>业务数据在消息队列中</td>
</tr>
<tr>
<td>syslog</td>
<td>tcp、udp</td>
<td>系统日志</td>
</tr>
</tbody></table>
<h3 id="日志的格式有哪些？"><a href="#日志的格式有哪些？" class="headerlink" title="日志的格式有哪些？"></a>日志的格式有哪些？</h3><p>日志的数据类型如上图。</p>
<p>传统的日志格式是面向用户的，所以难以解析。我们要做日志采集和分析平台，就不能随意的输出日志，必须按照一定的格式输出并存储。</p>
<p>常用的日志格式：基于分隔符分割的日志，JSON日志，JavaStack多行日志</p>
<p>常用文本日志的数据格式：<a href="https://help.aliyun.com/document_detail/28987.html?spm=a2c4g.11186623.6.583.ryJz66" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/28987.html?spm=a2c4g.11186623.6.583.ryJz66</a></p>
<h3 id="采集日志的框架有哪些？"><a href="#采集日志的框架有哪些？" class="headerlink" title="采集日志的框架有哪些？"></a>采集日志的框架有哪些？</h3><table>
<thead>
<tr>
<th>采集框架</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>logstash</td>
<td></td>
<td></td>
</tr>
<tr>
<td>filebeat</td>
<td></td>
<td></td>
</tr>
<tr>
<td>fluentd</td>
<td></td>
<td></td>
</tr>
<tr>
<td>flume</td>
<td></td>
<td></td>
</tr>
<tr>
<td>在线日志平台提供的SDK</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="日志采集的高性能如何实现？从大数据环境考虑"><a href="#日志采集的高性能如何实现？从大数据环境考虑" class="headerlink" title="日志采集的高性能如何实现？从大数据环境考虑"></a>日志采集的高性能如何实现？从大数据环境考虑</h3><p> 采集端：由采集端本身决定，尤其是采集端的缓存策略是基于内存还是文件。可以通过一台机器部署多个采集进程提高采集吞吐量。</p>
<p>接收端：通过集群增加数据传输吞吐量。</p>
<p>消息队列：对于大数据采集，可以通过消息队列提高数据流的稳定性。</p>
<h3 id="日志采集的高可用如何实现？从采集端不可用和接收端不可用的情况下考虑"><a href="#日志采集的高可用如何实现？从采集端不可用和接收端不可用的情况下考虑" class="headerlink" title="日志采集的高可用如何实现？从采集端不可用和接收端不可用的情况下考虑"></a>日志采集的高可用如何实现？从采集端不可用和接收端不可用的情况下考虑</h3><ul>
<li><p>采集端不可用：</p>
<table>
<thead>
<tr>
<th>采集方式</th>
<th>故障类型</th>
<th>实现高可用</th>
</tr>
</thead>
<tbody><tr>
<td>agent采集</td>
<td>agent死机、网络故障无法连接接收端、进程奔溃</td>
<td>实现本地缓存或存储日志采集的偏移量</td>
</tr>
<tr>
<td>ssh、脚本命令、虚拟机性能采集</td>
<td>死机</td>
<td>无法恢复</td>
</tr>
<tr>
<td>kafka、hdfs类型</td>
<td>采集端死机或崩溃</td>
<td>从kafka、hdfs历史数据恢复采集</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>接收端不可用：</p>
<p>发送端要自动进行故障转移，将数据发送到没有问题的接收端。</p>
<p>接收端要提供负载均衡，保证即使存在故障的接收端，也可以提供数据接收服务。</p>
<p><strong>这里的接收端，可能是存储端，也可能是中间件接收端，例如Kafka</strong>，总之，都要提供高可用服务。</p>
</li>
</ul>
<h3 id="日志存储方案有哪些？从大数据和高可用考虑"><a href="#日志存储方案有哪些？从大数据和高可用考虑" class="headerlink" title="日志存储方案有哪些？从大数据和高可用考虑"></a>日志存储方案有哪些？从大数据和高可用考虑</h3><ul>
<li>Hdfs </li>
<li>Habase</li>
<li>ElasticSearch</li>
</ul>
<p>都提供基于数据分片和复制的数据安全方案。</p>
<h3 id="日志采集和存储的伸缩性。"><a href="#日志采集和存储的伸缩性。" class="headerlink" title="日志采集和存储的伸缩性。"></a>日志采集和存储的伸缩性。</h3><table>
<thead>
<tr>
<th>分析和存储方案</th>
<th>伸缩性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>hdfs</td>
<td>优</td>
<td></td>
</tr>
<tr>
<td>hbase</td>
<td>基于HDFS，优</td>
<td></td>
</tr>
<tr>
<td>ElasticSearch</td>
<td>优</td>
<td></td>
</tr>
<tr>
<td>kafka</td>
<td>优</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="日志分析方案有哪些？优先从大数据和高可用考虑，其他考虑日志分析服务的性能"><a href="#日志分析方案有哪些？优先从大数据和高可用考虑，其他考虑日志分析服务的性能" class="headerlink" title="日志分析方案有哪些？优先从大数据和高可用考虑，其他考虑日志分析服务的性能"></a>日志分析方案有哪些？优先从大数据和高可用考虑，其他考虑日志分析服务的性能</h3><ul>
<li>ElasticSearch</li>
<li>Hadoop MapReduce</li>
<li>Hbase 接口</li>
<li>在线的日志平台</li>
</ul>
<h3 id="日志分析，我们的关注点数据，聚焦在哪里？"><a href="#日志分析，我们的关注点数据，聚焦在哪里？" class="headerlink" title="日志分析，我们的关注点数据，聚焦在哪里？"></a>日志分析，我们的关注点数据，聚焦在哪里？</h3><p>目前从公司角度来说：</p>
<p>TCRC：虚拟机性能采集和TCRC用户操作日志</p>
<p>容器：容器运行时性能</p>
<h3 id="日志采集和分析方案的价值在哪里？从客户和公司角度分析"><a href="#日志采集和分析方案的价值在哪里？从客户和公司角度分析" class="headerlink" title="日志采集和分析方案的价值在哪里？从客户和公司角度分析"></a>日志采集和分析方案的价值在哪里？从客户和公司角度分析</h3><ul>
<li>可用性监控【提供实时性能日志和运行日志的分析，或者对接监控平台，提高系统的可用性监控】</li>
<li>性能监控</li>
<li>故障根源分析【故障溯源】</li>
<li>安全审计</li>
<li>大数据建模，提供后续数据价值。【人物画像，基于大数据和人工智能的自动化运维】</li>
</ul>
<h3 id="日志分析结果展示方案有哪些？"><a href="#日志分析结果展示方案有哪些？" class="headerlink" title="日志分析结果展示方案有哪些？"></a>日志分析结果展示方案有哪些？</h3><table>
<thead>
<tr>
<th>分析平台</th>
<th>展示方法</th>
</tr>
</thead>
<tbody><tr>
<td>ElasticSearch</td>
<td>Kibana，Graylog：提供强大的日志分析和聚合的视图页面。<br>或者基于Elsearch的接口自定义开发</td>
</tr>
<tr>
<td>Hbase</td>
<td>提供页面，但是不能作为一个日志分析平台页面。</td>
</tr>
<tr>
<td>在线的日志平台</td>
<td>提供一个完善的分析视图页面</td>
</tr>
</tbody></table>
<h3 id="日志是否支持后期二次分析？"><a href="#日志是否支持后期二次分析？" class="headerlink" title="日志是否支持后期二次分析？"></a>日志是否支持后期二次分析？</h3><p>基本上，所有的日常存储都是长期大数据存储，所以后续分析应该不是问题。</p>
<p>并且数据存储在ElasticSearch和HDFS可以互相导入，有利于结合使用HDFS数据备份和ElasticSearch数据分析</p>
<h3 id="开发自定义日志分析接口"><a href="#开发自定义日志分析接口" class="headerlink" title="开发自定义日志分析接口"></a>开发自定义日志分析接口</h3><table>
<thead>
<tr>
<th>框架</th>
<th>难度</th>
<th>开发</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>复杂</td>
<td>基于MapReduce开发日志分析</td>
</tr>
<tr>
<td>Hbase</td>
<td>简单</td>
<td>基于Hbase客户端开发查询接口</td>
</tr>
<tr>
<td>ElasticSearch</td>
<td>简单</td>
<td>基于ElasticSearch客户端开发查询接口</td>
</tr>
<tr>
<td>以上接口都可以做简单的聚合查询，实现sum、ave、min、   rowcount等</td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>日志采集</category>
      </categories>
      <tags>
        <tag>日志采集</tag>
        <tag>ELK</tag>
        <tag>日志</tag>
        <tag>Flume</tag>
      </tags>
  </entry>
  <entry>
    <title>日志采集工具比较</title>
    <url>/2020/04/19/%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%B7%A5%E5%85%B7%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1 id="日志采集工具比较"><a href="#日志采集工具比较" class="headerlink" title="日志采集工具比较"></a>日志采集工具比较</h1><table>
<thead>
<tr>
<th></th>
<th>Flume</th>
<th>LogStash</th>
<th>Fluentd</th>
<th>Kafka</th>
<th>Filebeta</th>
<th>Apache Chukwa</th>
</tr>
</thead>
<tbody><tr>
<td>版本</td>
<td>1.8.0</td>
<td>6.3</td>
<td></td>
<td></td>
<td><a href="https://www.elastic.co/guide/en/beats/filebeat/current/index.html" target="_blank" rel="noopener">6.3</a></td>
<td></td>
</tr>
<tr>
<td>开发语言</td>
<td>Java1.8</td>
<td>JRuby</td>
<td>CRuby</td>
<td>Java</td>
<td>go</td>
<td></td>
</tr>
<tr>
<td>简介</td>
<td></td>
<td></td>
<td>JSON作为数据格式。，易于解析</td>
<td>一个成熟的高性能消息队列</td>
<td>轻量级的日志传输工具，支持对接logstash，elsearch。 性能非常好，部署简单</td>
<td>活跃度很低</td>
</tr>
<tr>
<td>成本</td>
<td>开源</td>
<td>免费</td>
<td>开源</td>
<td>开源</td>
<td>开源</td>
<td>开源</td>
</tr>
<tr>
<td>架构</td>
<td>Agent由source，channel、sink组成。多个Agent可以组成调用链</td>
<td>input、Filter、output组成。</td>
<td>Input：完成输入数据的读取，由source部分配置  Parser：解析插件  Output：完成输出数据的操作，由match部分配置  Formatter：消息格式化的插件，属于filter类型  Buffer：缓存插件，用于缓存数据</td>
<td></td>
<td><a href="https://www.cnblogs.com/louis2008/p/filebeat.html" target="_blank" rel="noopener">Filebeta</a></td>
<td></td>
</tr>
<tr>
<td>容错性</td>
<td>优秀，消息发送事务和重试、下游崩溃时消息磁盘存档</td>
<td>假如 Logstash 节点发生故障，Logstash 会通过持久化队列来保证运行中的事件至少一次被送达（at-least-once delivery）。那些未被正常处理的消息会被送往死信队列（dead letter queue）以便做进一步处理。由于具备了这种吸收吞吐量的能力，现在您无需采用额外的队列层，Logstash 就能平稳度过高峰期</td>
<td>缓冲，负载平衡，超时和重试的支持。</td>
<td>优秀</td>
<td>无</td>
<td></td>
</tr>
<tr>
<td>负载均衡</td>
<td>支持sink端故障转移和负载均衡策略，<a href="https://blog.csdn.net/looklook5/article/details/40583815" target="_blank" rel="noopener">博客</a>。</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>性能拓展</td>
<td>单个Agent配置多个sink提高性能</td>
<td></td>
<td>比较注重<em>性能</em>的地方采用C编写</td>
<td>高性能，高吞吐量</td>
<td></td>
<td></td>
</tr>
<tr>
<td>功能拓展</td>
<td>1. 可以下载源代码拓展 2.支持开发插件</td>
<td>ruby拓展开发插件</td>
<td></td>
<td>需要自己开发各种采集端</td>
<td></td>
<td></td>
</tr>
<tr>
<td>采集插件</td>
<td>Exec、JMS、Directory、 Tail、Syslog、Http、自定义</td>
<td>file、syslog、http、kafka、snmp、rabbitmq</td>
<td>多种，支持SNMP</td>
<td>无</td>
<td>适用于文件日志的采集端，替代 logstash-input-file 。</td>
<td></td>
</tr>
<tr>
<td>缓存队列（缓存通道）</td>
<td>Memory、Jdbc、Kafka、File、自定义</td>
<td>无，只发送至Redis或Kafka</td>
<td>支持缓存通道</td>
<td>本身有一个很好的存储机制，支持内存和磁盘可靠性</td>
<td></td>
<td></td>
</tr>
<tr>
<td>日志过滤</td>
<td>需要自定义采集插件实现日志过滤</td>
<td>多种Filter插件：grok、json、drop、mutate、date、clone等，支持结构化解析文本、事件克隆、丢弃、字段转换</td>
<td>支持多种过滤插件和解析插件</td>
<td>无</td>
<td></td>
<td></td>
</tr>
<tr>
<td>发送插件</td>
<td>HDFS、Hive、File、Null、Hbase、Kafka、Http、自定义</td>
<td>多种</td>
<td>多种</td>
<td>无</td>
<td></td>
<td></td>
</tr>
<tr>
<td>性能</td>
<td><a href="https://www.cnblogs.com/yueyanyu/p/6972802.html" target="_blank" rel="noopener">Flume1.4报告</a></td>
<td><a href="https://blog.csdn.net/u010871982/article/details/79035317/" target="_blank" rel="noopener"> <strong>logstash及filebeat内存占用对比</strong> </a>，<a href="http://chenlinux.com/2014/10/18/performance-testing-tunning-for-logstash-inputs-syslog/" target="_blank" rel="noopener">Logstash性能优化</a></td>
<td></td>
<td></td>
<td><a href="https://www.jianshu.com/p/0802cf22a135" target="_blank" rel="noopener">测试</a></td>
<td></td>
</tr>
<tr>
<td>缺点</td>
<td>没有snmp插件</td>
<td>性能和资源消耗较大。推荐logbeat采集数据，Logstash过滤日志。日志的容错性没有flume和fluentd号</td>
<td>输入输出插件没有logstash灵活。中文文档较少</td>
<td>没有可用的采集插件，更多的是用作消息缓存和转发</td>
<td>插件较少</td>
<td></td>
</tr>
<tr>
<td>安装文档</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Flume-架构"><a href="#Flume-架构" class="headerlink" title="Flume 架构"></a>Flume <strong>架构</strong></h3><p>多个Agent连接形成Agent链： </p>
<p><img src="https://tva4.sinaimg.cn/large/007S2YVMgy1gdzim9qz1ej30hn0bt408.jpg" alt="image"> </p>
<p>多路Agent:</p>
<p><img src="https://tva3.sinaimg.cn/large/007S2YVMgy1gdzin6f68fj30hc0a4gmo.jpg" alt="image"></p>
<p>实现load balance功能：</p>
<p><img src="https://tvax1.sinaimg.cn/large/007S2YVMgy1gdzino1ly0j30jg09mtb2.jpg" alt="img"></p>
<h3 id="FileBeta"><a href="#FileBeta" class="headerlink" title="FileBeta"></a>FileBeta</h3><p><img src="https://tva3.sinaimg.cn/large/007S2YVMgy1gdzio8robej30fe0c2mye.jpg" alt="img"> </p>
]]></content>
      <categories>
        <category>日志采集</category>
      </categories>
      <tags>
        <tag>日志采集</tag>
        <tag>ELK</tag>
        <tag>日志</tag>
        <tag>Flume</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型、异常处理、类加载、反射、引用</title>
    <url>/2020/04/19/%E6%B3%9B%E5%9E%8B%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="泛型、异常处理、类加载、反射、引用"><a href="#泛型、异常处理、类加载、反射、引用" class="headerlink" title="泛型、异常处理、类加载、反射、引用"></a>泛型、异常处理、类加载、反射、引用</h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>概念：一种编译时概念，表明容器对象内部元素类型，支持在编译时校验元素类型，但在运行时擦除的元素具体类型，统一用Object表示。简言之，泛型能够使<strong>类型</strong>（类和接口）在定义类，接口和方法的时候参数化。好处：消除类型转换。</p>
<h3 id="java6泛型"><a href="#java6泛型" class="headerlink" title="java6泛型"></a>java6泛型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; myMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="java7泛型"><a href="#java7泛型" class="headerlink" title="java7泛型"></a>java7泛型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; myMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="java8泛型"><a href="#java8泛型" class="headerlink" title="java8泛型"></a>java8泛型</h3><ol>
<li><p>支持通过方法上下文推断泛型目标类型</p>
</li>
<li><p>支持在方法调用链路当中，泛型类型推断传递到最后一个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">list.addAll(new ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="泛型通配符："><a href="#泛型通配符：" class="headerlink" title="泛型通配符："></a>泛型通配符：</h3><ol>
<li>泛型通配符：<code>?</code></li>
</ol>
<p>表示任意类型的泛型类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>通配符继承(<strong>上界&lt; ? extends Class&gt;</strong>)：<code>? extend Object</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Number&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">list &#x3D; new ArrayList&lt;Number&gt;();</span><br><span class="line">list &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">Number number &#x3D; list.get(0);</span><br></pre></td></tr></table></figure>

<p>list中存放的都是Number的子类型表示的对象，这里表示存放有任意类型的子类型，所以反而不能向里面添加元素，要添加的元素编译器无法判断是否与List中的元素类型相同。</p>
<p>​</p>
</li>
<li><p>通配符超类(<strong>下界&lt; ? super Class&gt;</strong>)：<code>? super Object</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;? super Number&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">list.add(new Integer(1));</span><br><span class="line">list.add(new Long(1L));</span><br><span class="line">Object object &#x3D; list.get(0);</span><br></pre></td></tr></table></figure>

<p>list中存放的都是Number的超类能表示的对象，这里表示能存放任意类型的超类，所以意味着可以向list中添加任意类型的对象，因为Object是Number的超类，所以list能存放任意的object对象。</p>
</li>
<li><ul>
<li>如果要从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends) </li>
<li>如果要从集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super) </li>
<li>如果既要存又要取，那么就不要使用任何通配符。</li>
</ul>
</li>
</ol>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><img src="https://tvax4.sinaimg.cn/large/007S2YVMgy1gdzjfcitv6j30hs0bcacg.jpg" alt="image"></p>
<p>实践：</p>
<ol>
<li><p>在所有方法上标记方法内被抛出的异常（无论是受检异常还是运行时异常），写注释时增加异常的注释信息</p>
</li>
<li><p>建立统一的自定义异常处理和通用异常处理</p>
</li>
<li><p>了解try-catch-finally顺序</p>
<ol>
<li>不管有木有出现异常，finally块中代码都会执行；</li>
<li>当try和catch中有return时，finally仍然会执行；</li>
<li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；</li>
<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值</li>
</ol>
</li>
<li><p>了解异常堆栈信息</p>
<p>异常堆栈信息提供了导致异常出现的方法调用链的精确顺序，包括每个方法调用的类名，方法名，代码文件名甚至行数，以此来精确定位异常出现的现场。</p>
</li>
<li><p>try-catch与性能</p>
<p>try-catch块会影响性能，但是并非很多，仅仅最重要的是只有在发生异常时，收集调用堆栈比较复杂。如果不抛出异常，那么性能消耗完全不明显。但是我们推荐的是尽量少用try-catch，因为代码的复杂度和可理解性的原因</p>
<p>​</p>
</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>这个东西用的实在实在太少。不说了，有兴趣的人可以自己去了解。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>很多Java框架，都跟反射离不开关系。因为有反射，所以框架实现了对通用数据结构的解析。反射实现了对Java对象元数据的获取。通过丰富的元数据，可以灵活地实现动态查询和赋值，例如动态调用方法、动态设置字段值。</p>
<table>
<thead>
<tr>
<th>方法关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>getDeclaredMethods()</td>
<td>获取所有的方法</td>
</tr>
<tr>
<td>getReturnType()</td>
<td>获得方法的放回类型</td>
</tr>
<tr>
<td>getParameterTypes()</td>
<td>获得方法的传入参数类型</td>
</tr>
<tr>
<td>getDeclaredMethod(“方法名”,参数类型.class,……)</td>
<td>获得特定的方法</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>构造方法关键字</td>
<td>含义</td>
</tr>
<tr>
<td>getDeclaredConstructors()</td>
<td>获取所有的构造方法</td>
</tr>
<tr>
<td>getDeclaredConstructor(参数类型.class,……)</td>
<td>获取特定的构造方法</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>父类和父接口</td>
<td>含义</td>
</tr>
<tr>
<td>getSuperclass()</td>
<td>获取某类的父类</td>
</tr>
<tr>
<td>getInterfaces()</td>
<td>获取某类实现的接口</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>字段</td>
<td></td>
</tr>
<tr>
<td>getFields()</td>
<td>获得某个类的所有的公共(public)的字段,包括父类。</td>
</tr>
<tr>
<td>getDeclaredFields()</td>
<td>获得某个类的所有申明的字段,即包括public、private和proteced，不包括父类</td>
</tr>
</tbody></table>
<ol>
<li><p>Accessable: Accessible并不是标识方法能否访问的. public的方法 Accessible仍为false .<br>Accessable属性是继承自AccessibleObject 类. 功能是启用或禁用安全检查。将此对象的 accessible 标志设置为指示的布尔值。值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查。</p>
<p>当isAccessible()的结果是false时不允许通过外部类反射访问私有字段。</p>
</li>
<li><p>反射获取注解</p>
<p>这个是一个比较常用的方法，尤其在写AOP切面时。</p>
<p>通过AOP的功能，我们可以拦截指定带有注解的方法。在执行AOP时，可以通过方法对象来获取注解上的参数。</p>
<table>
<thead>
<tr>
<th>method.getAnnoations()</th>
<th>获取方法上所有注解</th>
</tr>
</thead>
<tbody><tr>
<td>method.getDeclaredAnnotations()</td>
<td>获取当前方法上的注解，忽略继承来的注解</td>
</tr>
<tr>
<td>method.getParameterAnnotations()</td>
<td>获取方法参数上的注解，返回一个二维数组</td>
</tr>
<tr>
<td>method.getAnnotatedReturnType()</td>
<td>jdk1.8，返回方法返回值上的注解类型</td>
</tr>
<tr>
<td>method.getAnnotation(class)</td>
<td>根据类型返回单个注解，了解@ Repeatable</td>
</tr>
<tr>
<td>method.getAnnotationsByType</td>
<td>根据类型返回注解数组</td>
</tr>
<tr>
<td>field、class省略</td>
<td></td>
</tr>
</tbody></table>
<p><a href="http://www.howsoftworks.net/javaapi/java.lang/indexclass.html" target="_blank" rel="noopener">http://www.howsoftworks.net/javaapi/java.lang/indexclass.html</a></p>
</li>
</ol>
<h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><p>值传递：方法调用时，实际参数把它的值传递给对应的形式参数，方法执行中形式参数值的改变不影响实际参 数的值。</p>
<p>引用传递：也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，方法执行中形式参数值的改变将会影响实际参数的值。</p>
<p>Java中都是地址值引用，并不是引用传递。</p>
<p>⑴强引用（StrongReference）<br>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。  ps：强引用其实也就是我们平时A a = new A()这个意思。</p>
<p>⑵软引用（SoftReference）<br>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存（下文给出示例）。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>⑶弱引用（WeakReference）<br>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>⑷虚引用（PhantomReference）<br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
